<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX6FE21C7438844A5AAFDF19C6F6718A93">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBXEB124388A6334D23877A509D8D732BFA</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<token name="UnionsScaleNonuniformly">0</token>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b5664</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBXEB124388A6334D23877A509D8D732BFA">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>29.6581402</X>
					<Y>93.718605</Y>
					<Z>3.89688277</Z>
					<R00>-0.145599335</R00>
					<R01>-0.725613654</R01>
					<R02>0.672521889</R02>
					<R10>-7.4505806e-09</R10>
					<R11>0.679765761</R11>
					<R12>0.733429313</R12>
					<R20>-0.989343643</R20>
					<R21>0.10678681</R21>
					<R22>-0.0989734381</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>28.313097</X>
					<Y>92.2517471</Y>
					<Z>4.09482956</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b725d</UniqueId>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXE241642F2854445CB3997D9601C0C9B6">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b725f</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">0</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX5D4EF9A8E1C94C3DB574CE8FB5DE5A95">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAb34+WFlWmJiY6fTyz8unrJRsY2Rm3eTl6/3/lHxfeXBiS0pKjIJo/xhDUFRUhoZ2
zNLfaoZA///+//PAj5CH]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7263</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX0192E1F34BB1438C830498D45C005E8F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">GetParsedTokens</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5c33de30e8b23bd60301373a001b3c51</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX383D7EB071894C7D8F4BC14BB64324A5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LuaSyntaxToolset</string>
					<string name="ScriptGuid">{58D886FE-A3BC-4234-9328-C21BFAB2FA60}</string>
					<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.lookupify)
local formatTable = require(script.formatTable)

local tokenize = require(script.tokenize)
local parse = require(script.parse)

local printAst = require(script.printAst)
local stripAst = require(script.stripAst)
local formatAst = require(script.formatAst)

local addVariableInfo = require(script.addVariableInfo)
local beautifyVariables = require(script.beautifyVariables)
local minifyVariables = require(script.minifyVariablesAdvanced)

local decodeStrings = require(script.decodeStrings)
local encodeStrings = require(script.encodeStrings)

local Keywords = require(script.Keywords)
local WhitespaceCharacters = require(script.WhitespaceCharacters)
local AllIdentifierCharacters = require(script.AllIdentifierCharacters)

local LuaSyntaxToolset = {}

function LuaSyntaxToolset.minify(source: string, renameGlobals: boolean, doEncodeStrings: boolean)
	local tokens = tokenize(source)
	local ast = parse(tokens)
	local glb, root = addVariableInfo(ast)
	minifyVariables(glb, root, renameGlobals)
	if doEncodeStrings then
		encodeStrings(tokens)
	end
	stripAst(ast)
	return printAst(ast)
end

--[[
string source: The source code to beautify
bool renameVars: Should the local variables be renamed into easily find-replacable naming for reverse engineering?
bool renameGlobals: Should the same be done for globals? (unsafe if get/setfenv were used)
]]
function LuaSyntaxToolset.beautify(source: string, renameVars: boolean, renameGlobals: boolean, doDecodeStrings: boolean)
	local tokens = tokenize(source)
	local ast = parse(tokens)
	local glb, root = addVariableInfo(ast)
	if renameVars then
		beautifyVariables(glb, root, renameGlobals)
	end
	if doDecodeStrings then
		decodeStrings(tokens)
	end
	formatAst(ast)
	return printAst(ast)
end

return LuaSyntaxToolset
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bc6</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX1A085173E20F4DF197E99A34B5ECF807">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tokenize</string>
						<string name="ScriptGuid">{DB020844-8A15-48FA-AE4A-370CCA07A9FE}</string>
						<ProtectedString name="Source"><![CDATA[
--[[
function tokenize(text)

Turn a string containing Lua code into an array of tokens.
]]

local lookupify = require(script.Parent.lookupify)

-- Whitespace characters
local WhitespaceCharacters = require(script.Parent.WhitespaceCharacters)

local CharacterForEscape = {['r'] = '\r', ['n'] = '\n', ['t'] = '\t', ['"'] = '"', ["'"] = "'", ['\\'] = '\\'}

local AllIdentStartChars = lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
                                     'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
                                     's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                                     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
                                     'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
                                     'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_'}

local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

local Keywords = require(script.Parent.Keywords)

local BinaryDigits = lookupify{'0', '1'}
local Digits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
local DigitsPlusSeparator = lookupify{'_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
local HexDigits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
	                            'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'}

local Symbols = lookupify{'+', '-', '*', '/', '^', '%', ',', '{', '}', '[', ']', '(', ')', ';', '#', '.', ':', '?', '|', '&'}

local EqualSymbols = lookupify{
	'~', '=', '>', '<', -- Lua 5.1
	'+', '-', '*', '/', '^', '%', -- Luau
}


local function tokenize(text)
	-- Tracking for the current position in the buffer, and
	-- the current line / character we are on.
	local p = 1
	local length = #text

	-- Output buffer for tokens
	local tokenBuffer = {}

	-- Get a character, or '' if at eof
	local function look(n)
		n = n or 0
		if p <= length then
			return text:sub(p + n, p + n)
		else
			return ''
		end
	end
	local function get()
		if p <= length then
			local c = text:sub(p, p)
			p = p + 1
			return c
		else
			return ''
		end
	end

	-- Error
	local olderr = error
	local function error(str)
		local q = 1
		local line = 1
		local char = 1
		while q <= p do
			if text:sub(q, q) == '\n' then
				line = line + 1
				char = 1
			else
				char = char + 1
			end
			q = q + 1
		end
		-- Toggle for debugging		
		--for _, token in pairs(tokenBuffer) do
		--	print(token.Type.."<"..token.Source..">")
		--end
		olderr("file<"..line..":"..char..">: "..str)
	end

	local function warn(str)
		-- TODO: Maybe record for lints or something?
	end

	-- Consume a long data with equals count of `eqcount'
	local function longdata(eqcount)
		while true do
			local c = get()
			if c == '' then
				error("Unfinished long string.")
			elseif c == ']' then
				local done = true -- Until contested
				for i = 1, eqcount do
					if look() == '=' then
						p = p + 1
					else
						done = false
						break
					end
				end
				if done and get() == ']' then
					return
				end
			end
		end
	end

	-- Get the opening part for a long data `[` `=`* `[`
	-- Precondition: The first `[` has been consumed
	-- Return: nil or the equals count
	local function getopen()
		local startp = p
		while look() == '=' do
			p = p + 1
		end
		if look() == '[' then
			p = p + 1
			return p - startp - 1
		else
			p = startp
			return nil
		end
	end

	-- Add token
	local whiteStart = 1
	local tokenStart = 1
	local function token(type)
		local tk = {
			Type = type;
			LeadingWhite = text:sub(whiteStart, tokenStart-1);
			Source = text:sub(tokenStart, p-1);
		}
		table.insert(tokenBuffer, tk)
		whiteStart = p
		tokenStart = p
		return tk
	end

	-- Parse tokens loop
	while true do
		-- Mark the whitespace start
		whiteStart = p

		-- Get the leading whitespace + comments
		while true do
			local c = look()
			if c == '' then
				break
			elseif c == '-' then
				if look(1) == '-' then
					p = p + 2
					-- Consume comment body
					if look() == '[' then
						p = p + 1
						local eqcount = getopen()
						if eqcount then
							-- Long comment body
							longdata(eqcount)
						else
							-- Normal comment body
							while true do
								local c2 = get()
								if c2 == '' or c2 == '\n' then
									break
								end
							end
						end
					else
						-- Normal comment body
						while true do
							local c2 = get()
							if c2 == '' or c2 == '\n' then
								break
							end
						end
					end
				else
					break
				end
			elseif WhitespaceCharacters[c] then
				p = p + 1
			else
				break
			end
		end
		local leadingWhite = text:sub(whiteStart, p-1)

		-- Mark the token start
		tokenStart = p

		-- Switch on token type
		local c1 = get()
		if c1 == '' then
			-- End of file
			token('Eof')
			break
		elseif c1 == '\'' or c1 == '\"' then
			-- String constant
			while true do
				local c2 = get()
				if c2 == '\\' then
					local c3 = get()
					if c3 == 'x' then
						-- Hexidecimal character
						local c4 = get()
						local c5 = get()
						if not HexDigits[c4] or not HexDigits[c5] then
							error("Invalid Hexidecimal Escape Sequence `\\x"..c4..c5.."`")
						end
					elseif c3 == 'u' then
						-- Unicode character
						local c4 = get()
						if c4 ~= '{' then
							error("Invalid Unicode Escape Sequence `\\u"..c4.."`")
						end
						local codePoint = ""
						while true do
							local cbody = get()
							if cbody == '' then
								error("Unfinished Unicode Escape Sequence at End of File")
							elseif cbody == '}' then
								break
							elseif HexDigits[cbody] then
								codePoint = codePoint..cbody
							else
								error("Invalid Unicode Escape Sequence `\\u{"..codePoint..cbody.."`")
							end
						end
						if codePoint == "" then
							error("Empty Unicode Escape Sequence")
						elseif tonumber(codePoint, 16) >= 0x10FFFF then
							error("Unicode Escape Sequence Out of Range")
						end
					elseif c3 == 'z' then
						-- Whitespace trimmer
						-- Nothing to do					
					else						
						local esc = CharacterForEscape[c3]
						if not esc then
							warn("Invalid Escape Sequence `\\"..c3.."`.")
						end
					end
				elseif c2 == c1 then
					break
				end
			end
			token('String')
		elseif AllIdentStartChars[c1] then
			-- Ident or Keyword
			while AllIdentifierCharacters[look()] do
				p = p + 1
			end
			if Keywords[text:sub(tokenStart, p-1)] then
				token('Keyword')
			else
				token('Ident')
			end
		elseif Digits[c1] or (c1 == '.' and Digits[look()]) then
			-- Note: The character directly after the .
			-- Number
			if c1 == '0' and look():lower() == 'x' then
				p = p + 1
				-- Hex number
				while HexDigits[look()] or look() == '_' do
					p = p + 1
				end
			elseif c1 == '0' and look():lower() == 'b' then
				p = p + 1
				-- Binary number
				while BinaryDigits[look()] or look() == '_' do
					p = p + 1
				end
			else
				-- Normal Number
				while DigitsPlusSeparator[look()] do
					p = p + 1
				end
				if look() == '.' then
					-- With decimal point
					p = p + 1
					while DigitsPlusSeparator[look()] do
						p = p + 1
					end
				end
				if look() == 'e' or look() == 'E' then
					-- With exponent
					p = p + 1
					if look() == '-' then
						p = p + 1
					end
					while DigitsPlusSeparator[look()] do
						p = p + 1
					end
				end
			end
			token('Number')
		elseif c1 == '[' then
			-- '[' Symbol or Long String
			local eqCount = getopen()
			if eqCount then
				-- Long string
				longdata(eqCount)
				token('String')
			else
				-- Symbol
				token('Symbol')
			end
		elseif c1 == '.' then
			-- Greedily consume up to 3 `.` for . / .. / ... tokens
			-- Also consume "..=" compound concatenation operator in this case
			if look() == '.' then
				get()
				if look() == '.' or look() == '=' then
					get()
				end
			end
			token('Symbol')
		elseif c1 == '-' and look() == '>' then
			-- Special handling for `->`
			get()
			token('Symbol')
		elseif EqualSymbols[c1] then
			if look() == '=' then
				get()
			end
			token('Symbol')
		elseif Symbols[c1] then
			token('Symbol')
		else
			error("Bad symbol `"..c1.."` in source.")
		end
	end
	return tokenBuffer
end

return tokenize
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bc7</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0906068CA3CE4DCD987C9E99068D4BCA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lookupify</string>
						<string name="ScriptGuid">{66106BA3-4E11-44ED-8177-794338B4DCA7}</string>
						<ProtectedString name="Source"><![CDATA[--[[
function lookupify(array)

Turn an array of items into a set where set[item] = true
Useful for declaring static sets of strings.
]]
return function(tb)
	for _, v in pairs(tb) do
		tb[v] = true
	end
	return tb
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bc8</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX78D46FA9653F4EED8ED2F247358D54EA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tokenize.spec</string>
						<string name="ScriptGuid">{5B7CAA08-7CBF-4091-8903-7255CE1D3817}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local tokenize = require(script.Parent.tokenize)
	
	describe("tokenize", function()
		it("should succeed with no input", function()
			local output = tokenize("")
		end)
		
		it("should parse a basic input", function()
			local output = tokenize("local a = 5")
			expect(#output).to.equal(5) -- local, a, =, 5, EOF
		end)
	end)
	
	describe("new type related operators", function()
		it("should accept the optional type operator as a token", function()
			local output = tokenize("??")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
		
		it("should accept the union operator as a token", function()
			local output = tokenize("||")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
		
		it("should accept the intersection operator as a token", function()
			local output = tokenize("&&")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
	end)
	
	describe("type arrow operator", function()
		it("should parse an arrow as a single token", function()
			local output = tokenize("->->")
			expect(#output).to.equal(3) -- ->, ->, EOF
		end)
	end)
	
	describe("compound operators", function()
		it("should accept Luau compound operators", function()
			local output = tokenize[[+=,-=,%=]]
			expect(#output).to.equal(6)
			local output2 = tokenize[[/=,..=]]
			expect(#output2).to.equal(4)
		end)
	end)
	
	describe("number literals", function()
		it("should accept hexidecimal literals", function()
			tokenize[[0xABC, 0xabc, 0Xabc]]
		end)
		
		it("should accept underscores in number literals", function()
			local output = tokenize[[0xDEAD_BEEF, 100_000, 0x__42__, 0b__0_1_]]
			expect(#output).to.equal(8)
		end)
		
		it("should accept underscores in floating point literals", function()
			local output = tokenize[[.5, 0._7, 12.3_4E_78]]
			expect(#output).to.equal(6)
		end)
	end)
	
	describe("string literals", function()
		it("should parse hex constants", function()
			local output = tokenize[[local a = "\x5A"]]
			expect(#output).to.equal(5)
		end)
		
		it("should fail to parse a bad hex constant", function()
			expect(function()
				local output = tokenize[[local a = "\x5G"]]
			end).to.throw()
		end)
		
		it("should parse unicode constants", function()
			local output = tokenize[[local a = "\u{5Ab}"]]
			expect(#output).to.equal(5)
		end)
		
		it("should fail a unicode constant out of range", function()
			expect(function()
				tokenize[[local a = "\u{6456464}"]]
			end).to.throw()
		end)
		
		it("should fail an empty unicode constant", function()
			expect(function()
				tokenize[[local a = "\u{}"]]
			end).to.throw()
		end)
		
		it("should should fail an unfinished unicode constant", function()
			expect(function()
				tokenize[[local a = "\u{AB"]]
			end).to.throw()
		end)
		
		it("should accept the whitespace trimming escape", function()
			tokenize[[local a = "\z"]]
		end)
		
		it("should accept a bad escape sequence anyways", function()
			-- Lua 5.2+ does not accept the follow, but Lua 5.1 / Luau do
			expect(function()
				tokenize[[local a = "\LOL"]]
			end).never.to.throw()
		end)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bc9</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX57AF6CB81CF64A599A645E236899A284">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">formatTable</string>
						<string name="ScriptGuid">{E7156748-46D8-4A7B-9539-BB17005CBE78}</string>
						<ProtectedString name="Source"><![CDATA[--[[
function formatTable(tb, function
]]

function CountTable(tb)
	local c = 0
	for _ in pairs(tb) do c = c + 1 end
	return c
end

function FormatTableInt(tb, atIndent, ignoreFunc)
	if tb.Print then
		return tb.Print()
	end
	atIndent = atIndent or 0
	local useNewlines = (CountTable(tb) > 1)
	local baseIndent = string.rep('    ', atIndent+1)
	local out = "{"..(useNewlines and '\n' or '')
	for k, v in pairs(tb) do
		if type(v) ~= 'function' and not ignoreFunc(k) then
			out = out..(useNewlines and baseIndent or '')
			if type(k) == 'number' then
				--nothing to do
			elseif type(k) == 'string' and k:match("^[A-Za-z_][A-Za-z0-9_]*$") then 
				out = out..k.." = "
			elseif type(k) == 'string' then
				out = out.."[\""..k.."\"] = "
			else
				out = out.."["..tostring(k).."] = "
			end
			if type(v) == 'string' then
				out = out.."\""..v.."\""
			elseif type(v) == 'number' then
				out = out..v
			elseif type(v) == 'table' then
				out = out..FormatTableInt(v, atIndent+(useNewlines and 1 or 0), ignoreFunc)
			else
				out = out..tostring(v)
			end
			if next(tb, k) then
				out = out..","
			end
			if useNewlines then
				out = out..'\n'
			end
		end
	end
	out = out..(useNewlines and string.rep('    ', atIndent) or '').."}"
	return out
end

local function formatTable(tb, ignoreFunc: (any) -> boolean): ()
	ignoreFunc = ignoreFunc or function() 
		return false
	end
	return FormatTableInt(tb, 0, ignoreFunc)
end

return formatTable
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bca</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX84AC49318D1249B4A1D9157ECDECE8EA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">parse</string>
						<string name="ScriptGuid">{3676560B-6CD7-4093-9ABD-D58CD55E6C3D}</string>
						<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

local BlockFollowKeyword = lookupify{'else', 'elseif', 'until', 'end'}

local UnopSet = lookupify{'-', 'not', '#'}

local BinopSet = lookupify{
	'+', '-', '*', '/', '%', '^', '#',
	'..', '.', ':',
	'>', '<', '<=', '>=', '~=', '==',
	'and', 'or'
}

local AssignmentOperators = lookupify{
	'=', -- Lua 5.1 
	'+=', '-=', '*=', '/=', '^=', '%=', -- Luau
}

local BinaryPriority = {
   ['+'] = {6, 6};
   ['-'] = {6, 6};
   ['*'] = {7, 7};
   ['/'] = {7, 7};
   ['%'] = {7, 7};
   ['^'] = {10, 9};
   ['..'] = {5, 4};
   ['=='] = {3, 3};
   ['~='] = {3, 3};
   ['>'] = {3, 3};
   ['<'] = {3, 3};
   ['>='] = {3, 3};
   ['<='] = {3, 3};
   ['and'] = {2, 2};
   ['or'] = {1, 1};
};
local UnaryPriority = 8

local function parse(tokens)
	-- Pointer into tokens list
	local p = 1

	local function get()
		local tok = tokens[p]
		if p < #tokens then
			p = p + 1
		end
		return tok
	end
	local function peek(n: number | nil)
		n = p + (n or 0)
		return tokens[n] or tokens[#tokens]
	end

	local function getTokenStartPosition(token)
		local line = 1
		local char = 0
		local tkNum = 1
		while true do
			local tk = tokens[tkNum]
			local text;
			if tk == token then
				text = tk.LeadingWhite
			else
				text = tk.LeadingWhite..tk.Source
			end
			for i = 1, #text do
				local c = text:sub(i, i)
				if c == '\n' then
					line = line + 1
					char = 0
				else
					char = char + 1
				end
			end
			if tk == token then
				break
			end
			tkNum = tkNum + 1
		end
		return line..":"..(char+1)
	end
	local function debugMark()
		local tk = peek()
		return "<"..tk.Type.." `"..tk.Source.."`> at: "..getTokenStartPosition(tk)
	end

	local function isBlockFollow()
		local tok = peek()
		return tok.Type == 'Eof' or (tok.Type == 'Keyword' and BlockFollowKeyword[tok.Source])
	end	
	local function isUnop()
		return UnopSet[peek().Source] or false
	end
	local function isBinop()
		return BinopSet[peek().Source] or false
	end
	local function expect(type: string, source: string | nil)
		local tk = peek()
		if tk.Type == type and (source == nil or tk.Source == source) then
			return get()
		else
			for i = -3, 3 do
				print("Tokens["..i.."] = `"..peek(i).Source.."`")
			end
			if source then
				error(getTokenStartPosition(tk)..": `"..source.."` expected.")
			else
				error(getTokenStartPosition(tk)..": "..type.." expected.")
			end
		end
	end

	local function MkNode(node)
		local getf = node.GetFirstToken
		local getl = node.GetLastToken
		function node:GetFirstToken()
			local t = getf(self)
			if not t then
				assert(t)
			end
			return t
		end
		function node:GetLastToken()
			local t = getl(self)
			assert(t)
			return t
		end
		return node
	end

	-- Forward decls
	local block;
	local expr;
	local typeexpr;

	-- Expression list
	local function exprlist()
		local exprList = {}
		local commaList = {}
		table.insert(exprList, expr())
		while peek().Source == ',' do
			table.insert(commaList, get())
			table.insert(exprList, expr())
		end
		return exprList, commaList
	end

	local function prefixexpr()
		local tk = peek()
		if tk.Source == '(' then
			local oparenTk = get()
			local inner = expr()
			local cparenTk = expect('Symbol', ')')
			return MkNode{
				Type = 'ParenExpr';
				Expression = inner;
				Token_OpenParen = oparenTk;
				Token_CloseParen = cparenTk;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif tk.Type == 'Ident' then
			return MkNode{
				Type = 'VariableExpr';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		else
			print(debugMark())
			error(getTokenStartPosition(tk)..": Unexpected symbol")
		end
	end

	function tableexpr()
		local obrace = expect('Symbol', '{')
		local entries: {} = {}
		local separators = {}
		while peek().Source ~= '}' do
			if peek().Source == '[' then
				-- Index
				local obrac = get()
				local index = expr()
				local cbrac = expect('Symbol', ']')
				local eq = expect('Symbol', '=')
				local value = expr()
				table.insert(entries, {
					EntryType = 'Index';
					Index = index;
					Value = value;
					Token_OpenBracket = obrac;
					Token_CloseBracket = cbrac;
					Token_Equals = eq;
				})
			elseif peek().Type == 'Ident' and peek(1).Source == '=' then
				-- Field
				local field = get()
				local eq = get()
				local value = expr()
				table.insert(entries, {
					EntryType = 'Field';
					Field = field;
					Value = value;
					Token_Equals = eq;
				})
			else
				-- Value
				local value = expr()
				table.insert(entries, {
					EntryType = 'Value';
					Value = value;
				})
			end

			-- Comma or Semicolon separator
			if peek().Source == ',' or peek().Source == ';' then
				table.insert(separators, get())
			else
				break
			end
		end
		local cbrace = expect('Symbol', '}')
		return MkNode{
			Type = 'TableLiteral';
			EntryList = entries;
			Token_SeparatorList = separators;
			Token_OpenBrace = obrace;
			Token_CloseBrace = cbrace;
			GetFirstToken = function(self)
				return self.Token_OpenBrace
			end;
			GetLastToken = function(self)
				return self.Token_CloseBrace
			end;
		}
	end

	local function typeExprBasePart()
		if peek().Source == 'typeof' then
			local typeofTk = get()
			local openParen = expect('Symbol', '(')
			local expression = expr()
			local closeParen = expect('Symbol', ')')
			return MkNode{
				Type = 'TypeofType';
				Expression = expression;
				--
				Token_Typeof = typeofTk;
				Token_OpenParen = openParen;
				Token_CloseParen = closeParen;
				GetFirstToken = function(self)
					return self.Token_Typeof
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif peek().Source == '(' then
			-- Tuple type
			local tkOparen = get()
			local types = {}
			local commas = {}
			if peek().Source ~= ')' then
				while true do
					table.insert(types, typeexpr())
					if peek().Source == ',' then
						table.insert(commas, get())
					else
						break
					end
				end
			end
			local tkCparen = expect('Symbol', ')')
			return MkNode{
				Type = 'TupleType';
				TypeList = types;
				--
				Token_OpenParen = tkOparen;
				Token_CommaList = commas;
				Token_CloseParen = tkCparen;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif peek().Source == '{' then
			-- Table type
			local openBrace = get()
			local records: {} = {}
			local commas = {}
			if peek().Source == '[' or peek().Type == 'Ident' then
				while true do
					if peek().Source == '[' then
						-- Field type record
						local openBracket = get()
						local fieldType = typeexpr()
						local closeBracket = expect('Symbol', ']')
						local colon = expect('Symbol', ':')
						local valueType = typeexpr()
						table.insert(records, {
							Type = 'Type';
							KeyType = fieldType;
							ValueType = valueType;
							--
							Token_OpenBracket = openBracket;
							Token_CloseBracket = closeBracket;
							Token_Colon = colon;
						})
					elseif peek().Type == 'Ident' then
						-- Field name record
						local ident = get()
						local colon = expect('Symbol', ':')
						local valueType = typeexpr()
						table.insert(records, {
							Type = 'Name';
							Ident = ident;
							ValueType = valueType;
							--
							Token_Colon = colon;
						})
					else
						error(getTokenStartPosition(peek())..": Type expected, got `"..peek().Source.."`")
					end
					if peek().Source == ',' then
						table.insert(commas, get())
					else
						break
					end
				end
			end
			local closeBrace = expect('Symbol', '}')
			return MkNode{
				Type = 'TableType';
				RecordList = records;
				--
				Token_OpenBrace = openBrace;
				Token_CloseBrace = closeBrace;
				Token_CommaList = commas;
				GetFirstToken = function(self)
					return self.Token_OpenBrace
				end;
				GetLastToken = function(self)
					return self.Token_CloseBrace
				end;
			}
		elseif peek().Source == 'nil' then
			-- nil type
			local nilKw = get()
			return MkNode{
				Type = 'NilType';
				--
				Token_Nil = nilKw;
				GetFirstToken = function(self)
					return self.Token_Nil
				end;
				GetLastToken = function(self)
					return self.Token_Nil
				end;
			}
		elseif peek().Type == 'Ident' then
			-- Basic type
			local identList = {get()}
			local identDotList = {}
			while peek().Source == '.' do
				table.insert(identDotList, get())
				table.insert(identList, expect('Ident'))
			end
			local tkOpenAngle, tkCloseAngle
			local genericArgumentList = {}
			local genericArgumentCommaList = {}
			if peek().Source == '<' then
				tkOpenAngle = get()
				-- Parameterized generic type
				while true do
					table.insert(genericArgumentList, typeexpr())
					if peek().Source == ',' then
						table.insert(genericArgumentCommaList, get())
					else
						break
					end
				end
				if peek().Source == '>=' then
					-- Special handling for `>=` case
					tkCloseAngle = {
						Type = 'Symbol';
						LeadingWhite = peek().LeadingWhite;
						Source = '>';
					}
					peek().Source = '='
					peek().LeadingWhite = ""
				else
					tkCloseAngle = expect('Symbol', '>')
				end
			end
			return MkNode{
				Type = 'BasicType';
				IdentList = identList;
				GenericArgumentList = genericArgumentList;
				--
				Token_IdentDotList = identDotList;
				Token_OpenAngle = tkOpenAngle;
				Token_CloseAngle = tkCloseAngle;
				Token_GenericArgumentCommaList = genericArgumentCommaList;
				GetFirstToken = function(self)
					return self.IdentList[1]
				end;
				GetLastToken = function(self)
					if self.Token_CloseAngle then
						return self.Token_CloseAngle
					else
						return self.IdentList[#self.IdentList]
					end
				end;
			}
		else
			error(getTokenStartPosition(peek())..": Type expected, got `"..peek().Source.."`")
		end
	end

	local function typeExprPart()
		local baseType = typeExprBasePart()
		if peek().Source == '->' then
			-- Is actually a function type
			local tkArrow = get()
			local returnType = typeexpr()
			return MkNode{
				Type = 'FunctionType';
				ArgType = baseType;
				ReturnType = returnType;
				--
				Token_Arrow = tkArrow;
				GetFirstToken = function(self)
					return self.ArgType:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.ReturnType:GetLastToken()
				end;
			}
		elseif peek().Source == '?' then
			return MkNode{
				Type = 'OptionalType';
				BaseType = baseType;
				--
				Token_QuestionMark = get();
				GetFirstToken = function(self)
					return self.BaseType:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Token_QuestionMark
				end;
			}
		else
			return baseType
		end
	end

	function typeexpr()
		local parts = {typeExprPart()}
		local combiners = {}
		local combinersPresent = {}
		while peek().Source == '&' or peek().Source == '|' do
			local combiner = get()
			combinersPresent[combiner.Source] = true
			table.insert(parts, typeExprPart())
			table.insert(combiners, combiner)
		end
		if combinersPresent['&'] and combinersPresent['|'] then
			error(getTokenStartPosition(peek())..": Mixed union and intersection not allowed, must parenthesize")
		end
		if #parts > 1 then
			return MkNode{
				Type = combinersPresent['&'] and 'IntersectionType' or 'UnionType';
				TypeList = parts;
				--
				Token_CombinerList = combiners;
				GetFirstToken = function(self)
					return self.TypeList[1]:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.TypeList[#self.TypeList]:GetLastToken()
				end;
			}
		else
			return parts[1]
		end
	end

	-- List of identifiers
	local function varlist(acceptVarg)
		local varList = {}
		local colonList = {}
		local typeList = {}
		local commaList = {}
		if peek().Type == 'Ident' then
			varList[1] = get()
			if peek().Source == ':' then
				colonList[1] = get()
				typeList[1] = typeexpr()
			end
		elseif peek().Source == '...' and acceptVarg then
			return varList, colonList, typeList, commaList, get()
		end
		while peek().Source == ',' do
			table.insert(commaList, get())
			if peek().Source == '...' and acceptVarg then
				return varList, colonList, typeList, commaList, get()
			else
				local id = expect('Ident')
				table.insert(varList, id)
				if peek().Source == ':' then
					colonList[#varList] = get()
					typeList[#varList] = typeexpr()
				end
			end
		end
		return varList, colonList, typeList, commaList
	end

	-- Body
	local function blockbody(terminator)
		local body = block()
		local after = peek()
		if after.Type == 'Keyword' and after.Source == terminator then
			get()
			return body, after
		else
			print(after.Type, after.Source)
			error(getTokenStartPosition(after)..": "..terminator.." expected.")
		end
	end

	-- Function declaration
	local function funcdecl(isAnonymous)
		local functionKw = get()
		--
		local nameChain;
		local nameChainSeparator;
		--
		if not isAnonymous then
			nameChain = {}
			nameChainSeparator = {}
			--
			table.insert(nameChain, expect('Ident'))
			--
			while peek().Source == '.' do
				table.insert(nameChainSeparator, get())
				table.insert(nameChain, expect('Ident'))
			end
			if peek().Source == ':' then
				table.insert(nameChainSeparator, get())
				table.insert(nameChain, expect('Ident'))
			end
		end
		--
		local oparenTk = expect('Symbol', '(')
		local argList, argColonList, argTypeList, argCommaList, vargToken = varlist(true) --true -> allow varg symbol at end of var list
		local cparenTk = expect('Symbol', ')')
		local colonTk;
		local returnType;
		if peek().Source == ':' then
			colonTk = get()
			returnType = typeexpr()
		end
		--
		local fbody, enTk = blockbody('end')
		--
		return MkNode{
			Type = (isAnonymous and 'FunctionLiteral' or 'FunctionStat');
			NameChain = nameChain;
			ArgList = argList;
			ArgTypeList = argTypeList;
			ReturnType = returnType;
			Body = fbody;
			--
			Token_Function = functionKw;
			Token_NameChainSeparator = nameChainSeparator;
			Token_OpenParen = oparenTk;
			Token_Varg = vargToken;
			Token_ArgColonList = argColonList,
			Token_ArgCommaList = argCommaList;
			Token_CloseParen = cparenTk;
			Token_Colon = colonTk;
			Token_End = enTk;
			GetFirstToken = function(self)
				return self.Token_Function
			end;
			GetLastToken = function(self)
				return self.Token_End;
			end;
		}
	end

	-- Argument list passed to a funciton
	local function functionargs()
		local tk = peek()
		if tk.Source == '(' then
			local oparenTk = get()
			local argList = {}
			local argCommaList = {}
			while peek().Source ~= ')' do
				table.insert(argList, expr())
				if peek().Source == ',' then
					table.insert(argCommaList, get())
				else
					break
				end
			end
			local cparenTk = expect('Symbol', ')')
			return MkNode{
				CallType = 'ArgCall';
				ArgList = argList;
				--
				Token_CommaList = argCommaList;
				Token_OpenParen = oparenTk;
				Token_CloseParen = cparenTk;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif tk.Source == '{' then
			return MkNode{
				CallType = 'TableCall';
				TableExpr = expr();
				GetFirstToken = function(self)
					return self.TableExpr:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.TableExpr:GetLastToken()
				end;
			}
		elseif tk.Type == 'String' then
			return MkNode{
				CallType = 'StringCall';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		else
			error("Function arguments expected.")
		end
	end

	local function primaryexpr()
		local base = prefixexpr()
		assert(base, "nil prefixexpr")
		while true do
			local tk = peek()
			if tk.Source == '.' then
				local dotTk = get()
				local fieldName = expect('Ident')
				base = MkNode{
					Type = 'FieldExpr';
					Base = base;
					Field = fieldName;
					Token_Dot = dotTk;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.Field
					end;
				}
			elseif tk.Source == ':' then
				local colonTk = get()
				local methodName = expect('Ident')
				local fargs = functionargs()
				base = MkNode{
					Type = 'MethodExpr';
					Base = base;
					Method = methodName;
					FunctionArguments = fargs;
					Token_Colon = colonTk;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.FunctionArguments:GetLastToken()
					end;
				}
			elseif tk.Source == '[' then
				local obrac = get()
				local index = expr()
				local cbrac = expect('Symbol', ']')
				base = MkNode{
					Type = 'IndexExpr';
					Base = base;
					Index = index;
					Token_OpenBracket = obrac;
					Token_CloseBracket = cbrac;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.Token_CloseBracket
					end;
				}
			elseif tk.Source == '{' or tk.Source == '(' or tk.Type == 'String' then
				base = MkNode{
					Type = 'CallExpr';
					Base = base;
					FunctionArguments = functionargs();
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.FunctionArguments:GetLastToken()
					end;
				}
			else
				return base
			end
		end
	end

	local function simpleexpr()
		local tk = peek()
		if tk.Type == 'Number' then
			return MkNode{
				Type = 'NumberLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Type == 'String' then
			return MkNode{
				Type = 'StringLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == 'nil' then
			return MkNode{
				Type = 'NilLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == 'true' or tk.Source == 'false' then
			return MkNode{
				Type = 'BooleanLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == '...' then
			return MkNode{
				Type = 'VargLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == '{' then
			return tableexpr()
		elseif tk.Source == 'function' then
			return funcdecl(true)
		else
			return primaryexpr()
		end
	end

	local function subexpr(limit)
		local curNode;

		-- Initial Base Expression
		if isUnop() then
			local opTk = get()
			local ex = subexpr(UnaryPriority)
			curNode = MkNode{
				Type = 'UnopExpr';
				Token_Op = opTk;
				Rhs = ex;
				GetFirstToken = function(self)
					return self.Token_Op
				end;
				GetLastToken = function(self)
					return self.Rhs:GetLastToken()
				end;
			}
		else 
			curNode = simpleexpr()
			assert(curNode, "nil simpleexpr")
		end

		-- Apply Precedence Recursion Chain
		while isBinop() and BinaryPriority[peek().Source][1] > limit do
			local opTk = get()
			local rhs = subexpr(BinaryPriority[opTk.Source][2])
			assert(rhs, "RhsNeeded")
			curNode = MkNode{
				Type = 'BinopExpr';
				Lhs = curNode;
				Rhs = rhs;
				Token_Op = opTk;
				GetFirstToken = function(self)
					return self.Lhs:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Rhs:GetLastToken()
				end;
			}
		end

		-- Return result
		return curNode
	end

	-- Expression
	expr = function()
		return subexpr(0)
	end

	-- Expression statement
	local function exprstat()
		local ex = primaryexpr()
		if ex.Type == 'MethodExpr' or ex.Type == 'CallExpr' then
			-- all good, calls can be statements
			return MkNode{
				Type = 'CallExprStat';
				Expression = ex;
				GetFirstToken = function(self)
					return self.Expression:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Expression:GetLastToken()
				end;
			}
		else
			-- Assignment expr
			local lhs = {ex}
			local lhsSeparator = {}
			while peek().Source == ',' do
				table.insert(lhsSeparator, get())
				local lhsPart = primaryexpr()
				if lhsPart.Type == 'MethodExpr' or lhsPart.Type == 'CallExpr' then
					error("Bad left hand side of assignment")
				end
				table.insert(lhs, lhsPart)
			end
			local eq = get()
			if not AssignmentOperators[eq.Source] then
				error(getTokenStartPosition(eq)..": `=` or compound assigment expected")
			end
			local rhs = {expr()}
			local rhsSeparator = {}
			while peek().Source == ',' do
				table.insert(rhsSeparator, get())
				table.insert(rhs, expr())
			end
			if eq.Source ~= '=' and (#rhs > 1 or #lhs > 1) then
				error(getTokenStartPosition(ex:GetFirstToken())..": Compound assignment statements must operate on single values")
			end
			return MkNode{
				Type = 'AssignmentStat';
				Rhs = rhs;
				Lhs = lhs;
				Token_Equals = eq;
				Token_LhsSeparatorList = lhsSeparator;
				Token_RhsSeparatorList = rhsSeparator;
				GetFirstToken = function(self)
					return self.Lhs[1]:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Rhs[#self.Rhs]:GetLastToken()
				end;
			}
		end
	end

	-- If statement
	local function ifstat()
		local ifKw = get()
		local condition = expr()
		local thenKw = expect('Keyword', 'then')
		local ifBody = block()
		local elseClauses = {}
		while peek().Source == 'elseif' or peek().Source == 'else' do
			local elseifKw = get()
			local elseifCondition, elseifThenKw;
			if elseifKw.Source == 'elseif' then
				elseifCondition = expr()
				elseifThenKw = expect('Keyword', 'then')
			end
			local elseifBody = block()
			table.insert(elseClauses, {
				Condition = elseifCondition;
				Body = elseifBody;
				--
				ClauseType = elseifKw.Source;
				Token = elseifKw;
				Token_Then = elseifThenKw;
			})
			if elseifKw.Source == 'else' then
				break
			end
		end
		local enKw = expect('Keyword', 'end')
		return MkNode{
			Type = 'IfStat';
			Condition = condition;
			Body = ifBody;
			ElseClauseList = elseClauses;
			--
			Token_If = ifKw;
			Token_Then = thenKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_If
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- Do statement
	local function dostat()
		local doKw = get()
		local body, enKw = blockbody('end')
		--
		return MkNode{
			Type = 'DoStat';
			Body = body;
			--
			Token_Do = doKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_Do
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- While statement
	local function whilestat()
		local whileKw = get()
		local condition = expr()
		local doKw = expect('Keyword', 'do')
		local body, enKw = blockbody('end')
		--
		return MkNode{
			Type = 'WhileStat';
			Condition = condition;
			Body = body;
			--
			Token_While = whileKw;
			Token_Do = doKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_While
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- For statement
	local function forstat()
		local forKw = get()
		local loopVars, loopVarColons, loopVarTypes, loopVarCommas = varlist()
		local node = {}
		if peek().Source == '=' then
			local eqTk = get()
			local exprList, exprCommaList = exprlist()
			if #exprList < 2 or #exprList > 3 then
				error("expected 2 or 3 values for range bounds")
			end
			local doTk = expect('Keyword', 'do')
			local body, enTk = blockbody('end')
			return MkNode{
				Type = 'NumericForStat';
				VarList = loopVars;
				VarTypeList = loopVarTypes;
				RangeList = exprList;
				Body = body;
				--
				Token_For = forKw;
				Token_VarCommaList = loopVarCommas;
				Token_VarColonList = loopVarColons;
				Token_Equals = eqTk;
				Token_RangeCommaList = exprCommaList;
				Token_Do = doTk;
				Token_End = enTk;
				GetFirstToken = function(self)
					return self.Token_For
				end;
				GetLastToken = function(self)
					return self.Token_End
				end;
			}
		elseif peek().Source == 'in' then
			local inTk = get()
			local exprList, exprCommaList = exprlist()
			local doTk = expect('Keyword', 'do')
			local body, enTk = blockbody('end')
			return MkNode{
				Type = 'GenericForStat';
				VarList = loopVars;
				VarTypeList = loopVarTypes;
				GeneratorList = exprList;
				Body = body;
				--
				Token_For = forKw;
				Token_VarCommaList = loopVarCommas;
				Token_VarColonList = loopVarColons;
				Token_In = inTk;
				Token_GeneratorCommaList = exprCommaList;
				Token_Do = doTk;
				Token_End = enTk;
				GetFirstToken = function(self)
					return self.Token_For
				end;
				GetLastToken = function(self)
					return self.Token_End
				end;
			}
		else
			error("`=` or in expected")
		end
	end

	-- Repeat statement
	local function repeatstat()
		local repeatKw = get()
		local body, untilTk = blockbody('until')
		local condition = expr()
		return MkNode{
			Type = 'RepeatStat';
			Body = body;
			Condition = condition;
			--
			Token_Repeat = repeatKw;
			Token_Until = untilTk;
			GetFirstToken = function(self)
				return self.Token_Repeat
			end;
			GetLastToken = function(self)
				return self.Condition:GetLastToken()
			end;
		}
	end

	-- Local var declaration
	local function localdecl()
		local localKw = get()
		if peek().Source == 'function' then
			-- Local function def
			local funcStat = funcdecl(false)
			if #funcStat.NameChain > 1 then
				error(getTokenStartPosition(funcStat.Token_NameChainSeparator[1])..": `(` expected.")
			end
			return MkNode{
				Type = 'LocalFunctionStat';
				FunctionStat = funcStat;
				Token_Local = localKw;
				GetFirstToken = function(self)
					return self.Token_Local
				end;
				GetLastToken = function(self)
					return self.FunctionStat:GetLastToken()
				end;
			}
		elseif peek().Type == 'Ident' then
			-- Local variable declaration
			local varList, varColonList, varTypeList, varCommaList = varlist()
			local exprList, exprCommaList = {}, {}
			local eqToken;
			if peek().Source == '=' then
				eqToken = get()
				exprList, exprCommaList = exprlist()
			end
			return MkNode{
				Type = 'LocalVarStat';
				VarList = varList;
				TypeList = varTypeList;
				ExprList = exprList;
				Token_Local = localKw;
				Token_Equals = eqToken;
				Token_VarCommaList = varCommaList;
				Token_VarColonList = varColonList;
				Token_ExprCommaList = exprCommaList;	
				GetFirstToken = function(self)
					return self.Token_Local
				end;
				GetLastToken = function(self)
					if #self.ExprList > 0 then
						return self.ExprList[#self.ExprList]:GetLastToken()
					else
						return self.VarList[#self.VarList]
					end
				end;
			}
		else
			error("`function` or ident expected")
		end
	end

	-- Return statement
	local function retstat()
		local returnKw = get()
		local exprList;
		local commaList;
		if isBlockFollow() or peek().Source == ';' then
			exprList = {}
			commaList = {}
		else
			exprList, commaList = exprlist()
		end
		return {
			Type = 'ReturnStat';
			ExprList = exprList;
			Token_Return = returnKw;
			Token_CommaList = commaList;
			GetFirstToken = function(self)
				return self.Token_Return
			end;
			GetLastToken = function(self)
				if #self.ExprList > 0 then
					return self.ExprList[#self.ExprList]:GetLastToken()
				else
					return self.Token_Return
				end
			end;
		}
	end

	-- Break statement
	local function breakstat()
		local breakKw = get()
		return {
			Type = 'BreakStat';
			Token_Break = breakKw;
			GetFirstToken = function(self)
				return self.Token_Break
			end;
			GetLastToken = function(self)
				return self.Token_Break
			end;
		}
	end
	
	-- Continue statement
	local function continuestat()
		local continueKw = get()
		return {
			Type = 'ContinueStat';
			Token_Continue = continueKw;
			GetFirstToken = function(self)
				return self.Token_Continue
			end;
			GetLastToken = function(self)
				return self.Token_Continue
			end;
		}
	end
	
	-- Type statement
	local function typestat()
		local exportKw
		if peek().Source == 'export' then
			exportKw = get()
		end
		local typeKw = expect('Ident', 'type')
		local typeName = expect('Ident')
		local genericTypeList = {}
		local genericTypeCommas = {}
		local openAngle, closeAngle
		local addSyntheticEquals = false
		if peek().Source == '<' then
			openAngle = get()
			while true do
				table.insert(genericTypeList, expect('Ident'))
				if peek().Source == ',' then
					table.insert(genericTypeCommas, get())
				else
					break
				end
			end
			-- Special case handling for the `>=` token. In this context treat it
			-- as separate `>` and `=` tokens instead.
			if peek().Source == '>=' then
				closeAngle = get()
				closeAngle.Source = '>'
				addSyntheticEquals = true
			else
				closeAngle = expect('Symbol', '>')
			end
		end
		local equals
		if addSyntheticEquals then
			equals = {
				Type = 'Symbol';
				Source = '=';
				LeadingWhite = "";
			}
		else
			equals = expect('Symbol', '=')
		end
		local mainType = typeexpr()
		return MkNode{
			Type = 'TypeStat';
			Ident = typeName;
			GenericTypeList = genericTypeList;
			AliasedType = mainType;
			--
			Token_Export = exportKw;
			Token_Type = typeKw;
			Token_OpenAngle = openAngle;
			Token_CloseAngle = closeAngle;
			Token_GenericTypeCommaList = genericTypeCommas;
			Token_Equals = equals;
			GetFirstToken = function(self)
				if self.Token_Export then
					return self.Token_Export
				else
					return self.Token_Type
				end
			end;
			GetLastToken = function(self)
				return self.AliasedType:GetLastToken()
			end;
		}
	end

	-- Expression
	local function statement()
		local tok = peek()
		if tok.Source == 'if' then
			return false, ifstat()
		elseif tok.Source == 'while' then
			return false, whilestat()
		elseif tok.Source == 'do' then
			return false, dostat()
		elseif tok.Source == 'for' then
			return false, forstat()
		elseif tok.Source == 'repeat' then
			return false, repeatstat()
		elseif tok.Source == 'function' then
			return false, funcdecl(false)
		elseif tok.Source == 'local' then
			return false, localdecl()
		elseif tok.Source == 'return' then
			return true, retstat()
		elseif tok.Source == 'break' then
			return true, breakstat()
		elseif tok.Source == 'type' or tok.Source == 'export' then
			return false, typestat()
		elseif tok.Source == 'continue' then
			if peek(1).Source == 'end' or peek(1).Source == ';' then
				return true, continuestat()
			else
				return false, exprstat()
			end
		else
			return false, exprstat()
		end
	end

	-- Chunk
	block = function()
		local statements = {}
		local semicolons = {}
		local isLast = false
		while not isLast and not isBlockFollow() do
			-- Parse statement
			local stat;
			isLast, stat = statement()
			table.insert(statements, stat)
			local next = peek()
			if next.Type == 'Symbol' and next.Source == ';' then
				local semiList = {}
				while next.Type == 'Symbol' and next.Source == ';' do
					table.insert(semiList, get())
					next = peek()
				end
				semicolons[#statements] = semiList
			end
		end
		return {
			Type = 'StatList';
			StatementList = statements;
			SemicolonList = semicolons;
			GetFirstToken = function(self)
				if #self.StatementList == 0 then
					return nil
				else
					return self.StatementList[1]:GetFirstToken()
				end
			end;
			GetLastToken = function(self)
				if #self.StatementList == 0 then
					return nil
				elseif self.SemicolonList[#self.StatementList] then
					-- Last token may be one of the semicolon separators
					local semis = self.SemicolonList[#self.StatementList]
					if semis then
						return semis[#semis]
					end
				else
					return self.StatementList[#self.StatementList]:GetLastToken()
				end
			end;
		}
	end

	return block()
end

return parse]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bcb</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX45D785DEDEC14E8196504A153C8C0071">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">visitAst</string>
						<string name="ScriptGuid">{EDCEC994-0B27-450A-99E9-14CB5127B866}</string>
						<ProtectedString name="Source"><![CDATA[

local formatTable = require(script.Parent.formatTable)
local lookupify = require(script.Parent.lookupify)

function visitAst(ast, visitors)
	local ExprType = lookupify{
		'BinopExpr'; 'UnopExpr'; 
		'NumberLiteral'; 'StringLiteral'; 'NilLiteral'; 'BooleanLiteral'; 'VargLiteral';
		'FieldExpr'; 'IndexExpr';
		'MethodExpr'; 'CallExpr';
		'FunctionLiteral';
		'VariableExpr';
		'ParenExpr';
		'TableLiteral';
	}

	local StatType = lookupify{
		'StatList';
		'BreakStat';
		'ReturnStat';
		'LocalVarStat';
		'LocalFunctionStat';
		'FunctionStat';
		'RepeatStat';
		'GenericForStat';
		'NumericForStat';
		'WhileStat';
		'DoStat';
		'IfStat';
		'CallExprStat';
		'AssignmentStat';
	}

	-- Check for typos in visitor construction
	for visitorSubject, visitor in pairs(visitors) do
		if not StatType[visitorSubject] and not ExprType[visitorSubject] then
			error("Invalid visitor target: `"..visitorSubject.."`")
		end
	end

	-- Helpers to call visitors on a node
	local function preVisit(exprOrStat)
		local visitor = visitors[exprOrStat.Type]
		if type(visitor) == 'function' then
			return visitor(exprOrStat)
		elseif visitor and visitor.Pre then
			return visitor.Pre(exprOrStat)
		end
	end
	local function postVisit(exprOrStat)
		local visitor = visitors[exprOrStat.Type]
		if visitor and type(visitor) == 'table' and visitor.Post then
			return visitor.Post(exprOrStat)
		end
	end

	local visitExpr, visitStat, visitType;

	visitExpr = function(expr)
		if preVisit(expr) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if expr.Type == 'BinopExpr' then
			visitExpr(expr.Lhs)
			visitExpr(expr.Rhs)
		elseif expr.Type == 'UnopExpr' then
			visitExpr(expr.Rhs)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- No children to visit, single token literals
		elseif expr.Type == 'FieldExpr' then
			visitExpr(expr.Base)
		elseif expr.Type == 'IndexExpr' then
			visitExpr(expr.Base)
			visitExpr(expr.Index)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			visitExpr(expr.Base)
			if expr.FunctionArguments.CallType == 'ArgCall' then
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					visitExpr(argExpr)
				end
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				visitExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			visitStat(expr.Body)
		elseif expr.Type == 'VariableExpr' then
			-- No children to visit
		elseif expr.Type == 'ParenExpr' then
			visitExpr(expr.Expression)
		elseif expr.Type == 'TableLiteral' then
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					visitExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					visitExpr(entry.Index)
					visitExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					visitExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
			end
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
		postVisit(expr)
	end
	
	visitType = function(typeExpr)
		if preVisit(typeExpr) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if typeExpr.Type == 'BasicType' then
			if typeExpr.Token_OpenAngle then
				for _, typeArg in pairs(typeExpr.GenericArgumentList) do
					visitType(typeArg)
				end
			end
		elseif typeExpr.Type == 'TypeofType' then
			visitExpr(typeExpr.Expression)
		elseif typeExpr.Type == 'FunctionType' then
			visitType(typeExpr.ArgType)
			visitType(typeExpr.ReturnType)
		elseif typeExpr.Type == 'TupleType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				visitType(subTypeExpr)
			end
		elseif typeExpr.Type == 'TableType' then
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					visitType(record.KeyType)
					visitType(record.ValueType)
				elseif record.Type == 'Name' then
					visitType(record.ValueType)
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
			end
		elseif typeExpr.Type == 'OptionalType' then
			visitType(typeExpr.BaseType)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				visitType(subTypeExpr)
			end
		else
			error("Bad typeExpr type in: "..formatTable(typeExpr))
		end
	end

	visitStat = function(stat)
		if preVisit(stat) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if stat.Type == 'StatList' then
			for index, ch in pairs(stat.StatementList) do
				visitStat(ch)
			end
		elseif stat.Type == 'BreakStat' then
			-- No children to visit
		elseif stat.Type == 'ContinueStat' then
			-- No children to visit
		elseif stat.Type == 'ReturnStat' then
			for index, expr in pairs(stat.ExprList) do
				visitExpr(expr)
			end
		elseif stat.Type == 'LocalVarStat' then
			for _, typeExpr in pairs(stat.TypeList) do
				visitType(typeExpr)
			end
			if stat.Token_Equals then
				for index, expr in pairs(stat.ExprList) do
					visitExpr(expr)
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			for _, typeExpr in pairs(stat.FunctionStat.ArgTypeList) do
				visitType(typeExpr)
			end
			if stat.FunctionStat.ReturnType then
				visitType(stat.FunctionStat.ReturnType)
			end
			visitStat(stat.FunctionStat.Body)
		elseif stat.Type == 'FunctionStat' then
			for _, typeExpr in pairs(stat.ArgTypeList) do
				visitType(typeExpr)
			end
			if stat.ReturnType then
				visitType(stat.ReturnType)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'RepeatStat' then
			visitStat(stat.Body)
			visitExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			for _, typeExpr in pairs(stat.VarTypeList) do
				visitType(typeExpr)
			end
			for index, expr in pairs(stat.GeneratorList) do
				visitExpr(expr)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'NumericForStat' then
			for _, typeExpr in pairs(stat.VarTypeList) do
				visitType(typeExpr)
			end
			for index, expr in pairs(stat.RangeList) do
				visitExpr(expr)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'WhileStat' then
			visitExpr(stat.Condition)
			visitStat(stat.Body)
		elseif stat.Type == 'DoStat' then
			visitStat(stat.Body)
		elseif stat.Type == 'IfStat' then
			visitExpr(stat.Condition)
			visitStat(stat.Body)
			for _, clause in pairs(stat.ElseClauseList) do
				if clause.Condition then
					visitExpr(clause.Condition)
				end
				visitStat(clause.Body)
			end
		elseif stat.Type == 'CallExprStat' then
			visitExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				visitExpr(ex)
			end
			for index, ex in pairs(stat.Rhs) do
				visitExpr(ex)
			end
		elseif stat.Type == 'TypeStat' then
			visitType(stat.AliasedType)
		else
			assert(false, "unreachable, "..tostring(stat.Type))
		end	
		postVisit(stat)
	end

	if StatType[ast.Type] then
		visitStat(ast)
	else
		visitExpr(ast)
	end
end

return visitAst]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bcc</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX895814A789BA43E68889CE1E8330F0B8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">addVariableInfo</string>
						<string name="ScriptGuid">{A84C5995-53B6-43F6-B95A-F032C786629C}</string>
						<ProtectedString name="Source"><![CDATA[
local visitAst = require(script.Parent.visitAst)

function addVariableInfo(ast)
	local globalVars = {}
	local currentScope = nil

	-- Numbering generator for variable lifetimes
	local locationGenerator = 0
	local function markLocation()
		locationGenerator = locationGenerator + 1
		return locationGenerator
	end

	-- Scope management
	local function pushScope()
		currentScope = {
			ParentScope = currentScope;
			ChildScopeList = {};
			VariableList = {};
			BeginLocation = markLocation();
		}
		if currentScope.ParentScope then
			currentScope.Depth = currentScope.ParentScope.Depth + 1
			table.insert(currentScope.ParentScope.ChildScopeList, currentScope)
		else
			currentScope.Depth = 1
		end
		function currentScope:GetVar(varName)
			for _, var in pairs(self.VariableList) do
				if var.Name == varName then
					return var
				end
			end
			if self.ParentScope then
				return self.ParentScope:GetVar(varName)
			else
				for _, var in pairs(globalVars) do
					if var.Name == varName then
						return var
					end
				end
			end
		end
	end
	local function popScope()
		local scope = currentScope

		-- Mark where this scope ends
		scope.EndLocation = markLocation()

		-- Mark all of the variables in the scope as ending there
		for _, var in pairs(scope.VariableList) do
			var.ScopeEndLocation = scope.EndLocation
		end

		-- Move to the parent scope
		currentScope = scope.ParentScope

		return scope
	end
	pushScope() -- push initial scope

	-- Add / reference variables
	local function addLocalVar(name, setNameFunc, localInfo)
		assert(localInfo, "Misisng localInfo")
		assert(name, "Missing local var name")
		local var = {
			Type = 'Local';
			Name = name;
			RenameList = {setNameFunc};
			AssignedTo = false;
			Info = localInfo;
			UseCount = 0;
			Scope = currentScope;
			BeginLocation = markLocation();
			EndLocation = markLocation();
			ReferenceLocationList = {markLocation()};
		}
		function var:Rename(newName)
			self.Name = newName
			for _, renameFunc in pairs(self.RenameList) do
				renameFunc(newName)
			end
		end
		function var:Reference()
			self.UseCount = self.UseCount + 1
		end
		table.insert(currentScope.VariableList, var)
		return var
	end
	local function getGlobalVar(name)
		for _, var in pairs(globalVars) do
			if var.Name == name then
				return var
			end
		end
		local var = {
			Type = 'Global';
			Name = name;
			RenameList = {};
			AssignedTo = false;
			UseCount = 0;
			Scope = nil; -- Globals have no scope
			BeginLocation = markLocation();
			EndLocation = markLocation();
			ReferenceLocationList = {};
		}
		function var:Rename(newName)
			self.Name = newName
			for _, renameFunc in pairs(self.RenameList) do
				renameFunc(newName)
			end
		end
		function var:Reference()
			self.UseCount = self.UseCount + 1
		end
		table.insert(globalVars, var)
		return var
	end
	local function addGlobalReference(name, setNameFunc)
		assert(name, "Missing var name")
		local var = getGlobalVar(name)
		table.insert(var.RenameList, setNameFunc)
		return var
	end
	local function getLocalVar(scope, name)
		-- First search this scope
		-- Note: Reverse iterate here because Lua does allow shadowing a local
		--       within the same scope, and the later defined variable should
		--       be the one referenced.
		for i = #scope.VariableList, 1, -1 do
			if scope.VariableList[i].Name == name then
				return scope.VariableList[i]
			end
		end

		-- Then search parent scope
		if scope.ParentScope then
			local var = getLocalVar(scope.ParentScope, name)
			if var then
				return var
			end
		end

		-- Then 
		return nil
	end
	local function referenceVariable(name, setNameFunc)
		assert(name, "Missing var name")
		local var = getLocalVar(currentScope, name)
		if var then
			table.insert(var.RenameList, setNameFunc)
		else
			var = addGlobalReference(name, setNameFunc)
		end
		-- Update the end location of where this variable is used, and
		-- add this location to the list of references to this variable.
		local curLocation = markLocation()
		var.EndLocation = curLocation
		table.insert(var.ReferenceLocationList, var.EndLocation)
		return var
	end

	local visitor = {}
	visitor.FunctionLiteral = {
		-- Function literal adds a new scope and adds the function literal arguments
		-- as local variables in the scope.
		Pre = function(expr)
			pushScope()
			for index, ident in pairs(expr.ArgList) do
				local var = addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function(expr)
			popScope()
		end;
	}
	visitor.VariableExpr = function(expr)
		-- Variable expression references from existing local varibales
		-- in the current scope, annotating the variable usage with variable
		-- information.
		expr.Variable = referenceVariable(expr.Token.Source, function(newName)
			expr.Token.Source = newName
		end)
	end
	visitor.StatList = {
		-- StatList adds a new scope
		Pre = function(stat)
			pushScope()
		end;
		Post = function(stat)
			-- Ugly hack for repeat until statements. They use a statlist in their body,
			-- but we have to wait to pop that stat list until the until conditional
			-- expression has been visited rather than popping where the textual contents 
			-- of the statlist actually end. (As is the case for all the other places a 
			-- stat list can appear)
			if not stat.SkipPop then
				popScope()
			end
		end;
	}
	visitor.LocalVarStat = {
		Post = function(stat)
			-- Local var stat adds the local variables to the current scope as locals
			-- We need to visit the subexpressions first, because these new locals
			-- will not be in scope for the initialization value expressions. That is:
			--  `local bar = bar + 1`
			-- Is valid code
			for varNum, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					stat.VarList[varNum].Source = name
				end, {
					Type = 'Local';
				})
			end		
		end;
	}
	visitor.LocalFunctionStat = {
		Pre = function(stat)
			-- Local function stat adds the function itself to the current scope as
			-- a local variable, and creates a new scope with the function arguments
			-- as local variables.
			addLocalVar(stat.FunctionStat.NameChain[1].Source, function(name)
				stat.FunctionStat.NameChain[1].Source = name
			end, {
				Type = 'LocalFunction';
			})
			pushScope()
			for index, ident in pairs(stat.FunctionStat.ArgList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function()
			popScope()
		end;
	}
	visitor.FunctionStat = {
		Pre = function(stat) 			
			-- Function stat adds a new scope containing the function arguments
			-- as local variables.
			-- A function stat may also assign to a global variable if it is in
			-- the form `function foo()` with no additional dots/colons in the 
			-- name chain.
			-- **BUGFIX**: If `function foo()` is done when there is already a local
			-- variable `foo` in scope, it will assign to the local variable instead
			-- of a global one! I did not know this when writing it initially.
			local nameChain = stat.NameChain
			local var;
			if #nameChain == 1 then
				-- If there is only one item in the name chain, then the first item
				-- is a reference to a variable
				if getLocalVar(currentScope, nameChain[1].Source) then
					-- If there is a local of that name, then it's a reference to that local
					var = referenceVariable(nameChain[1].Source, function(name)
						nameChain[1].Source = name
					end)
				else
					-- Otherwise, it's a reference to a global
					var = addGlobalReference(nameChain[1].Source, function(name)
						nameChain[1].Source = name
					end)
				end
			else
				var = referenceVariable(nameChain[1].Source, function(name)
					nameChain[1].Source = name
				end)
			end
			var.AssignedTo = true
			pushScope()
			for index, ident in pairs(stat.ArgList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function()
			popScope()
		end;
	}
	visitor.GenericForStat = {
		Pre = function(stat)
			-- Generic fors need an extra scope holding the range variables
			-- Need a custom visitor so that the generator expressions can be
			-- visited before we push a scope, but the body can be visited
			-- after we push a scope.
			for _, ex in pairs(stat.GeneratorList) do
				visitAst(ex, visitor)
			end
			pushScope()
			for index, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'ForRange';
					Index = index;
				})
			end
			visitAst(stat.Body, visitor)
			popScope()
			return true -- Custom visit
		end;
	}
	visitor.NumericForStat = {
		Pre = function(stat)
			-- Numeric fors need an extra scope holding the range variables
			-- Need a custom visitor so that the generator expressions can be
			-- visited before we push a scope, but the body can be visited
			-- after we push a scope.
			for _, ex in pairs(stat.RangeList) do
				visitAst(ex, visitor)
			end
			pushScope()
			for index, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'ForRange';
					Index = index;
				})
			end
			visitAst(stat.Body, visitor)
			popScope()
			return true	-- Custom visit
		end;
	}
	visitor.RepeatStat = {
		Pre = function(stat)
			-- Extend the scope of the body statement up to the current point, that is
			-- up to the point *after* the until condition, since the body variables are
			-- still in scope through that condition.
			-- The SkipPop flag is used by visitor.StatList to accomplish this.
			stat.Body.SkipPop = true
		end;
		Post = function(stat)
			-- Now that the conditional exprssion has been visited, it's safe to pop the
			-- body scope
			popScope()
		end;
	}
	visitor.AssignmentStat = {
		Post = function(stat)
			-- For an assignment statement we need to mark the
			-- "assigned to" flag on variables.
			for _, ex in pairs(stat.Lhs) do
				if ex.Variable then
					ex.Variable.AssignedTo = true
				end
			end
		end;
	}

	visitAst(ast, visitor)

	return globalVars, popScope()
end

return addVariableInfo]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bcd</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX84D0B310D989445C8A66BB0C98B2BB22">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">printAst</string>
						<string name="ScriptGuid">{FF18B966-EDDB-4D21-8E99-0975F23EDAA7}</string>
						<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)

-- Prints out an AST to a string
local function printAst(ast)

	local printStat, printExpr, printType;

	local buffer = ''

	local function printt(tk)
		if not tk.LeadingWhite or not tk.Source then
			error("Bad token: "..formatTable(tk))
		end
		buffer = buffer..tk.LeadingWhite..tk.Source
	end

	printExpr = function(expr)
		if expr.Type == 'BinopExpr' then
			printExpr(expr.Lhs)
			printt(expr.Token_Op)
			printExpr(expr.Rhs)
		elseif expr.Type == 'UnopExpr' then
			printt(expr.Token_Op)
			printExpr(expr.Rhs)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Just print the token
			printt(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			printExpr(expr.Base)
			printt(expr.Token_Dot)
			printt(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			printExpr(expr.Base)
			printt(expr.Token_OpenBracket)
			printExpr(expr.Index)
			printt(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			printExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				printt(expr.Token_Colon)
				printt(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				printt(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				printt(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					printExpr(argExpr)
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						printt(sep)
					end
				end
				printt(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				printExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			printt(expr.Token_Function)
			printt(expr.Token_OpenParen)
			for index, arg in pairs(expr.ArgList) do
				printt(arg)
				local colon = expr.Token_ArgColonList[index]
				if colon then
					printt(colon)
					printType(expr.ArgTypeList[index])
				end
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if expr.Token_Varg then
				printt(expr.Token_Varg)
			end
			printt(expr.Token_CloseParen)
			if expr.Token_Colon then
				printt(expr.Token_Colon)
				printType(expr.ReturnType)
			end
			printStat(expr.Body)
			printt(expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			printt(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			printt(expr.Token_OpenParen)
			printExpr(expr.Expression)
			printt(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			printt(expr.Token_OpenBrace)
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					printt(entry.Field)
					printt(entry.Token_Equals)
					printExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					printt(entry.Token_OpenBracket)
					printExpr(entry.Index)
					printt(entry.Token_CloseBracket)
					printt(entry.Token_Equals)
					printExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					printExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
				local sep = expr.Token_SeparatorList[index]
				if sep then
					printt(sep)
				end
			end
			printt(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end
	
	printType = function(typeExpr)
		if typeExpr.Type == 'BasicType' then
			for i, ident in pairs(typeExpr.IdentList) do
				printt(ident)
				if typeExpr.Token_IdentDotList[i] then
					printt(typeExpr.Token_IdentDotList[i])
				end
			end
			if typeExpr.Token_OpenAngle then
				printt(typeExpr.Token_OpenAngle)
				for index, typeArg in pairs(typeExpr.GenericArgumentList) do
					printType(typeArg)
					if typeExpr.Token_GenericArgumentCommaList[index] then
						printt(typeExpr.Token_GenericArgumentCommaList[index])
					end
				end
				printt(typeExpr.Token_CloseAngle)
			end
		elseif typeExpr.Type == 'NilType' then
			printt(typeExpr.Token_Nil)
		elseif typeExpr.Type == 'TypeofType' then
			printt(typeExpr.Token_Typeof)
			printt(typeExpr.Token_OpenParen)
			printExpr(typeExpr.Expression)
			printt(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'FunctionType' then
			printType(typeExpr.ArgType)
			printt(typeExpr.Token_Arrow)
			printType(typeExpr.ReturnType)
		elseif typeExpr.Type == 'TupleType' then	
			printt(typeExpr.Token_OpenParen)
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				printType(subTypeExpr)
				if typeExpr.Token_CommaList[index] then
					printt(typeExpr.Token_CommaList[index])
				end
			end
			printt(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'TableType' then
			printt(typeExpr.Token_OpenBrace)
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					printt(record.Token_OpenBracket)
					printType(record.KeyType)
					printt(record.Token_CloseBracket)
					printt(record.Token_Colon)
					printType(record.ValueType)
				elseif record.Type == 'Name' then
					printt(record.Ident)
					printt(record.Token_Colon)
					printType(record.ValueType)
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
				if typeExpr.Token_CommaList[index] then
					printt(typeExpr.Token_CommaList[index])
				end
			end
			printt(typeExpr.Token_CloseBrace)
		elseif typeExpr.Type == 'OptionalType' then
			printType(typeExpr.BaseType)
			printt(typeExpr.Token_QuestionMark)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				printType(subTypeExpr)
				if typeExpr.Token_CombinerList[index] then
					printt(typeExpr.Token_CombinerList[index])
				end
			end
		else
			assert(false, "unreachable, type: "..typeExpr.Type..":"..formatTable(typeExpr))
		end
	end

	printStat = function(stat)
		if stat.Type == 'StatList' then
			for index, ch in pairs(stat.StatementList) do
				printStat(ch)
				local semis = stat.SemicolonList[index]
				if semis then
					for _, semi in pairs(semis) do
						printt(semi)
					end
				end
			end
		elseif stat.Type == 'BreakStat' then
			printt(stat.Token_Break)
		elseif stat.Type == 'ContinueStat' then
			printt(stat.Token_Continue)
		elseif stat.Type == 'TypeStat' then
			if stat.Token_Export then
				printt(stat.Token_Export)
			end
			printt(stat.Token_Type)
			printt(stat.Ident)
			if stat.Token_OpenAngle then
				printt(stat.Token_OpenAngle)
				for index, ident in pairs(stat.GenericTypeList) do
					printt(ident)
					if stat.Token_GenericTypeCommaList[index] then
						printt(stat.Token_GenericTypeCommaList[index])
					end
				end
				printt(stat.Token_CloseAngle)
			end
			printt(stat.Token_Equals)
			printType(stat.AliasedType)
		elseif stat.Type == 'ReturnStat' then
			printt(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				printExpr(expr)
				if stat.Token_CommaList[index] then
					printt(stat.Token_CommaList[index])
				end
			end
		elseif stat.Type == 'LocalVarStat' then
			printt(stat.Token_Local)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.TypeList[index])
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if stat.Token_Equals then
				printt(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					printExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						printt(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' or stat.Type == 'FunctionStat' then
			if stat.Type == 'LocalFunctionStat' then
				printt(stat.Token_Local)
				stat = stat.FunctionStat
				printt(stat.Token_Function)
				printt(stat.NameChain[1])
			else
				printt(stat.Token_Function)
				for index, part in pairs(stat.NameChain) do
					printt(part)
					local sep = stat.Token_NameChainSeparator[index]
					if sep then
						printt(sep)
					end
				end
			end
			printt(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				printt(arg)
				local colon = stat.Token_ArgColonList[index]
				if colon then
					printt(colon)
					printType(stat.ArgTypeList[index])
				end
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if stat.Token_Varg then
				printt(stat.Token_Varg)
			end
			printt(stat.Token_CloseParen)
			if stat.Token_Colon then
				printt(stat.Token_Colon)
				printType(stat.ReturnType)
			end
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			printt(stat.Token_Repeat)
			printStat(stat.Body)
			printt(stat.Token_Until)
			printExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			printt(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				printExpr(expr)
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			printt(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				printExpr(expr)
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'WhileStat' then
			printt(stat.Token_While)
			printExpr(stat.Condition)
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'DoStat' then
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'IfStat' then
			printt(stat.Token_If)
			printExpr(stat.Condition)
			printt(stat.Token_Then)
			printStat(stat.Body)
			for _, clause in pairs(stat.ElseClauseList) do
				printt(clause.Token)
				if clause.Condition then
					printExpr(clause.Condition)
					printt(clause.Token_Then)
				end
				printStat(clause.Body)
			end
			printt(stat.Token_End)
		elseif stat.Type == 'CallExprStat' then
			printExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				printExpr(ex)
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				printExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					printt(sep)
				end
			end
		else
			assert(false, "unreachable")
		end	
	end

	printStat(ast)
	
	return buffer
end

return printAst]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bce</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF124A211DDCE4A5EB71E301F37804595">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Keywords</string>
						<string name="ScriptGuid">{E737D36C-9194-486E-97B7-7FE0231EDA20}</string>
						<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{
    'and', 'break', 'do', 'else', 'elseif',
    'end', 'false', 'for', 'function', 'goto', 'if',
    'in', 'local', 'nil', 'not', 'or', 'repeat',
    'return', 'then', 'true', 'until', 'while',
};]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bcf</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDE09A17BE3E54CA085746A3E320ACE6B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">WhitespaceCharacters</string>
						<string name="ScriptGuid">{C3753E71-4FCD-4793-8173-1C41DEFF4776}</string>
						<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{' ', '\n', '\t', '\r'}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd0</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5C2BE6A12BB446C2AD66584EBBCB015E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AllIdentifierCharacters</string>
						<string name="ScriptGuid">{98D170F3-EFC3-410F-9C92-9A5CF616498F}</string>
						<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
                 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
                 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
                 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
	             'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
	             '_',
	             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd1</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF0CC6F8CA30D4C69AE1C3BFEF283A1A7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">stripAst</string>
						<string name="ScriptGuid">{0FE8128D-BA56-4B71-80CB-2DF03FBE8440}</string>
						<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)
local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

-- Strips as much whitespace off of tokens in an AST as possible without 
local function stripAst(ast)
	local stripStat, stripExpr;

	local function stript(token)
		token.LeadingWhite = ''
	end

	-- Make to adjacent tokens as close as possible
	local function joint(tokenA, tokenB)
		-- Strip the second token's whitespace
		stript(tokenB)

		-- Get the trailing A <-> leading B character pair
		local lastCh = tokenA.Source:sub(-1, -1)
		local firstCh = tokenB.Source:sub(1, 1)

		-- Cases to consider:
		--  Touching minus signs -> comment: `- -42` -> `--42' is invalid
		--  Touching dots: `.. .5` -> `...5` is invalid
		--  Touching words: `a b` -> `ab` is invalid
		--  Touching digits: `2 3`, can't occurr in the Lua syntax as number literals aren't a primary expression
		--  Abiguous syntax: `f(x)\n(x)()` is already disallowed, we can't cause a problem by removing newlines
		--  `>` `=` cannot be merged, because they will become a `>=` token.

		-- Figure out what separation is needed
		if 
			(lastCh == '-' and firstCh == '-') or
			(lastCh == '>' and firstCh == '=') or
			(lastCh == '.' and firstCh == '.') or
			(AllIdentifierCharacters[lastCh] and AllIdentifierCharacters[firstCh]) 
		then
			tokenB.LeadingWhite = ' ' -- Use a separator
		else
			tokenB.LeadingWhite = '' -- Don't use a separator
		end
	end

	-- Join up a statement body and it's opening / closing tokens
	local function bodyjoint(open, body, close)
		stripStat(body)
		stript(close)
		local bodyFirst = body:GetFirstToken()
		local bodyLast = body:GetLastToken()
		if bodyFirst then
			-- Body is non-empty, join body to open / close
			joint(open, bodyFirst)
			joint(bodyLast, close)
		else
			-- Body is empty, just join open and close token together
			joint(open, close)
		end
	end

	stripExpr = function(expr)
		if expr.Type == 'BinopExpr' then
			stripExpr(expr.Lhs)
			stript(expr.Token_Op)
			stripExpr(expr.Rhs)
			-- Handle the `a - -b` -/-> `a--b` case which would otherwise incorrectly generate a comment
			-- Also handles operators "or" / "and" which definitely need joining logic in a bunch of cases
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			joint(expr.Lhs:GetLastToken(), expr.Token_Op)
		elseif expr.Type == 'UnopExpr' then
			stript(expr.Token_Op)
			stripExpr(expr.Rhs)
			-- Handle the `- -b` -/-> `--b` case which would otherwise incorrectly generate a comment
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Just print the token
			stript(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			stripExpr(expr.Base)
			stript(expr.Token_Dot)
			stript(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			stripExpr(expr.Base)
			stript(expr.Token_OpenBracket)
			stripExpr(expr.Index)
			stript(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			stripExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				stript(expr.Token_Colon)
				stript(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				stript(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				stript(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					stripExpr(argExpr)
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						stript(sep)
					end
				end
				stript(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				stripExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			stript(expr.Token_Function)
			stript(expr.Token_OpenParen)
			expr.Token_ArgColonList = {}
			expr.ArgTypeList = {}
			expr.Token_Colon = nil
			expr.ReturnType = nil
			for index, arg in pairs(expr.ArgList) do
				stript(arg)
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if expr.Token_Varg then
				stript(expr.Token_Varg)
			end
			stript(expr.Token_CloseParen)
			bodyjoint(expr.Token_CloseParen, expr.Body, expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			stript(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			stript(expr.Token_OpenParen)
			stripExpr(expr.Expression)
			stript(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			stript(expr.Token_OpenBrace)
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					stript(entry.Field)
					stript(entry.Token_Equals)
					stripExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					stript(entry.Token_OpenBracket)
					stripExpr(entry.Index)
					stript(entry.Token_CloseBracket)
					stript(entry.Token_Equals)
					stripExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					stripExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
				local sep = expr.Token_SeparatorList[index]
				if sep then
					stript(sep)
				end
			end
			-- Trailing separator is never needed, EG: {a = 5; b = 6;} -> {a=5;b=6}
			expr.Token_SeparatorList[#expr.EntryList] = nil
			stript(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end

	stripStat = function(stat)
		if stat.Type == 'StatList' then
			-- Strip all surrounding whitespace on statement lists along with separating whitespace
			local i = 1
			while i <= #stat.StatementList do
				local chStat = stat.StatementList[i]

				-- Strip the statement and it's whitespace
				local deleted = stripStat(chStat)
				if deleted then
					table.remove(stat.StatementList, i)
					table.remove(stat.SemicolonList, i)
					continue
				end
				stript(chStat:GetFirstToken())

				-- Have max one semicolon between statements
				if stat.SemicolonList[i] then
					stat.SemicolonList[i] = {stat.SemicolonList[i][1]}
				end

				-- If there was a last statement, join them appropriately
				local lastChStat = stat.StatementList[i-1]
				if lastChStat then
					-- See if we can remove a semi-colon, the only case where we can't is if
					-- this and the last statement have a `);(` pair, where removing the semi-colon
					-- would introduce ambiguous syntax.
					if stat.SemicolonList[i-1] and 
						(lastChStat:GetLastToken().Source ~= ')' or chStat:GetFirstToken().Source ~= ')')
					then
						stat.SemicolonList[i-1] = nil
					end

					-- If there isn't a semi-colon, we should safely join the two statements
					-- (If there is one, then no whitespace leading chStat is always okay)
					if stat.SemicolonList[i-1] then
						joint(lastChStat:GetLastToken(), chStat:GetFirstToken())
					end
					
					chStat:GetFirstToken().LeadingWhite = " "
				end

				i += 1
			end

			-- A semi-colon is never needed on the last stat in a statlist:
			stat.SemicolonList[#stat.StatementList] = nil

			-- The leading whitespace on the statlist should be stripped
			if #stat.StatementList > 0 then
				stript(stat.StatementList[1]:GetFirstToken())
			end

		elseif stat.Type == 'BreakStat' then
			stript(stat.Token_Break)

		elseif stat.Type == 'ContinueStat' then
			stript(stat.Token_Continue)

		elseif stat.Type == 'ReturnStat' then
			stript(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				stripExpr(expr)
				if stat.Token_CommaList[index] then
					stript(stat.Token_CommaList[index])
				end
			end
			if #stat.ExprList > 0 then
				joint(stat.Token_Return, stat.ExprList[1]:GetFirstToken())
			end
		elseif stat.Type == 'LocalVarStat' then
			stript(stat.Token_Local)
			stat.Token_VarColonList = {}
			stat.TypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_Local, var)
				else
					stript(var)
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.Token_Equals then
				stript(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					stripExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						stript(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			stript(stat.Token_Local)
			stat.FunctionStat.Token_ArgColonList = {}
			stat.FunctionStat.ArgTypeList = {}
			stat.FunctionStat.Token_Colon = nil
			stat.FunctionStat.ReturnType = nil
			joint(stat.Token_Local, stat.FunctionStat.Token_Function)
			joint(stat.FunctionStat.Token_Function, stat.FunctionStat.NameChain[1])
			joint(stat.FunctionStat.NameChain[1], stat.FunctionStat.Token_OpenParen)
			for index, arg in pairs(stat.FunctionStat.ArgList) do
				stript(arg)
				local comma = stat.FunctionStat.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.FunctionStat.Token_Varg then
				stript(stat.FunctionStat.Token_Varg)
			end
			stript(stat.FunctionStat.Token_CloseParen)
			bodyjoint(stat.FunctionStat.Token_CloseParen, stat.FunctionStat.Body, stat.FunctionStat.Token_End)
		elseif stat.Type == 'FunctionStat' then
			stript(stat.Token_Function)
			stat.Token_ArgColonList = {}
			stat.ArgTypeList = {}
			stat.Token_Colon = nil
			stat.ReturnType = nil
			for index, part in pairs(stat.NameChain) do
				if index == 1 then
					joint(stat.Token_Function, part)
				else
					stript(part)
				end
				local sep = stat.Token_NameChainSeparator[index]
				if sep then
					stript(sep)
				end
			end
			stript(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				stript(arg)
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.Token_Varg then
				stript(stat.Token_Varg)
			end
			stript(stat.Token_CloseParen)
			bodyjoint(stat.Token_CloseParen, stat.Body, stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			stript(stat.Token_Repeat)
			bodyjoint(stat.Token_Repeat, stat.Body, stat.Token_Until)
			stripExpr(stat.Condition)
			joint(stat.Token_Until, stat.Condition:GetFirstToken())
		elseif stat.Type == 'GenericForStat' then
			stript(stat.Token_For)
			stat.Token_VarColonList = {}
			stat.VarTypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_For, var)
				else
					stript(var)
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.VarList[#stat.VarList], stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				stripExpr(expr)
				if index == 1 then
					joint(stat.Token_In, expr:GetFirstToken())
				end
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.GeneratorList[#stat.GeneratorList]:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			stript(stat.Token_For)
			stat.Token_VarColonList = {}
			stat.VarTypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_For, var)
				else
					stript(var)
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.VarList[#stat.VarList], stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				stripExpr(expr)
				if index == 1 then
					joint(stat.Token_Equals, expr:GetFirstToken())
				end
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.RangeList[#stat.RangeList]:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)	
		elseif stat.Type == 'WhileStat' then
			stript(stat.Token_While)
			stripExpr(stat.Condition)
			stript(stat.Token_Do)
			joint(stat.Token_While, stat.Condition:GetFirstToken())
			joint(stat.Condition:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'DoStat' then
			stript(stat.Token_Do)
			stript(stat.Token_End)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'IfStat' then
			stript(stat.Token_If)
			stripExpr(stat.Condition)
			joint(stat.Token_If, stat.Condition:GetFirstToken())
			joint(stat.Condition:GetLastToken(), stat.Token_Then)
			--
			local lastBodyOpen = stat.Token_Then
			local lastBody = stat.Body
			--
			for _, clause in pairs(stat.ElseClauseList) do
				bodyjoint(lastBodyOpen, lastBody, clause.Token)
				lastBodyOpen = clause.Token
				--
				if clause.Condition then
					stripExpr(clause.Condition)
					joint(clause.Token, clause.Condition:GetFirstToken())
					joint(clause.Condition:GetLastToken(), clause.Token_Then)
					lastBodyOpen = clause.Token_Then
				end
				stripStat(clause.Body)
				lastBody = clause.Body
			end
			--
			bodyjoint(lastBodyOpen, lastBody, stat.Token_End)

		elseif stat.Type == 'CallExprStat' then
			stripExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				stripExpr(ex)
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					stript(sep)
				end
			end
			stript(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				stripExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					stript(sep)
				end
			end
		elseif stat.Type == 'TypeStat' then
			return true
		else
			assert(false, "unreachable")
		end	
	end

	return stripStat(ast)
end

return stripAst]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd2</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCF23243B0CA04015BA707FF7F2CE077E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">formatAst</string>
						<string name="ScriptGuid">{E28E52A2-F831-4335-978F-6A0F2D39A0FA}</string>
						<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)
local WhitespaceCharacters = require(script.Parent.WhitespaceCharacters)
local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

-- Adds / removes whitespace in an AST to put it into a "standard formatting"
local function formatAst(ast)
	local formatStat
	local formatExpr
	local formatType

	local currentIndent = 0

	local function applyIndent(token)
		local indentString = '\n'..('\t'):rep(currentIndent)
		if token.LeadingWhite == '' or (token.LeadingWhite:sub(-#indentString, -1) ~= indentString) then
			-- Trim existing trailing whitespace on LeadingWhite
			-- Trim trailing tabs and spaces, and up to one newline
			token.LeadingWhite = token.LeadingWhite:gsub("\n?[\t ]*$", "")
			token.LeadingWhite = token.LeadingWhite..indentString
		end
	end

	local function tighten(token)
		token.LeadingWhite = token.LeadingWhite:gsub("[ ]*$", "")
	end

	local function trim(token)
		tighten(token)
		token.LeadingWhite = token.LeadingWhite:gsub("^%s*", "")
	end

	local function indent()
		currentIndent = currentIndent + 1
	end

	local function undent()
		currentIndent = currentIndent - 1
		assert(currentIndent >= 0, "Undented too far")
	end

	local function leadingChar(tk)
		if #tk.LeadingWhite > 0 then
			return tk.LeadingWhite:sub(1,1)
		else
			return tk.Source:sub(1,1)
		end
	end

	local function joint(tokenA, tokenB)
		-- Get the trailing A <-> leading B character pair
		local lastCh = tokenA.Source:sub(-1, -1)
		local firstCh = tokenB.Source:sub(1, 1)

		-- Cases to consider:
		--  Touching minus signs -> comment: `- -42` -> `--42' is invalid
		--  Touching dots: `.. .5` -> `...5` is invalid
		--  Touching words: `a b` -> `ab` is invalid
		--  Touching digits: `2 3`, can't occurr in the Lua syntax as number literals aren't a primary expression
		--  Abiguous syntax: `f(x)\n(x)()` is already disallowed, we can't cause a problem by removing newlines
		--  `>` `=` cannot be merged, because they will become a `>=` token.

		-- Figure out what separation is needed
		if 
			(lastCh == '-' and firstCh == '-') or
			(lastCh == '>' and firstCh == '=') or
			(lastCh == '.' and firstCh == '.') or
			(AllIdentifierCharacters[lastCh] and AllIdentifierCharacters[firstCh]) 
		then
			tokenB.LeadingWhite = ' ' -- Use a separator
		else
			tokenB.LeadingWhite = '' -- Don't use a separator
		end
	end

	local function padToken(tk)
		tighten(tk)
		if not WhitespaceCharacters[leadingChar(tk)] then
			tk.LeadingWhite = ' '..tk.LeadingWhite
		end
	end

	local function padExpr(expr)
		padToken(expr:GetFirstToken())
	end

	local function formatBody(openToken, bodyStat, closeToken)
		indent()
		formatStat(bodyStat)
		undent()
		applyIndent(closeToken)
	end

	formatType = function(typeExpr)
		tighten(typeExpr:GetFirstToken())
		if typeExpr.Type == 'BasicType' then
			for index, ident in pairs(typeExpr.IdentList) do
				tighten(ident)
				if typeExpr.Token_IdentDotList[index] then
					tighten(typeExpr.Token_IdentDotList[index])
				end
			end
			if typeExpr.Token_OpenAngle then
				tighten(typeExpr.Token_OpenAngle)
				for index, typeArg in pairs(typeExpr.GenericArgumentList) do
					formatType(typeArg)
					if index == 1 then
						tighten(typeArg:GetFirstToken())
					else
						padToken(typeArg:GetFirstToken())
					end
					if typeExpr.Token_GenericArgumentCommaList[index] then
						tighten(typeExpr.Token_GenericArgumentCommaList[index])
					end
				end
				tighten(typeExpr.Token_CloseAngle)
			end
		elseif typeExpr.Type == 'NilType' then
			tighten(typeExpr.Token_Nil)
		elseif typeExpr.Type == 'TypeofType' then
			--(typeExpr.Token_Typeof)
			tighten(typeExpr.Token_OpenParen)
			formatExpr(typeExpr.Expression)
			tighten(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'FunctionType' then
			formatType(typeExpr.ArgType)
			padToken(typeExpr.Token_Arrow)
			formatType(typeExpr.ReturnType)
			padToken(typeExpr.ReturnType:GetFirstToken())
		elseif typeExpr.Type == 'TupleType' then
			--(typeExpr.Token_OpenParen)
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				formatType(subTypeExpr)
				if index == 1 then
					tighten(subTypeExpr:GetFirstToken())
				else
					padToken(subTypeExpr:GetFirstToken())
				end
				if typeExpr.Token_CommaList[index] then
					tighten(typeExpr.Token_CommaList[index])
				end
			end
			tighten(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'TableType' then
			--(typeExpr.Token_OpenBrace)
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					if index == 1 then
						tighten(record.Token_OpenBracket)
					else
						padToken(record.Token_OpenBracket)
					end
					formatType(record.KeyType)
					tighten(record.Token_CloseBracket)
					tighten(record.Token_Colon)
					formatType(record.ValueType)
					padToken(record.ValueType:GetFirstToken())
				elseif record.Type == 'Name' then
					if index == 1 then
						tighten(record.Ident)
					else
						padToken(record.Ident)
					end
					tighten(record.Token_Colon)
					formatType(record.ValueType)
					padToken(record.ValueType:GetFirstToken())
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
				if typeExpr.Token_CommaList[index] then
					tighten(typeExpr.Token_CommaList[index])
				end
			end
			tighten(typeExpr.Token_CloseBrace)
		elseif typeExpr.Type == 'OptionalType' then
			formatType(typeExpr.BaseType)
			tighten(typeExpr.Token_QuestionMark)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				formatType(subTypeExpr)
				if index > 1 then
					padToken(subTypeExpr:GetFirstToken())
				end
				if typeExpr.Token_CombinerList[index] then
					padToken(typeExpr.Token_CombinerList[index])
				end
			end
		else
			error("Bad typeExpr type in: "..formatTable(typeExpr))
		end
	end

	formatExpr = function(expr)
		tighten(expr:GetFirstToken())
		if expr.Type == 'BinopExpr' then
			formatExpr(expr.Lhs)
			formatExpr(expr.Rhs)
			if expr.Token_Op.Source == '..' then
				-- Only necessary padding on ..
				joint(expr.Lhs:GetLastToken(), expr.Token_Op)
				joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			else
				padExpr(expr.Rhs)
				padToken(expr.Token_Op)
			end
		elseif expr.Type == 'UnopExpr' then
			formatExpr(expr.Rhs)
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			--(expr.Token_Op)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Nothing to do
			--(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			formatExpr(expr.Base)
			tighten(expr.Token_Dot)
			tighten(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			formatExpr(expr.Base)
			formatExpr(expr.Index)
			--(expr.Token_OpenBracket)
			--(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			formatExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				--(expr.Token_Colon)
				--(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				--(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				--(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					formatExpr(argExpr)
					if index > 1 then
						padExpr(argExpr)
					end
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						tighten(sep)
					end
				end
				--(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				formatExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			--(expr.Token_Function)
			tighten(expr.Token_OpenParen)
			for index, arg in pairs(expr.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = expr.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(expr.ArgTypeList[index])
				end
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #expr.ArgList > 0 and expr.Token_Varg then
				padToken(expr.Token_Varg)
			end
			tighten(expr.Token_CloseParen)
			if expr.Token_Colon then
				tighten(expr.Token_Colon)
				formatType(expr.ReturnType)
				padToken(expr.ReturnType:GetFirstToken())
			end
			formatBody(expr.Token_CloseParen, expr.Body, expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			--(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			formatExpr(expr.Expression)
			--(expr.Token_OpenParen)
			tighten(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			--(expr.Token_OpenBrace)
			if #expr.EntryList == 0 then
				-- Nothing to do
			else
				indent()
				for index, entry in pairs(expr.EntryList) do
					if entry.EntryType == 'Field' then
						applyIndent(entry.Field)
						padToken(entry.Token_Equals)
						formatExpr(entry.Value)
						padExpr(entry.Value)
					elseif entry.EntryType == 'Index' then
						applyIndent(entry.Token_OpenBracket)
						formatExpr(entry.Index)
						tighten(entry.Token_CloseBracket)
						padToken(entry.Token_Equals)
						formatExpr(entry.Value)
						padExpr(entry.Value)
					elseif entry.EntryType == 'Value' then
						formatExpr(entry.Value)
						applyIndent(entry.Value:GetFirstToken())
					else
						assert(false, "unreachable")
					end
					local sep = expr.Token_SeparatorList[index]
					if sep then
						tighten(sep)
					end
				end
				undent()
				applyIndent(expr.Token_CloseBrace)
			end
			tighten(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end

	formatStat = function(stat)
		if stat.Type == 'StatList' then
			for _, stat in pairs(stat.StatementList) do
				formatStat(stat)
				applyIndent(stat:GetFirstToken())
			end

		elseif stat.Type == 'BreakStat' then
			--(stat.Token_Break)

		elseif stat.Type == 'ContinueStat' then
			--(stat.Token_Continue)

		elseif stat.Type == 'TypeStat' then
			if stat.Token_Export then
				tighten(stat.Token_Export)
				padToken(stat.Token_Type)
			else
				tighten(stat.Token_Type)
			end
				
			padToken(stat.Ident)
			if stat.Token_OpenAngle then
				tighten(stat.Token_OpenAngle)
				for index, ident in pairs(stat.GenericTypeList) do
					if index == 1 then
						tighten(ident)
					else
						padToken(ident)
					end
					if stat.Token_GenericTypeCommaList[index] then
						tighten(stat.Token_GenericTypeCommaList[index])
					end
				end
				tighten(stat.Token_CloseAngle)
			end
			padToken(stat.Token_Equals)
			formatType(stat.AliasedType)
			padToken(stat.AliasedType:GetFirstToken())

		elseif stat.Type == 'ReturnStat' then
			--(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				formatExpr(expr)
				padExpr(expr)
				if stat.Token_CommaList[index] then
					--(stat.Token_CommaList[index])
					tighten(stat.Token_CommaList[index])
				end
			end
		elseif stat.Type == 'LocalVarStat' then
			--(stat.Token_Local)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.TypeList[index])
					padToken(stat.TypeList[index]:GetFirstToken())
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if stat.Token_Equals then
				padToken(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					formatExpr(expr)
					padExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						tighten(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			--(stat.Token_Local)
			padToken(stat.FunctionStat.Token_Function)
			padToken(stat.FunctionStat.NameChain[1])
			tighten(stat.FunctionStat.Token_OpenParen)
			for index, arg in pairs(stat.FunctionStat.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = stat.FunctionStat.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.FunctionStat.ArgTypeList[index])
					padToken(stat.FunctionStat.ArgTypeList[index]:GetFirstToken())
				end
				local comma = stat.FunctionStat.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #stat.FunctionStat.ArgList > 0 and stat.FunctionStat.Token_Varg then
				padToken(stat.FunctionStat.Token_Varg)
			end
			tighten(stat.FunctionStat.Token_CloseParen)
			if stat.FunctionStat.Token_Colon then
				tighten(stat.FunctionStat.Token_Colon)
				formatType(stat.FunctionStat.ReturnType)
				padToken(stat.FunctionStat.ReturnType:GetFirstToken())
			end
			formatBody(stat.FunctionStat.Token_CloseParen, stat.FunctionStat.Body, stat.FunctionStat.Token_End)
		elseif stat.Type == 'FunctionStat' then
			--(stat.Token_Function)
			for index, part in pairs(stat.NameChain) do
				if index == 1 then
					padToken(part)
				end
				local sep = stat.Token_NameChainSeparator[index]
				if sep then
					tighten(sep)
				end
			end
			tighten(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = stat.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.ArgTypeList[index])
					padToken(stat.ArgTypeList[index]:GetFirstToken())
				end
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #stat.ArgList > 0 and stat.Token_Varg then
				padToken(stat.Token_Varg)
			end
			tighten(stat.Token_CloseParen)
			if stat.Token_Colon then
				tighten(stat.Token_Colon)
				formatType(stat.ReturnType)
				padToken(stat.ReturnType:GetFirstToken())
			end
			formatBody(stat.Token_CloseParen, stat.Body, stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			--(stat.Token_Repeat)
			formatBody(stat.Token_Repeat, stat.Body, stat.Token_Until)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			--(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.VarTypeList[index])
					padToken(stat.VarTypeList[index]:GetFirstToken())
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				formatExpr(expr)
				padExpr(expr)
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			--(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.VarTypeList[index])
					padToken(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				formatExpr(expr)
				padExpr(expr)
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)	
		elseif stat.Type == 'WhileStat' then
			--(stat.Token_While)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'DoStat' then
			--(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'IfStat' then
			--(stat.Token_If)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
			padToken(stat.Token_Then)
			--
			local lastBodyOpen = stat.Token_Then
			local lastBody = stat.Body
			--
			for _, clause in pairs(stat.ElseClauseList) do
				formatBody(lastBodyOpen, lastBody, clause.Token)
				lastBodyOpen = clause.Token
				--
				if clause.Condition then
					formatExpr(clause.Condition)
					padExpr(clause.Condition)
					padToken(clause.Token_Then)
					lastBodyOpen = clause.Token_Then
				end
				lastBody = clause.Body
			end
			--
			formatBody(lastBodyOpen, lastBody, stat.Token_End)

		elseif stat.Type == 'CallExprStat' then
			formatExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				formatExpr(ex)
				if index > 1 then
					padExpr(ex)
				end
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					--(sep)
					tighten(sep)
				end
			end
			padToken(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				formatExpr(ex)
				padExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					--(sep)
					tighten(sep)
				end
			end
		else
			assert(false, "unreachable")
		end	
	end

	formatStat(ast)
	trim(ast:GetFirstToken())
end

return formatAst]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd3</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX43053CAD2FC04CF68C37F869A080627A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">generateVariableName</string>
						<string name="ScriptGuid">{331D19B7-B7F6-40F4-91A0-A1522E256287}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Turns an index [0..n) into a variable name. 
0 -> '_'
1 -> 'a'
27 -> 'z'
28 -> '_a'
29 -> '_b' 
etc...
]]
local VarDigits = {'_'}
for i = ('a'):byte(), ('z'):byte() do table.insert(VarDigits, string.char(i)) end
for i = ('A'):byte(), ('Z'):byte() do table.insert(VarDigits, string.char(i)) end
for i = ('0'):byte(), ('9'):byte() do table.insert(VarDigits, string.char(i)) end

local VarStartDigits = {'_'}
for i = ('a'):byte(), ('z'):byte() do table.insert(VarStartDigits, string.char(i)) end
for i = ('A'):byte(), ('Z'):byte() do table.insert(VarStartDigits, string.char(i)) end

local function generateVariableName(index)
	local id = ''
	local d = index % #VarStartDigits
	index = (index - d) / #VarStartDigits
	id = id..VarStartDigits[d+1]
	while index > 0 do
		local d = index % #VarDigits
		index = (index - d) / #VarDigits
		id = id..VarDigits[d+1]
	end
	return id
end

return generateVariableName]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd4</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE97AC342C7BE41BEBB72E7546D144F16">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">beautifyVariables</string>
						<string name="ScriptGuid">{B8EE838E-1F63-4C7F-9905-ED69F19D838D}</string>
						<ProtectedString name="Source"><![CDATA[local function beautifyVariables(globalScope, rootScope, renameGlobals)
	local externalGlobals = {}
	for _, var in pairs(globalScope) do
		if not var.AssignedTo or not renameGlobals then
			externalGlobals[var.Name] = true
		end
	end

	local localNumber = 1
	local globalNumber = 1

	local function setVarName(var, name)
		var.Name = name
		for _, setter in pairs(var.RenameList) do
			setter(name)
		end
	end

	if renameGlobals then
		for _, var in pairs(globalScope) do
			if var.AssignedTo then
				setVarName(var, 'G_'..globalNumber..'_')
				globalNumber = globalNumber + 1
			end
		end
	end

	local function modify(scope)
		for _, var in pairs(scope.VariableList) do
			local name = 'L_'..localNumber..'_'
			if var.Info.Type == 'Argument' then
				name = name..'arg'..var.Info.Index
			elseif var.Info.Type == 'LocalFunction' then
				name = name..'func'
			elseif var.Info.Type == 'ForRange' then
				name = name..'forvar'..var.Info.Index
			end
			setVarName(var, name)
			localNumber = localNumber + 1
		end
		for _, scope in pairs(scope.ChildScopeList) do
			modify(scope)
		end
	end
	modify(rootScope)
end

return beautifyVariables]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd5</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1D908187D7EE4439890ACB47B3182548">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">minifyVariablesBasic</string>
						<string name="ScriptGuid">{768CF6F1-C481-4AAA-B98F-347D4BFEB1C3}</string>
						<ProtectedString name="Source"><![CDATA[local Keywords = require(script.Parent.Keywords)

local generateVariableName = require(script.Parent.generateVariableName)

local function minifyVariables(globalScope, rootScope)
	-- externalGlobals is a set of global variables that have not been assigned to, that is
	-- global variables defined "externally to the script". We are not going to be renaming 
	-- those, and we have to make sure that we don't collide with them when renaming 
	-- things so we keep track of them in this set.
	local externalGlobals = {}

	-- First we want to rename all of the variables to unique temoraries, so that we can
	-- easily use the scope::GetVar function to check whether renames are valid.
	local temporaryIndex = 0
	for _, var in pairs(globalScope) do
		if var.AssignedTo then
			var:Rename('_TMP_'..temporaryIndex..'_')
			temporaryIndex = temporaryIndex + 1
		else
			-- Not assigned to, external global
			externalGlobals[var.Name] = true
		end
	end
	local function temporaryRename(scope)
		for _, var in pairs(scope.VariableList) do
			var:Rename('_TMP_'..temporaryIndex..'_')
			temporaryIndex = temporaryIndex + 1
		end
		for _, childScope in pairs(scope.ChildScopeList) do
			temporaryRename(childScope)
		end
	end

	-- Now we go through renaming, first do globals, we probably want them
	-- to have shorter names in general.
	-- TODO: Rename all vars based on frequency patterns, giving variables
	--       used more shorter names.
	local nextFreeNameIndex = 0
	for _, var in pairs(globalScope) do
		if var.AssignedTo then
			local varName = ''
			repeat
				varName = generateVariableName(nextFreeNameIndex)
				nextFreeNameIndex = nextFreeNameIndex + 1
			until not Keywords[varName] and not externalGlobals[varName]
			var:Rename(varName)
		end
	end

	-- Now rename all local vars
	rootScope.FirstFreeName = nextFreeNameIndex
	local function doRenameScope(scope)
		for _, var in pairs(scope.VariableList) do
			local varName = ''
			repeat
				varName = generateVariableName(scope.FirstFreeName)
				scope.FirstFreeName = scope.FirstFreeName + 1
			until not Keywords[varName] and not externalGlobals[varName]
			var:Rename(varName)
		end
		for _, childScope in pairs(scope.ChildScopeList) do
			childScope.FirstFreeName = scope.FirstFreeName
			doRenameScope(childScope)
		end
	end
	doRenameScope(rootScope)
end

return minifyVariables]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd6</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6529242F69F1403CAAD3BF6CBB8D469C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">minifyVariablesAdvanced</string>
						<string name="ScriptGuid">{6F6D632A-4472-428F-9C90-1FE1C7088DBD}</string>
						<ProtectedString name="Source"><![CDATA[local Keywords = require(script.Parent.Keywords)

local generateVariableName = require(script.Parent.generateVariableName)

local function minifyVariables(globalScope, rootScope, renameGlobals)
	-- Variable names and other names that are fixed, that we cannot use
	-- Either these are Lua keywords, or globals that are not assigned to,
	-- that is environmental globals that are assigned elsewhere beyond our 
	-- control.
	local globalUsedNames = {}
	for kw, _ in pairs(Keywords) do
		globalUsedNames[kw] = true
	end

	-- Gather a list of all of the variables that we will rename
	local allVariables = {}
	local allLocalVariables = {}
	do
		-- Add applicable globals
		for _, var in pairs(globalScope) do
			if var.AssignedTo and renameGlobals then
				-- We can try to rename this global since it was assigned to
				-- (and thus presumably initialized) in the script we are 
				-- minifying.
				table.insert(allVariables, var)
			else
				-- We can't rename this global, mark it as an unusable name
				-- and don't add it to the nename list
				globalUsedNames[var.Name] = true
			end
		end

		-- Recursively add locals, we can rename all of those
		local function addFrom(scope)
			for _, var in pairs(scope.VariableList) do
				table.insert(allVariables, var)
				table.insert(allLocalVariables, var)
			end
			for _, childScope in pairs(scope.ChildScopeList) do
				addFrom(childScope)
			end
		end
		addFrom(rootScope)
	end

	-- Add used name arrays to variables
	for _, var in pairs(allVariables) do
		var.UsedNameArray = {}
	end

	-- Sort the least used variables first
	table.sort(allVariables, function(a, b)
		return #a.RenameList < #b.RenameList
	end)

	-- Lazy generator for valid names to rename to
	local nextValidNameIndex = 0
	local varNamesLazy = {}
	local function varIndexToValidVarName(i)
		local name = varNamesLazy[i] 
		if not name then
			repeat
				name = generateVariableName(nextValidNameIndex)
				nextValidNameIndex = nextValidNameIndex + 1
			until not globalUsedNames[name]
			varNamesLazy[i] = name
		end
		return name
	end

	-- For each variable, go to rename it
	for _, var in pairs(allVariables) do
		-- Lazy... todo: Make theis pair a proper for-each-pair-like set of loops 
		-- rather than using a renamed flag.
		var.Renamed = true

		-- Find the first unused name
		local i = 1
		while var.UsedNameArray[i] do
			i = i + 1
		end

		-- Rename the variable to that name
		var:Rename(varIndexToValidVarName(i))

		if var.Scope then
			-- Now we need to mark the name as unusable by any variables:
			--  1) At the same depth that overlap lifetime with this one
			--  2) At a deeper level, which have a reference to this variable in their lifetimes
			--  3) At a shallower level, which are referenced during this variable's lifetime
			for _, otherVar in pairs(allVariables) do
				if not otherVar.Renamed then
					if not otherVar.Scope or otherVar.Scope.Depth < var.Scope.Depth then
						-- Check Global variable (Which is always at a shallower level)
						--  or
						-- Check case 3
						-- The other var is at a shallower depth, is there a reference to it
						-- durring this variable's lifetime?
						for _, refAt in pairs(otherVar.ReferenceLocationList) do
							if refAt >= var.BeginLocation and refAt <= var.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end

					elseif otherVar.Scope.Depth > var.Scope.Depth then
						-- Check Case 2
						-- The other var is at a greater depth, see if any of the references
						-- to this variable are in the other var's lifetime.
						for _, refAt in pairs(var.ReferenceLocationList) do
							if refAt >= otherVar.BeginLocation and refAt <= otherVar.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end

					else --otherVar.Scope.Depth must be equal to var.Scope.Depth
						-- Check case 1
						-- The two locals are in the same scope
						-- Just check if the usage lifetimes overlap within that scope. That is, we
						-- can shadow a local variable within the same scope as long as the usages
						-- of the two locals do not overlap.
						if var.BeginLocation < otherVar.EndLocation and
							var.EndLocation > otherVar.BeginLocation
						then
							otherVar.UsedNameArray[i] = true
						end
					end
				end
			end
		else
			-- This is a global var, all other globals can't collide with it, and
			-- any local variable with a reference to this global in it's lifetime
			-- can't collide with it.
			for _, otherVar in pairs(allVariables) do
				if not otherVar.Renamed then
					if otherVar.Type == 'Global' then
						otherVar.UsedNameArray[i] = true
					elseif otherVar.Type == 'Local' then
						-- Other var is a local, see if there is a reference to this global within
						-- that local's lifetime.
						for _, refAt in pairs(var.ReferenceLocationList) do
							if refAt >= otherVar.BeginLocation and refAt <= otherVar.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end
					else
						assert(false, "unreachable")
					end
				end
			end
		end
	end


	-- -- 
	-- print("Total Variables: "..#allVariables)
	-- print("Total Range: "..rootScope.BeginLocation.."-"..rootScope.EndLocation)
	-- print("")
	-- for _, var in pairs(allVariables) do
	-- 	io.write("`"..var.Name.."':\n\t#symbols: "..#var.RenameList..
	-- 		"\n\tassigned to: "..tostring(var.AssignedTo))
	-- 	if var.Type == 'Local' then
	-- 		io.write("\n\trange: "..var.BeginLocation.."-"..var.EndLocation)
	-- 		io.write("\n\tlocal type: "..var.Info.Type)
	-- 	end
	-- 	io.write("\n\n")
	-- end

	-- -- First we want to rename all of the variables to unique temoraries, so that we can
	-- -- easily use the scope::GetVar function to check whether renames are valid.
	-- local temporaryIndex = 0
	-- for _, var in pairs(allVariables) do
	-- 	var:Rename('_TMP_'..temporaryIndex..'_')
	-- 	temporaryIndex = temporaryIndex + 1
	-- end

	-- For each variable, we need to build a list of names that collide with it

	--
	--error()
end

return minifyVariables]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd7</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80BBB1B3E93F4EE7A65090E674A8B21F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">parse.spec</string>
						<string name="ScriptGuid">{18ACC8F0-B66C-4641-8EBB-1E137548A7E8}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	
	local function doParse(code)
		parse(tokenize(code))
	end
	
	describe("basic parsing", function()
		it("should parse a basic script", function()
			doParse[[local a = 5]]
		end)
	end)
	
	describe("export types", function()
		it("should parse an export type", function()
			doParse[[export type foo = bar<string>]]
		end)
	end)
	
	describe("typeof types", function()
		it("should let you define a type via typeof", function()
			doParse[[local a: typeof(foo + bar);]]
		end)
	end)
	
	describe("generic type usage", function()
		it("should handle you using a generic type", function()
			doParse[[local n: Thing<number, string> = 6]]
		end)
		
		it("should handle the `>=` case in a local statement", function()
			doParse[[local n: Thing<number>= 6]]
		end)
	end)
	
	describe("type statement", function()
		it("should let you alias a type", function()
			doParse[[type Foo = number]]
		end)

		it("should let you alias a generic type", function()
			doParse[[type Set<T> = {[T]: boolean}]]
		end)

		it("should let you use multiple generic argument", function()
			doParse[[type Map<K,V> = {[K]: V}]]
		end)

		it("should handle the `>=` token correctly", function()
			doParse[[type Generic<T>=T]]
		end)
	end)
	
	describe("nil type", function()
		it("can be used in a type statement", function()
			doParse[[type Foo = nil]]
			doParse[[type FooTable = {[number]: nil}]]
		end)
		
		it("can be used as a type", function()
			doParse[[local a: nil = nil]]
		end)
	end)

	describe("table types", function()
		it("should parse a basic table type", function()
			doParse[[
			local a: {}
			]]
		end)

		it("should parse name fields", function()
			doParse[[
			local a: {a: number, b:string}
			local b: {b: c?}?
			]]
		end)

		it("should parse type fields", function()
			doParse[[
			local b: {[boolean]: number}
			local c: {[string]: string, [() -> boolean]: number} = 5
			]]
		end)
	end)
	
	describe("function types", function()
		it("should parse a function with return type", function()
			doParse[[
			function a(b:c, d:e): (f, g)
			end
			]]
		end)

		it("should parse a function type", function()
			doParse[[
			local a: () -> number
			local b: ((number) -> number);
			]]
		end)
	end)

	describe("typed local declarations", function()
		it("should parse a local declaration without types", function()
			doParse[[
			local a
			local b = 7
			local c, d
			]]
		end)

		it("should parse a local declaration with basic types", function()
			doParse[[
			local a: number = 7
			local b, c: string = 7, "test"
			]]
		end)
	end)
	
	describe("compound assigment", function()
		it("should parse a compound assignment operator", function()
			doParse[[
			a += 1
			a -= 2
			a /= 3
			a *= 4
			a ^= 5
			a %= 6
			]]
		end)
		
		it("should not parse a compound assignment with multiple parts", function()
			expect(function()
				doParse[[
				a, b += 6, 7
				]]
			end).to.throw()
		end)
	end)
	
	describe("continue", function()
		it("should parse a continue statement", function()
			doParse[[
			while true do
				continue
			end
			]]
		end)
		
		it("should parse a continue statement with semis", function()
			doParse[[
			while true do
				continue;;
			end
			]]
		end)
		
		it("should parse a continue call", function()
			doParse[[
			while true do
				continue()
			end
			]]
		end)
		
		it("should parse a continue call with semis", function()
			doParse[[
			while true do
				continue();;
			end
			]]
		end)
		
		it("should accept continue as a variable", function()
			doParse[[local continue = 5]]
		end)
	end)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd8</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC6AD27B9E0424B0CA4219B3112182695">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">encodeStrings</string>
						<string name="ScriptGuid">{98FE1826-E6D8-437C-8BDF-9DED0A8F839D}</string>
						<ProtectedString name="Source"><![CDATA[
function encodeCharacter(normalCharacter)
	return "\\x"..string.format("%X", string.byte(normalCharacter))
end


function encode(str, quot)
	local elements = {quot}
	local p = 2
	local len = #str
	while p < len do
		local c = str:sub(p, p)
		if c == '\\' then
			-- Some kind of escape
			local escape = str:sub(p + 1, p + 1):lower()
			if escape == 'x' then
				-- Hexidecimal escape
				table.insert(elements, str:sub(p, p + 3))
				p += 4
			elseif escape == 'u' then
				local q = str:find('}', p)
				table.insert(elements, str:sub(p, q))
				p = q + 1
			else
				-- Normal escape
				table.insert(elements, '\\'..escape)
				p += 2
			end
		else
			-- Normal character
			table.insert(elements, encodeCharacter(c))
			p += 1
		end
	end
	table.insert(elements, quot)
	return table.concat(elements)
end

return function(tokens)
	for _, token in pairs(tokens) do
		if token.Type == 'String' then
			-- Don't modify long string constants
			local quot = token.Source:sub(1, 1)
			if quot == '"' or quot == "'" then
				token.Source = encode(token.Source, quot)
			end
		end	
	end
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bd9</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3F23EB515F0A4019A9102ACA0600AAEF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">decodeStrings</string>
						<string name="ScriptGuid">{0E5400D8-E4BA-4C4E-9622-B2CA0DD2EB6D}</string>
						<ProtectedString name="Source"><![CDATA[
local MIN_PRINTABLE = 32
local MAX_PRINTABLE = 126
local ESCAPES = {
	[string.byte('\a')] = 'a',
	[string.byte('\b')] = 'b',
	[string.byte('\f')] = 'f',
	[string.byte('\n')] = 'n',
	[string.byte('\t')] = 't',
	[string.byte('\r')] = 'r',
	[string.byte('\v')] = 'v',
}

function decodeCharacter(chars)
	local code = tonumber(chars, 16)
	local char = string.char(code)
	if code >= MIN_PRINTABLE and code <= MAX_PRINTABLE then
		return string.char(code)
	elseif code >= 0 and code <= 0xFF and ESCAPES[char] then
		return "\\"..ESCAPES[char]
	elseif code <= 0xFF then
		return string.format("\\x%X", code)	
	else
		return string.format("\\u{%X}", code)
	end
end

function decode(str, quot)
	local elements = {quot}
	local p = 2
	local len = #str
	while p < len do
		local c = str:sub(p, p)
		if c == '\\' then
			-- Some kind of escape
			local escape = str:sub(p + 1, p + 1):lower()
			if escape == 'x' then
				-- Hexidecimal escape
				table.insert(elements, decodeCharacter(str:sub(p + 2, p + 3)))
				p += 4
			elseif escape == 'u' then
				local q = str:find('}', p)
				table.insert(elements, decodeCharacter(str:sub(p + 3, q - 1)))
				p = q + 1
			else
				-- Normal escape
				table.insert(elements, '\\'..escape)
				p += 2
			end
		else
			-- Normal character
			table.insert(elements, c)
			p += 1
		end
	end
	table.insert(elements, quot)
	return table.concat(elements)
end

return function(tokens)
	for _, token in pairs(tokens) do
		if token.Type == 'String' then
			-- Don't modify long string constants
			local quot = token.Source:sub(1, 1)
			if quot == '"' or quot == "'" then
				token.Source = decode(token.Source, quot)
			end
		end	
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bda</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBE5983892FF74F03A091483E552825A6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">encodeStrings.spec</string>
						<string name="ScriptGuid">{62373A2E-A905-48E2-BA0F-A6B0B58C64FB}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local encodeStrings = require(script.Parent.encodeStrings)
	local tokenize = require(script.Parent.tokenize)

	describe("encoding string constants", function()
		it("should encode an empty string token", function()
			expect(function()
				encodeStrings(tokenize[[""]])
			end).never.to.throw()
		end)

		it("should encode a test string", function()
			local tokens = tokenize[["Testing"]]
			encodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["\x54\x65\x73\x74\x69\x6E\x67"]])
		end)

		it("should hex encode unicode text", function()
			local tokens = tokenize[["😜"]]
			encodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["\xF0\x9F\x98\x9C"]])
		end)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bdb</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD60A2EC72BE847219018225AFC8BD66D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">decodeStrings.spec</string>
						<string name="ScriptGuid">{8245985F-17FA-4D56-9F8D-0BAA24ED1E67}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local decodeStrings = require(script.Parent.decodeStrings)
	local tokenize = require(script.Parent.tokenize)
	
	describe("decoding string constants", function()
		it("should decode some ascii text as hex escapes", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\x20\n\x20\u{FFF}\x31\x32\x33"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing \n \u{FFF}123"]])
		end)
		
		it("should not decode a non-ascii character", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\xAB"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing\xAB"]])
		end)

		it("should uppercase hex and unicode escapes", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\xab\u{fff}"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing\xAB\u{FFF}"]])
		end)
	end)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bdc</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF5DDFB059641411EA6193C4B9F9C4DF5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">formatAst.spec</string>
						<string name="ScriptGuid">{A34F0C13-B96A-436E-BC46-47980A7EACEC}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local formatAst = require(script.Parent.formatAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	local printAst = require(script.Parent.printAst)
	
	local function doFormat(str)
		local ast = parse(tokenize(str))
		formatAst(ast)
		return printAst(ast)
	end
	
	describe("formatting statements", function()
		it("should format an export type statement", function()
			local str = doFormat[[export  type   foo<T > =blah]]
			expect(str).to.equal[[export type foo<T> = blah]]
		end)
		
		it("should format nil type usage", function()
			local str = doFormat[[local a:nil=nil]]
			expect(str).to.equal[[local a: nil = nil]]
		end)
		
		it("should format a qualified type", function()
			local str = doFormat[[local a:b.c =d.e.  f()]]
			expect(str).to.equal[[local a: b.c = d.e.f()]]
		end)
	end)
	
	describe("formatting locals", function()
		it("should format a local declaration", function()
			doFormat[[
			local a,b,c
			]]
		end)

		it("should format generic type arguments", function()
			local str = doFormat[[local a:foo<bar,baz>]]
			expect(str).to.equal[[local a: foo<bar, baz>]]
			local str2 = doFormat[[local  a  :  Set<T>=value]]
			expect(str2).to.equal[[local a: Set<T> = value]]
		end)

		it("should format a local declaration with types", function()
			local str = doFormat[[local a:number,b:string=7]]
			expect(str).to.equal[[local a: number, b: string = 7]]
			local str2 = doFormat[[local  a   : number,   b :  string  =  7]]
			expect(str2).to.equal[[local a: number, b: string = 7]]
		end)

		it("should format a typed function", function()
			local str = doFormat[[local function  foo(arg:t):number bar()end]]
			expect(str).to.equal"local function foo(arg: t): number\n\tbar()\nend"
		end)

		it("should format a continue statement", function()
			local str = doFormat[[while true do continue end]]
			expect(str).to.equal"while true do\n\tcontinue\nend"
		end)

		it("should format compound assignments", function()
			local str = doFormat[[a+=b b/=c e%=f]]
			expect(str).to.equal"a += b\nb /= c\ne %= f"
		end)

		it("should format a type statement", function()
			local str = doFormat[[type FooBar<T,U>=number]]
			expect(str).to.equal"type FooBar<T, U> = number"
			local str2 = doFormat[[type   FooBar   <T  ,  U  >  =  number]]
			expect(str2).to.equal"type FooBar<T, U> = number"
		end)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bdd</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX19903E48484E47CBAD171EB067D0D65C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">printAst.spec</string>
						<string name="ScriptGuid">{17C67A36-D594-439E-AD7E-35859D84CC8D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local printAst = require(script.Parent.printAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	
	describe("formatting", function()
		it("should print back loops with types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("for i: number, j:number in iterator() do end")
			check("for i: number = a, b, c  do end")
		end)
		
		it("should print generic type arguments", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a: FooBar<a, b, c>;")
			check("local a: baz< a, b,c> = 6")
		end)
		
		it("should print back typeof types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("type Foo=typeof(foo + bar)")
			check("local a:typeof(foobar) | {}")
		end)
		
		it("should print back type statements", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("type Foo=number")
			check("type Set<T >= {[T]: boolean}")
			check("type Map<K, V> =Bar")
			check("type Map<K,V>=Bar;;")
		end)
		
		it("should print back table types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a: { }")
			check("local a: {[number]: number}")
			check("local a:{field: value, foo:bar}")
			check("local a:  {field: value, [type]: type}")
		end)

		it("should print complex types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a:(b)->c")
			check("local a:(b,c?)->d? | e")
			check("local a: (b & c) | d? | (e)->(f | g)?")
		end)

		it("should print local statements", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a")
			check("local a;")
			check("local a,b,c")
			check("local a:type")
			check("local a, b, c")
			check("local a,b: type = c")
			check("local a, b: type=c")
		end)

		it("should print function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("function a() end")
			check("function a(...) end")
			check("function a(a,b, ...) end")
			check("function a(a:type, c,...): t end")
			check("function a(a:c,e:f) end")
		end)

		it("should print function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local function a() end")
			check("local function a(...) end")
			check("local function a(a,b, ...) end")
			check("local function a(a:type, c,...): t end")
			check("local function a(a:c,e:f) end")
		end)

		it("should print anonymous function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("a = function(a,b, ...) end")
			check("a = function(a:type, b): t end")
			check("a = function(a, b:type,...) end")
		end)

		it("should differentiate local and global functions", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local function blah() end")
			check("function blah() end")
			check("function a.b.c(arg) end")
		end)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bde</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4FEE8F68656943079C6E0192BC3CC0F4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">stripAst.spec</string>
						<string name="ScriptGuid">{59D109C4-6327-4D3A-B0C0-B030A04FE977}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local stripAst = require(script.Parent.stripAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	local printAst = require(script.Parent.printAst)
	
	local function doStrip(str)
		local ast = parse(tokenize(str))
		stripAst(ast)
		return printAst(ast)
	end
	
	describe("special cases", function()
		it("should not join `..` and `.5`", function()
			local str = doStrip[[local a = "a" .. .5]]
			expect(str).to.equal[[local a="a".. .5]]
		end)
		
		it("should not join things into a comment", function()
			local str = doStrip[[local a = 5 - -5]]
			expect(str).to.equal[[local a=5- -5]]
		end)
	end)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032bdf</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBXA873D856F9AC45E68E0E28AA44FBF0D8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestParse</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{A5D82D09-8B9D-4296-92B1-26D796A520E8}</string>
					<ProtectedString name="Source"><![CDATA[local tokenizeFunction = require(script.Parent.LuaSyntaxToolset.tokenize)
local parseFunction = require(script.Parent.LuaSyntaxToolset.parse)

local testSource = [[
local Selection = game:GetService('Selection')

local PluginFolder = script.Parent.Parent
local PluginModules = require(PluginFolder.Modules)

local ScriptUtility = PluginModules.Utility.ScriptUtility

local SystemsContainer = {}

-- // Module // --
local Module = {}

Module.WidgetMaid = PluginModules.Classes.Maid.New()
Module.Visible = false
Module.DockWidget = false

function Module:ParseSelection()

	local whitelistClassName = {'LocalScript', 'Script', 'ModuleScript'}
	local ScriptInstances = Selection:Get()
	for _, scriptInstance in ipairs( ScriptInstances ) do
		if table.find(whitelistClassName, scriptInstance.ClassName) then
			ScriptUtility:RawParse( scriptInstance )
		end
	end

end

function Module:Show()
	if Module.Visible then
		return
	end
	Module.Visible = true
	Module.DockWidget.Enabled = true
	print(script.Name, 'Show')
end

function Module:Hide()
	if not Module.Visible then
		return
	end
	Module.Visible = false
	Module.DockWidget.Enabled = false
	print(script.Name, 'Hide')
	self.WidgetMaid:Cleanup()
end

function Module:Toggle()
	if Module.Visible then
		Module:Hide()
	else
		Module:Show()
	end
end

function Module:Destroy()
	print(script.Name, 'Destroy')
end

function Module:Init(otherSystems, plugin)
	SystemsContainer = otherSystems

	local dockWidgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		false, true,
		250, 150, 50, 30
	)

	Module.DockWidget = plugin:CreateDockWidgetPluginGui(script.Name, dockWidgetInfo)
	Module.DockWidget.Title = script.Name
	Module.DockWidget.Enabled = false
end

return Module
]]

local result = tokenizeFunction(testSource)
print(result)

print(parseFunction(result))
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032c35</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX7A912C7CEADF47978B83157CBA5D3E83">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">ParseToNodeForm</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5c33de30e8b23bd60301373a001b3c88</UniqueId>
			</Properties>
			<Item class="Script" referent="RBXCDB9FB2DF82742A0AEAFF738C557AC12">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestData</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{BC2F7845-9B61-4693-ABC3-946663AED506}</string>
					<ProtectedString name="Source"><![CDATA[warn('Character visuals - masks / gun skins / perks / etc')
local Players = game:GetService('Players')
local Teams = game:GetService('Teams')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ReplicatedAssets = ReplicatedStorage:WaitForChild('Assets')
local ReplicatedCore = require(ReplicatedStorage:WaitForChild('Core'))
local ReplicatedModules = require(ReplicatedStorage:WaitForChild('Modules'))
local ReplicatedData = ReplicatedCore.ReplicatedData
local ItemsModule = ReplicatedModules.Defined.Items
local SystemsContainer = {}
local CharacterCache = {}
local Module = {}

function Module:RenderUpdate()
	local renderData = ReplicatedData:GetData('RenderData')
	-- print(renderData)
	if typeof(renderData) ~= 'table' then
		return
	end

	for playerName, accessoryData in pairs(renderData) do
		local PlayerInstance = Players:FindFirstChild(playerName)
		if (not PlayerInstance) or PlayerInstance.Team == Teams.Props then
			continue
		end

		local CharacterInstance = workspace:FindFirstChild(playerName)
		local HeadInstance = CharacterInstance and CharacterInstance:FindFirstChild('Head')
		if (not CharacterInstance) or (not HeadInstance) then
			continue
		end

		if not CharacterCache[PlayerInstance] then
			CharacterCache[PlayerInstance] = { }
		end

		-- print(CharacterInstance:GetFullName(), accessoryData)

		-- remove all old accessories that are not equipped
		for accessoryID, accessoryInstance in pairs( CharacterCache[PlayerInstance] ) do
			if not table.find(accessoryData, accessoryID) then
				accessoryInstance:Destroy()
				CharacterCache[PlayerInstance][accessoryID] = nil
			end
		end

		-- equip new accessories and skip those that are equipped
		for _, accessoryID in ipairs( accessoryData ) do
			local accessoryConfig = ItemsModule:GetConfigFromID( accessoryID )
			if not accessoryConfig then
				warn('Cannot find the accessory config for ID ', accessoryID)
				continue
			end

			if not accessoryConfig.Model then
				warn('No model set for accessory of ID ', accessoryID)
				continue
			end

			local ModelInstance = ReplicatedAssets.Masks:FindFirstChild(accessoryConfig.Model)
			if not ModelInstance then
				warn('Could not find accessory instance named ', accessoryConfig.Model)
				continue
			end

			-- print(ModelInstance:GetFullName())

			ModelInstance = ModelInstance:Clone()
			ModelInstance:SetPrimaryPartCFrame( HeadInstance.CFrame )
			ReplicatedModules.Utility.Models:WeldConstraint( ModelInstance.PrimaryPart, HeadInstance )
			ModelInstance.Parent = CharacterInstance

			CharacterCache[PlayerInstance][accessoryID] = ModelInstance
		end
	end
end

function Module:Init( otherSystems )
	SystemsContainer = otherSystems

	task.defer(function()
		Module:RenderUpdate()
	end)

	workspace.ChildAdded:Connect(function(childInstance)
		if Players:FindFirstChild(childInstance.Name) then
			task.wait(0.1)
			Module:RenderUpdate()
		end
	end)

	workspace.ChildRemoved:Connect(function(childInstance)
		if Players:FindFirstChild(childInstance.Name) then
			Module:RenderUpdate()
		end
	end)

	ReplicatedData.OnUpdate:Connect(function(Category, _)
		if Category == 'PlayerData' then
			Module:RenderUpdate()
		end
	end)
end

return Module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0005395e</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX576C575324304E698EEE417BFFCE657F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Data</string>
					<string name="ScriptGuid">{8DCE85F3-4842-4F4E-B6FF-2050B53C8546}</string>
					<ProtectedString name="Source"><![CDATA[return {
	["GetFirstToken"] = "function",
	["GetLastToken"] = "function",
	["SemicolonList"] = {},
	["StatementList"] =  {
		[1] =  {
			["Expression"] =  {
				["Base"] =  {
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token"] =  {
						["LeadingWhite"] = "",
						["Source"] = "warn",
						["Type"] = "Ident"
					},
					["Type"] = "VariableExpr"
				},
				["FunctionArguments"] =  {
					["ArgList"] =  {
						[1] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Token"] =  {
								["LeadingWhite"] = "",
								["Source"] = "'Character visuals - masks / gun skins / perks / etc'",
								["Type"] = "String"
							},
							["Type"] = "StringLiteral"
						}
					},
					["CallType"] = "ArgCall",
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseParen"] =  {
						["LeadingWhite"] = "",
						["Source"] = ")",
						["Type"] = "Symbol"
					},
					["Token_CommaList"] = {},
					["Token_OpenParen"] =  {
						["LeadingWhite"] = "",
						["Source"] = "(",
						["Type"] = "Symbol"
					}
				},
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["Type"] = "CallExpr"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Type"] = "CallExprStat"
		},
		[2] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Players'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Players",
					["Type"] = "Ident"
				}
			}
		},
		[3] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Teams'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Teams",
					["Type"] = "Ident"
				}
			}
		},
		[4] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'ReplicatedStorage'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedStorage",
					["Type"] = "Ident"
				}
			}
		},
		[5] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "ReplicatedStorage",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Assets'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "WaitForChild",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedAssets",
					["Type"] = "Ident"
				}
			}
		},
		[6] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "require",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedStorage",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "WaitForChild",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Type"] = "CallExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedCore",
					["Type"] = "Ident"
				}
			}
		},
		[7] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "require",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedStorage",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "WaitForChild",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Type"] = "CallExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedModules",
					["Type"] = "Ident"
				}
			}
		},
		[8] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "ReplicatedCore",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["Field"] =  {
						["LeadingWhite"] = "",
						["Source"] = "ReplicatedData",
						["Type"] = "Ident"
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_Dot"] =  {
						["LeadingWhite"] = "",
						["Source"] = ".",
						["Type"] = "Symbol"
					},
					["Type"] = "FieldExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedData",
					["Type"] = "Ident"
				}
			}
		},
		[9] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["Base"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Token"] =  {
								["LeadingWhite"] = " ",
								["Source"] = "ReplicatedModules",
								["Type"] = "Ident"
							},
							["Type"] = "VariableExpr"
						},
						["Field"] =  {
							["LeadingWhite"] = "",
							["Source"] = "Defined",
							["Type"] = "Ident"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Dot"] =  {
							["LeadingWhite"] = "",
							["Source"] = ".",
							["Type"] = "Symbol"
						},
						["Type"] = "FieldExpr"
					},
					["Field"] =  {
						["LeadingWhite"] = "",
						["Source"] = "Items",
						["Type"] = "Ident"
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_Dot"] =  {
						["LeadingWhite"] = "",
						["Source"] = ".",
						["Type"] = "Symbol"
					},
					["Type"] = "FieldExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ItemsModule",
					["Type"] = "Ident"
				}
			}
		},
		[10] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "SystemsContainer",
					["Type"] = "Ident"
				}
			}
		},
		[11] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "CharacterCache",
					["Type"] = "Ident"
				}
			}
		},
		[12] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				}
			}
		},
		[13] =  {
			["ArgList"] = {},
			["ArgTypeList"] = {},
			["Body"] =  {
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["SemicolonList"] = {},
				["StatementList"] =  {
					[1] =  {
						["ExprList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "ReplicatedData",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "GetData",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Equals"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "=",
							["Type"] = "Symbol"
						},
						["Token_ExprCommaList"] = {},
						["Token_Local"] =  {
							["LeadingWhite"] = "",
							["Source"] = "local",
							["Type"] = "Keyword"
						},
						["Token_VarColonList"] = {},
						["Token_VarCommaList"] = {},
						["Type"] = "LocalVarStat",
						["TypeList"] = {},
						["VarList"] =  {
							[1] =  {
								["LeadingWhite"] = " ",
								["Source"] = "renderData",
								["Type"] = "Ident"
							}
						}
					},
					[2] =  {
						["Body"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["SemicolonList"] = {},
							["StatementList"] =  {
								[1] =  {
									["ExprList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CommaList"] = {},
									["Token_Return"] =  {
										["LeadingWhite"] = "",
										["Source"] = "return",
										["Type"] = "Keyword"
									},
									["Type"] = "ReturnStat"
								}
							},
							["Type"] = "StatList"
						},
						["Condition"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Lhs"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "typeof",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Type"] = "CallExpr"
							},
							["Rhs"] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = " ",
									["Source"] = "'table'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							},
							["Token_Op"] =  {
								["LeadingWhite"] = " ",
								["Source"] = "~=",
								["Type"] = "Symbol"
							},
							["Type"] = "BinopExpr"
						},
						["ElseClauseList"] = {},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_End"] =  {
							["LeadingWhite"] = "",
							["Source"] = "end",
							["Type"] = "Keyword"
						},
						["Token_If"] =  {
							["LeadingWhite"] = "",
							["Source"] = "if",
							["Type"] = "Keyword"
						},
						["Token_Then"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "then",
							["Type"] = "Keyword"
						},
						["Type"] = "IfStat"
					},
					[3] =  {
						["Body"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["SemicolonList"] = {},
							["StatementList"] =  {
								[1] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[2] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Lhs"] = table,
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "BinopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[3] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[4] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[5] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Lhs"] = table,
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "BinopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[6] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "UnopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[7] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["GeneratorList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Do"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "do",
										["Type"] = "Keyword"
									},
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_For"] =  {
										["LeadingWhite"] = "",
										["Source"] = "for",
										["Type"] = "Keyword"
									},
									["Token_GeneratorCommaList"] = {},
									["Token_In"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "in",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] =  {
										[1] = table
									},
									["Type"] = "GenericForStat",
									["VarList"] =  {
										[1] = table,
										[2] = table
									},
									["VarTypeList"] = {}
								},
								[8] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["GeneratorList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Do"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "do",
										["Type"] = "Keyword"
									},
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_For"] =  {
										["LeadingWhite"] = "",
										["Source"] = "for",
										["Type"] = "Keyword"
									},
									["Token_GeneratorCommaList"] = {},
									["Token_In"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "in",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] =  {
										[1] = table
									},
									["Type"] = "GenericForStat",
									["VarList"] =  {
										[1] = table,
										[2] = table
									},
									["VarTypeList"] = {}
								}
							},
							["Type"] = "StatList"
						},
						["GeneratorList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "pairs",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Type"] = "CallExpr"
							}
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Do"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "do",
							["Type"] = "Keyword"
						},
						["Token_End"] =  {
							["LeadingWhite"] = "",
							["Source"] = "end",
							["Type"] = "Keyword"
						},
						["Token_For"] =  {
							["LeadingWhite"] = "",
							["Source"] = "for",
							["Type"] = "Keyword"
						},
						["Token_GeneratorCommaList"] = {},
						["Token_In"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "in",
							["Type"] = "Keyword"
						},
						["Token_VarColonList"] = {},
						["Token_VarCommaList"] =  {
							[1] =  {
								["LeadingWhite"] = "",
								["Source"] = ",",
								["Type"] = "Symbol"
							}
						},
						["Type"] = "GenericForStat",
						["VarList"] =  {
							[1] =  {
								["LeadingWhite"] = " ",
								["Source"] = "playerName",
								["Type"] = "Ident"
							},
							[2] =  {
								["LeadingWhite"] = " ",
								["Source"] = "accessoryData",
								["Type"] = "Ident"
							}
						},
						["VarTypeList"] = {}
					}
				},
				["Type"] = "StatList"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["NameChain"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				},
				[2] =  {
					["LeadingWhite"] = "",
					["Source"] = "RenderUpdate",
					["Type"] = "Ident"
				}
			},
			["Token_ArgColonList"] = {},
			["Token_ArgCommaList"] = {},
			["Token_CloseParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = ")",
				["Type"] = "Symbol"
			},
			["Token_End"] =  {
				["LeadingWhite"] = "",
				["Source"] = "end",
				["Type"] = "Keyword"
			},
			["Token_Function"] =  {
				["LeadingWhite"] = "",
				["Source"] = "function",
				["Type"] = "Keyword"
			},
			["Token_NameChainSeparator"] =  {
				[1] =  {
					["LeadingWhite"] = "",
					["Source"] = ":",
					["Type"] = "Symbol"
				}
			},
			["Token_OpenParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = "(",
				["Type"] = "Symbol"
			},
			["Type"] = "FunctionStat"
		},
		[14] =  {
			["ArgList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "otherSystems",
					["Type"] = "Ident"
				}
			},
			["ArgTypeList"] = {},
			["Body"] =  {
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["SemicolonList"] = {},
				["StatementList"] =  {
					[1] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Lhs"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "SystemsContainer",
									["Type"] = "Ident"
								},
								["Type"] = "VariableExpr"
							}
						},
						["Rhs"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = " ",
									["Source"] = "otherSystems",
									["Type"] = "Ident"
								},
								["Type"] = "VariableExpr"
							}
						},
						["Token_Equals"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "=",
							["Type"] = "Symbol"
						},
						["Token_LhsSeparatorList"] = {},
						["Token_RhsSeparatorList"] = {},
						["Type"] = "AssignmentStat"
					},
					[2] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "task",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "defer",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Type"] = "CallExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[3] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "workspace",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "ChildAdded",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[4] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "workspace",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "ChildRemoved",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[5] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedData",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "OnUpdate",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					}
				},
				["Type"] = "StatList"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["NameChain"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				},
				[2] =  {
					["LeadingWhite"] = "",
					["Source"] = "Init",
					["Type"] = "Ident"
				}
			},
			["Token_ArgColonList"] = {},
			["Token_ArgCommaList"] = {},
			["Token_CloseParen"] =  {
				["LeadingWhite"] = " ",
				["Source"] = ")",
				["Type"] = "Symbol"
			},
			["Token_End"] =  {
				["LeadingWhite"] = "",
				["Source"] = "end",
				["Type"] = "Keyword"
			},
			["Token_Function"] =  {
				["LeadingWhite"] = "",
				["Source"] = "function",
				["Type"] = "Keyword"
			},
			["Token_NameChainSeparator"] =  {
				[1] =  {
					["LeadingWhite"] = "",
					["Source"] = ":",
					["Type"] = "Symbol"
				}
			},
			["Token_OpenParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = "(",
				["Type"] = "Symbol"
			},
			["Type"] = "FunctionStat"
		},
		[15] =  {
			["ExprList"] =  {
				[1] =  {
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "Module",
						["Type"] = "Ident"
					},
					["Type"] = "VariableExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_CommaList"] = {},
			["Token_Return"] =  {
				["LeadingWhite"] = "",
				["Source"] = "return",
				["Type"] = "Keyword"
			},
			["Type"] = "ReturnStat"
		}
	},
	["Type"] = "StatList"
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00053d11</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX19A568325EE24431B65BF13F2375E5B0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestDiagramNodes</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{03ADE7C4-1C90-49AD-9903-0893DAE20C01}</string>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService('HttpService')

local SampleData = require(script.Parent.Data)

local ScopeConnectionMap = {}
local ScopeRegistries = {}

local SkipTypeList = {'ReturnStat', 'GenericForStat', 'IfStat', 'AssignmentStat 1'}

local ParseHandlers = {
	LocalVarStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.SetVariableNodes, {statementIndex, data.Type, data, depth})
	end,
	FunctionStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CreateFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
	CallExprStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CallFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
}

function ParseStatementList(parentRegistryUUID, StatementList, depth)
	print('Step Depth; ', depth or 0)
	
	local currentRegistryUUID = HttpService:GenerateGUID(false)
	if ScopeConnectionMap[parentRegistryUUID] then
		table.insert(ScopeConnectionMap[parentRegistryUUID], currentRegistryUUID)
	else
		ScopeConnectionMap[parentRegistryUUID] = {currentRegistryUUID}
	end
	
	local scopeReg = {
		Depth = depth,
		SetVariableNodes = { },
		CreateFunctionNodes = { },
		CallFunctionNodes = { },
	}
	
	ScopeRegistries[currentRegistryUUID] = scopeReg
	
	for statementIndex, data in pairs( StatementList ) do
		local parsed = true
		if ParseHandlers[data.Type] then
			print('Parsed ; ', statementIndex, data.Type)
			ParseHandlers[data.Type](scopeReg, statementIndex, data, depth or 0)
		elseif table.find(SkipTypeList, data.Type) then
			print('Skipped ; ', data.Type, statementIndex)
			continue
		else
			parsed = false
		end
		if data.Body and data.Body.StatementList then
			parsed = true
			local _ = ParseStatementList(currentRegistryUUID, data.Body.StatementList, (depth or 0) + 1)
		end
		if not parsed then
			warn('Unsupported Type ; ', data.Type, statementIndex)
		end
	end

	return scopeReg
end

ParseStatementList(false, SampleData.StatementList) -- ModuleScript parse [Type : StatList]

print(ScopeConnectionMap)
local baseRegistryString = 'REGISTRY %s DEPTH %d || CALL FUNCTIONS (%d), CREATE FUNCTIONS (%d), SET VARIABLE (%d)'
for registryUUID, data in pairs( ScopeRegistries ) do
	print( string.format(baseRegistryString, registryUUID, data.Depth or 0, #data.CallFunctionNodes, #data.CreateFunctionNodes, #data.SetVariableNodes) )
end

print(string.rep('\n', 10))

for registryID, registryData in pairs(ScopeRegistries) do
	print('==== ', registryID, ' ====')
	for _, SetVariableNode in ipairs( registryData.SetVariableNodes ) do
		local statementIndex, dataType, data, depth = unpack(SetVariableNode)
		print('SET VARIABLE ; ', statementIndex, dataType, data.VarList[1].Source, depth)
	end
	for _, CreateFunctionNode in ipairs( registryData.CreateFunctionNodes ) do
		local statementIndex, dataType, data, depth = unpack(CreateFunctionNode)
		print('CREATE FUNCTION ; ', statementIndex, dataType, data.NameChain[#data.NameChain].Source, depth)
	end
	for _, functionCallNode in ipairs( registryData.CallFunctionNodes ) do
		local statementIndex, dataType, data, depth = unpack(functionCallNode)
		print('CALL FUNCTION ; ', statementIndex, dataType, depth)
	end
end


]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00053da5</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX85EC805AA1E043DFA84651589E1E30BB">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70b7</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX8BEAA3C6610D4C6DA4EC61528040A531">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">50250e3257db262a030774450002228a</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX8D58D7AE1F684D7090FD759CE6475E1B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70c3</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXDD1E0FC05AEE40E1948F43D7B30CEF81">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70c4</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXE14EC4E35E18433FB5A5E38464503511">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70c9</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXD49A64E9971A4E5F813C7FAB51787BE4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ca</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXA6C25549AE4F4C9FA4DDC8ABEE858E19">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">56832</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70cc</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBXDC32B81251FD4E1CBBC3B9114CE8D529">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70d0</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX799731BA04DC41D69672A02EABDCEC9E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70d2</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX4B7B87F2D8C54E62BF52CA3E982722C0">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70d3</UniqueId>
			<bool name="Use2022MaterialsXml">true</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX0FF1E40AA37040E49FFB458FC4C73E61">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00021ddd</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX1EC6764DC40D4F048048111B9AE04F26">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00021fe4</UniqueId>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX625DDDE96B6845DDAF58C8CE4C52B877">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatInputBarConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00021fe5</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX37305BAA0D604346A6A1597FE9D4F273">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70d7</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX4C46FBC4A4D3491B93C086FABF994FFD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode">US</string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70d9</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX0AB4B3AB246E4B4FBA1888CB1C14E1CF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70dc</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBX8D5568EAA7624762833A7DA15278CFB5">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">128</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70dd</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX130E6415790A481CAB769D4EF9743FB9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7261</UniqueId>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX1B5822F1131E4D1299F138B16D1C6999">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7260</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXE9F3F714746F43448EA05F8EA1BDDD72">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70de</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX1F9B609408444EE398E60110FD7310A6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70df</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX2780BF6806B84476B0FD1ECE99B19B9F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70e1</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX87D5C0857F3E492BA512A61EF798E8AE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70e5</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX1CAAB42F7B8F4B30AE899827FCB88598">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70e7</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXB532A9D07CFF41F080A2528D70F23977">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70e8</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX3224CBADBDE64F5D886B3A2862AA6B80">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ea</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXE50329C0D182412AA697E3F387CB63D9">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ec</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX38EE53E1BACD4E3C957A687230B7459A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7262</UniqueId>
				<string name="Value">{FEB25E56-03C8-4C7E-9E67-941EA2879662}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX8B45611F2B2749F1A14C5FCE23CA762F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ed</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX1A197A43C64C43DDBD89A1A0C7599564">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ee</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX008CFC09A83E4E04AB4C291425EDCF1A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ef</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX6C9251EEB9C7449FAEB6331B490A9829">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70f9</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXF9CCD1B346F14808A6891D7ABC745284">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70fb</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXFEC2219BD09A493BA5C85E53239858A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70fd</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX939EDC81A3304506BA0A6B3D1055A45E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70fe</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX7BC7022D945243618EEB8129441AEE2E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b70ff</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX6C0D7386A2004DCFB0F887EB53D1BD5E">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7102</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBXC5C553309CDB46A8806F71194E8CE42A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7105</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX75216BFEB2214B018C3E958CD89A2A4D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7106</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerStorage" referent="RBX6A15D44F54624FE9980F5A3185F59E4B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7107</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBX3C7E00E49B8A4E8B996A5723489CCBAB">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">BuildScriptArchitectDiagram</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030474</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXE3D46EAA851740FDBBE1A03E138CC9C8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Modules</string>
					<string name="ScriptGuid">{C3EE1985-25FF-4887-9364-FB637D658DDD}</string>
					<ProtectedString name="Source"><![CDATA[local Module = {}

for _, ModuleScript in ipairs( script:GetChildren() ) do
	if ModuleScript:IsA('ModuleScript') then
		Module[ModuleScript.Name] = require(ModuleScript)
	end
end

return Module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030476</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX836695F257CA49EEB09A799A5C25BD43">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Classes</string>
						<string name="ScriptGuid">{D888E1FD-DEE6-4D54-BA08-75A887DE2F28}</string>
						<ProtectedString name="Source"><![CDATA[local Module = {}

for _, ModuleScript in ipairs( script:GetChildren() ) do
	if ModuleScript:IsA('ModuleScript') then
		Module[ModuleScript.Name] = require(ModuleScript)
	end
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030477</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX4C1B1E7BA3BB492C96E0359E41281652">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Event</string>
							<string name="ScriptGuid">{A6270E6B-7D70-497A-BBCB-435B18F0804D}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Example Code : Alternatives To BindableEvents
	(allows Instance passing)

	local newSignal = Signal.New('Signal1')
	print(newSignal, getmetatable(newSignal))

	print(Signal:GetSignal('Signal1'))
	newSignal:HideSignal('Signal1') -- Prevents GetSignal

	newSignal:Connect(function(connection, ...)
		print("Got Callback: ", ...)
	end)

	newSignal:Fire()
	task.spawn(function()
		local t = tick()
		newSignal:Wait(1)
		print( string.format("defered %s/1 second", tick()-t) )
	end)

	newSignal:Fire("e")
	newSignal:Disconnect()
	newSignal:Fire()
]]

-- SPOOK_EXE

local HttpService = game:GetService('HttpService')

local activeSignals = {}

-- // Classes // --
local Callback = {}
Callback.__index = Callback

function Callback.New(SuperSignal, callbackFunction : (any) -> (any))

	return setmetatable({
		ClassName = "BaseSignalCallback",
		Super = setmetatable({}, SuperSignal),
		Active = true,
		ID = HttpService:GenerateGUID(false),
		_function = callbackFunction,
	}, Callback)

end

function Callback:Trigger(...)
	if not self.Active then
		error("Trying to trigger a disconnected callback.")
	end
	self._function(...)
end

function Callback:Disconnect()
	if not self.Active then
		error("Trying to disconnect a disconnected callback.")
	end
	self.Active = false
	if self.Super then
		getmetatable(self.Super):RemoveCallback(Callback)
	end
end

local Signal = {}
Signal.__index = Signal

function Signal.New(customID)
	return setmetatable({
		ClassName = "BaseSignal",
		Active = true,
		ID = customID or HttpService:GenerateGUID(false),
		_callbacks = {},
	}, Signal)
end

function Signal:GetSignal(signalID)
	assert(typeof(signalID) == "string", "Passed signalID is not a string.")
	for _, signal in ipairs(activeSignals) do
		if signal.ID == signalID then
			return signal
		end
	end
	return Signal.New(signalID)
end

function Signal:HideSignal(signalID)
	assert(typeof(signalID) == "string", "Passed signalID is not a string.")
	for i, signal in ipairs(activeSignals) do
		if signal.ID == signalID then
			table.remove(activeSignals, i)
			break
		end
	end
end

function Signal:RemoveCallback(callback)
	for i, callbackClass in ipairs(self._callbacks) do
		if callback.ID == callbackClass.ID then
			table.remove(self._callbacks, i)
			break
		end
	end
end

function Signal:Fire(...)
	if not self.Active then
		error("Trying to fire a disconnected Signal.")
	end
	for _, callbackClass in ipairs(self._callbacks) do
		callbackClass:Trigger(...)
	end
end

function Signal:Wait(timePeriod)
	if not self.Active then
		error("Trying to Wait on a disconnected Signal.")
	end
	timePeriod = typeof(timePeriod) == "number" and timePeriod or nil
	local bindableWait = Instance.new('BindableEvent')
	local callback; callback = self:Connect(function()
		callback:Disconnect()
		bindableWait:Fire()
	end)
	bindableWait.Event:Wait()
	bindableWait:Destroy()
	if timePeriod then
		task.wait(timePeriod)
	end
end

function Signal:Connect(...)
	if not self.Active then
		error("Trying to connect a disconnected Signal.")
	end
	local callbacks = {}
	local passed_arguments = {...}
	for _, passed_arg in ipairs(passed_arguments) do
		if typeof(passed_arg) == "function" then
			local new_callback = Callback.New(self, passed_arg)
			table.insert(self._callbacks, new_callback)
			table.insert(callbacks, new_callback)
		end
	end
	return unpack(callbacks)
end

function Signal:Disconnect()
	if not self.Active then
		error("Trying to disconnect a disconnected Signal.")
	end
	self.Active = false
	self:HideSignal(self.ID)
	self.Callbacks = nil
	setmetatable(self, {
		__index = function(_, _)
			return nil
		end,
		__newindex = function(_, _, _)
			error("Cannot edit locked metatable.")
		end,
	})
end

return Signal

-- SPOOK_EXE]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030478</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB884E3A637DC465EB0CBE1D9D0C7AAE4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Maid</string>
							<string name="ScriptGuid">{4E098B81-0AEC-4BAE-ABB3-EDB198A1D7BF}</string>
							<ProtectedString name="Source"><![CDATA[
local cleanupMethods = {
	['Instance'] = function(Task)
		Task:Destroy()
	end,
	['RBXConnection'] = function(Task)
		Task:Disconnect()
	end,
	['table'] = function(Task)
		if typeof(Task.Destroy) == 'function' then
			Task:Destroy()
		end
	end
}

-- // Class // --
local Class = {}
Class.__index = Class

function Class.New()
	return setmetatable({ _tasks = {} }, Class)
end

function Class:Give(...)
	for _, Task in ipairs( {...} ) do
		if cleanupMethods[typeof(Task)] and (not table.find(self._tasks, Task)) then
			table.insert(self._tasks, Task)
		end
	end
end

function Class:Cleanup()
	for _, Task in ipairs( self._tasks ) do
		local taskType = typeof(Task)
		local func = cleanupMethods[taskType]
		if func then
			task.defer(func, Task)
		else
			warn('Could not find cleanup function for type; ', taskType)
		end
	end
end

return Class]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030479</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1C0581ADBC344C03898B16D1AD9F6DB5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Promise</string>
							<string name="ScriptGuid">{5A332919-F703-41C9-A5BD-A92D6D3CF71F}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047a</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9429C94540194A82A8B4F988EC5B94BD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NodeTree</string>
							<string name="ScriptGuid">{ED0DB7C1-00C0-4DF8-8CCA-42E958F611EA}</string>
							<ProtectedString name="Source"><![CDATA[
local HttpService = game:GetService('HttpService')

local function setProperties(thisTable, toThis)
	for k,v in pairs(thisTable) do
		toThis[k] = v
	end
	return toThis
end

-- // NODE // --
local Node = {}
Node.__index = Node

function Node.New(nodeID)
	return setmetatable({
		x = 0,
		y = 0,
		layerZ = 0, -- what column they are in
		radius = 35,

		ID = nodeID or HttpService:GenerateGUID(false),
		depends = {},
		orderNumber = 0, -- set automatically to make room for lines
		node_data = false,
	}, Node)
end

function Node:LoadDepends(dependsTable)
	for _, str in ipairs( dependsTable ) do
		table.insert(self.depends, str)
	end
end

function Node:SetPosition(nX : number, nY : number)
	self.x = nX
	self.y = nY
end

function Node:SetLayer(nLayer : number)
	self.layerZ = nLayer
end

function Node:SetData(node_data)
	self.node_data = node_data
end

-- // TREE CLASS // --
local TreeData = {}
TreeData.__index = TreeData

function TreeData.New()
	return setmetatable({
		name = "Unknown",
		visible = false,
		nodes = {},
		IDToNode = {},
		LayerZToNodeArray = {},

		widthSeparation = 100,
		windowHeight = 500,
	}, TreeData)
end

--[[
	{
		{ ID = 'blah2', Depends = {}, Layer = 1 },
		{ ID = 'blah', Depends = {'blah2'}, Layer = 2 },
	}
]]

function TreeData:GetNodeFromID(nodeID)
	return self.IDToNode[nodeID]
end

function TreeData:LoadNodes( nodesTable )
	-- add all nodes
	for _, nodeData in ipairs( nodesTable ) do
		local layerZArray = self.LayerZToNodeArray[nodeData.Layer]
		if not layerZArray then
			layerZArray = {}
			self.LayerZToNodeArray[nodeData.Layer] = layerZArray
		end

		local newNode = Node.New(nodeData.ID)
		newNode:SetLayer(nodeData.Layer)
		newNode:LoadDepends( nodeData.Depends )
		table.insert(self.nodes, newNode) -- array
		self.IDToNode[nodeData.ID] = newNode -- hashmap
		table.insert(layerZArray, newNode) -- layer array
	end

	-- check duplicate dependancies (recursive)
	for layerNumber, layerNodes in pairs(self.LayerZToNodeArray) do
		local layerCount = #layerNodes
		local deltaCount = (1 / layerCount);
		local deltaStep = (self.windowHeight * 0.5) * deltaCount;
		local topHeight = ((self.windowHeight * 0.5) - ( (layerCount / 2) * deltaStep ));
		for nodeIndex, node in ipairs( layerNodes ) do
			local nodeY = topHeight + (deltaStep * nodeIndex)
			local nodeX = layerNumber * self.widthSeparation
			node:SetPosition( nodeX, nodeY );
		end
	end
end

--[[
	function TreeData:ShowTree()
		public void draw() {
			// Show connection lines
			stroke(255);
			fill(255);
			for (int i = 0; i < nodes.length; i++) {
				Node baseNode = nodes[i];
				for (String dependID : baseNode.depends) {
					Node dependedNode = IDToNode.get(dependID);
					// If node is null, then the depended node is not within this tree.
					if (dependedNode == null) {
						printOnce("[WARN] Depended ID has no node in the tree! " + baseNode.ID + " depending on " + dependID);
						continue;
					}
					// Create line to link the dependant ones
					noFill();
					bezierLine( baseNode.x, baseNode.y, dependedNode.x, dependedNode.y, widthSeparation);
					fill(255);
				}
			}
			// Show nodes
			for (int i = 0; i < nodes.length; i++) {
				nodes[i].show();
			}
		}
	end
]]

return { Node = Node, TreeData = TreeData }
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">310dd1710dcb8bab030416e9000307a0</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6CC166242E1C472584C68C38BCC3E7C4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScriptENVParser</string>
							<string name="ScriptGuid">{158CADA1-F5F2-4998-9346-24EC78269B55}</string>
							<ProtectedString name="Source"><![CDATA[
local HttpService = game:GetService('HttpService')

local SkipTypeList = {'ReturnStat', 'GenericForStat', 'IfStat', 'AssignmentStat 1'}

local ParseHandlers = {
	LocalVarStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.SetVariableNodes, {statementIndex, data.Type, data, depth})
	end,
	FunctionStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CreateFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
	CallExprStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CallFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
}

-- // Class // --
local Class = {}
Class.__index = Class

function Class.New()
	return setmetatable({
		LastParse = 0,
		RootScopeRegistry = false,
		ScopeConnectionMap = {},
		ScopeRegistries = {},
	}, Class)
end

function Class:Reset()
	print('Reset Script Parser')
	self.ScopeConnectionMap = {}
	self.ScopeRegistries = {}
	self.LastParse = 0
end

function Class:ParseStatementList(parentRegistryUUID, StatementList, depth)
	print('ParentID: ', parentRegistryUUID)
	print('Step Depth; ', depth or 0)

	local currentRegistryUUID = HttpService:GenerateGUID(false)

	local scopeReg = {
		ParentScopeUUID = parentRegistryUUID,
		ScopeID = currentRegistryUUID,
		ChildScopesIDs = {},
		SetVariableNodes = {},
		CreateFunctionNodes = {},
		CallFunctionNodes = {},
		Depth = depth,
	}

	if self.ScopeConnectionMap[parentRegistryUUID] then
		table.insert(self.ScopeConnectionMap[parentRegistryUUID], currentRegistryUUID)
	else
		self.ScopeConnectionMap[parentRegistryUUID] = {currentRegistryUUID}
	end

	self.ScopeRegistries[currentRegistryUUID] = scopeReg

	for statementIndex, data in pairs( StatementList ) do
		local parsed = true
		if ParseHandlers[data.Type] then
			print('Parsed ; ', statementIndex, data.Type)
			ParseHandlers[data.Type](scopeReg, statementIndex, data, depth or 0)
		elseif table.find(SkipTypeList, data.Type) then
			print('Skipped ; ', data.Type, statementIndex)
			continue
		else
			parsed = false
		end
		if data.Body and data.Body.StatementList then
			parsed = true
			local envRegistryTable = self:ParseStatementList(currentRegistryUUID, data.Body.StatementList, (depth or 0) + 1)
			table.insert(scopeReg.ChildScopesIDs, envRegistryTable.ScopeID)
		end
		if not parsed then
			warn('Unsupported Type ; ', data.Type, statementIndex)
		end
	end

	return scopeReg
end

function Class:OutputParse()
	print(self.ScopeConnectionMap)
	local baseRegistryString = 'REGISTRY %s DEPTH %d || CALL FUNCTIONS (%d), CREATE FUNCTIONS (%d), SET VARIABLE (%d)'
	for registryUUID, data in pairs( self.ScopeRegistries ) do
		print( string.format(baseRegistryString, registryUUID, data.Depth or 0, #data.CallFunctionNodes, #data.CreateFunctionNodes, #data.SetVariableNodes) )
	end
	print(string.rep('\n', 2))
	for registryID, registryData in pairs(self.ScopeRegistries) do
		print('==== ', registryID, ' ====')
		for _, SetVariableNode in ipairs( registryData.SetVariableNodes ) do
			local statementIndex, dataType, data, depth = unpack(SetVariableNode)
			print('SET VARIABLE ; ', statementIndex, dataType, data.VarList[1].Source, depth)
		end
		for _, CreateFunctionNode in ipairs( registryData.CreateFunctionNodes ) do
			local statementIndex, dataType, data, depth = unpack(CreateFunctionNode)
			print('CREATE FUNCTION ; ', statementIndex, dataType, data.NameChain[#data.NameChain].Source, depth)
		end
		for _, functionCallNode in ipairs( registryData.CallFunctionNodes ) do
			local statementIndex, dataType, data, depth = unpack(functionCallNode)
			print('CALL FUNCTION ; ', statementIndex, dataType, depth)
		end
	end
end

function Class:ParseTokens(tokenDictionary)
	self:Reset()
	local rootEnvDictionary = self:ParseStatementList(false, tokenDictionary.StatementList, false)
	self.RootScopeRegistry = rootEnvDictionary
	return rootEnvDictionary
end

--[[
	-- Create one node tree that links scripts together in one large diagram
	function Module:ConstructLargeNodeTree(parseResult)
		print('Construct Large Tree ; ', parseResult)
	end

	-- Create node trees for each script separately (no linking between scripts in one large diagram)
	function Module:ConstructPerScriptNodeTrees(parseResult)
		print(parseResult)
		local newNodeTree = NodeTreeContainer.TreeData.New()
		local nodesArray = {}

		--	{
		--		{ ID = 'blah2', Depends = {}, Layer = 1 },
		--		{ ID = 'blah', Depends = {'blah2'}, Layer = 2 },
		--	}

		for _, t in ipairs( parseResult ) do
			local scriptFullName, envParserClass = unpack(t)
			print('==== ', scriptFullName, ' ====')
			envParserClass:OutputParse() -- DEBUG
			break
		end

		newNodeTree:LoadNodes( nodesArray )

		return newNodeTree
	end
]]

return Class]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">310dd1710dcb8bab030416e9000307a2</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1A25227E26C4409E82877A44BE8FE981">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Utility</string>
						<string name="ScriptGuid">{003CBDCF-4E29-4D8D-9AC6-2ABFCE7F3F40}</string>
						<ProtectedString name="Source"><![CDATA[local Module = {}

for _, ModuleScript in ipairs( script:GetChildren() ) do
	if ModuleScript:IsA('ModuleScript') then
		Module[ModuleScript.Name] = require(ModuleScript)
	end
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047b</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX13B6E418D44E49E59F9CB274480EC728">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Debounce</string>
							<string name="ScriptGuid">{CBE095A7-B35E-4D38-9355-87AEBA0CDA27}</string>
							<ProtectedString name="Source"><![CDATA[
local debounceCache = {}

-- // Module // --
local Module = {}

function Module:Debounce(debounceName : string, duration : number?)
	duration = typeof(duration) == 'number' and duration or 1
	if typeof(debounceName) == 'string' then
		if debounceCache[debounceName] then
			return false
		end
		debounceCache[debounceName] = true
		task.delay(duration, function()
			debounceCache[debounceName] = nil
		end)
		return true
	end
	return false
end

function Module:__call(_, ...)
	return Module:Debounce(...)
end
setmetatable(Module, Module)

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047c</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX31EE20E6C8A54B68AE99921A3F94AB6D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Models</string>
							<string name="ScriptGuid">{480FBE8D-A9AF-4E2C-A350-CFEEDE950887}</string>
							<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService('TweenService')

-- // Module // --
local Module = {}

function Module:ScaleModel(Model, scale)
	local primary = Model and Model.PrimaryPart
	if not primary then
		error("No Primary Part set on model ".. (Model and Model:GetFullName() or "No Model"))
	end
	local primaryCF = primary.CFrame
	for _, v in ipairs(Model:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Size *= scale
			if v == primary then
				continue
			end
			v.CFrame = (primaryCF + (primaryCF:Inverse() * v.Position * scale))
		end
	end
end

function Module:WeldConstraint(WeldMe, ToThis)
	local constraint = Instance.new('WeldConstraint')
	constraint.Name = 'WeldConstraintInstance'
	constraint.Part0 = WeldMe
	constraint.Part1 = ToThis
	constraint.Parent = ToThis
	return constraint
end

local tweenCache = {}
function Module:TweenModel(Model, endCFrame, tweenInfo, Yield)
	local cfValue = Instance.new('CFrameValue')
	cfValue.Name = Model:GetFullName()
	cfValue.Value = Model:GetPrimaryPartCFrame()
	cfValue.Changed:Connect(function()
		Model:SetPrimaryPartCFrame(cfValue.Value)
	end)
	cfValue.Parent = script

	local Tween = tweenCache[Model]
	if Tween then
		Tween:Cancel()
		tweenCache[Model] = nil
	end

	Tween = TweenService:Create(cfValue, tweenInfo or TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Value = endCFrame})

	Tween.Completed:Connect(function()
		if tweenCache[Model] == Tween then
			tweenCache[Model] = nil
		end
		cfValue:Destroy()
	end)

	Tween:Play()

	if Yield then
		Tween.Completed:Wait()
	end
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047d</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX77D3F3A683784554A49ACC794DB701D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Numbers</string>
							<string name="ScriptGuid">{91FA4557-103E-4379-B619-D2F7784AA4A8}</string>
							<ProtectedString name="Source"><![CDATA[local Module = {}

-- from number A to B with alpha t (0 -> 1)
function Module:LinearInterpolation(v0, v1, t)
	return (1 - t) * v0 + t * v1
end

-- Processing equilivant of map(number, oldMinA, oldMaxB, newMinA, newMaxB)
function Module:MapValue(n, start, stop, newStart, newStop)
	return ((n - start) / (stop - start)) * (newStop - newStart) + newStart
end

-- Returns the % value of the decimal (0 -> 1) (000.00)
function Module:FormatPercent(decimal)
	return string.format("%3.2f", decimal * 100) .. "%"
end

-- Round the given number between the given decimal places
function Module:RoundN(number, decimal_places)
	decimal_places = (decimal_places or 0)
	if decimal_places == 0 then
		return math.round(number)
	end
	local e = math.pow(10, decimal_places)
	return math.round(number * e) / e
end

-- Clamp the given value between 0 and 1
function Module:Clamp01(value)
	return math.clamp(value, 0, 1)
end

-- Add Commas to Number, 1000 = 1,000
function Module:NumberCommas(value, useAltCommas)
	local wholeComponent = tostring(math.floor(math.abs(value)))
	local decimalComponent = tostring(value - math.floor(value))
	local comma = useAltCommas and "." or ","
	local period = useAltCommas and "," or "."
	local newString = ""
	local digits = 0
	for idx = #wholeComponent, 1, -1 do
		newString = wholeComponent:sub(idx, idx) .. newString
		digits += 1
		if digits == 3 and idx ~= 1 then
			newString = comma .. newString
			digits = 0
		end
	end
	if decimalComponent ~= "0" and #decimalComponent > 2 then
		newString = newString .. period .. decimalComponent:sub(3)
	end
	if math.sign(value) == -1 then
		newString = "-" .. newString
	end
	return newString
end

-- 300 -> (00:05:00)
function Module:FormatForTimer(seconds)
	seconds = math.floor(seconds)
	local minutes = (seconds/60)
	local hours = math.floor(minutes/60)
	hours = (hours < 0 and 0 or hours)
	minutes = math.floor(minutes) - (hours * 60)
	minutes = (minutes < 0 and 0 or minutes)
	seconds = seconds - (minutes*60) - (hours * 60 * 60)
	seconds = (seconds < 0 and 0 or seconds)
	return (hours>9 and hours or '0'..hours)..':'..(minutes>9 and minutes or '0'..minutes)..':'..(seconds>9 and seconds or '0'..seconds)
end

local NUMBER_SUFFIXES = {"k","M","B","T","qd","Qn","sx","Sp","O","N","de","Ud","DD","tdD","qdD","QnD","sxD","SpD","OcD","NvD","Vgn","UVg","DVg","TVg","qtV","QnV","SeV","SPG","OVG","NVG","TGN","UTG","DTG","tsTG","qtTG","QnTG","ssTG","SpTG","OcTG","NoTG","QdDR","uQDR","dQDR","tQDR","qdQDR","QnQDR","sxQDR","SpQDR","OQDDr","NQDDr","qQGNT","uQGNT","dQGNT","tQGNT","qdQGNT","QnQGNT","sxQGNT","SpQGNT", "OQQGNT","NQQGNT","SXGNTL"}

-- 50000 -> 50k
function Module:NumberSuffix(Input)
	local Negative = (Input < 0)
	local Paired = false
	Input = math.abs(Input)
	for i, _ in pairs(NUMBER_SUFFIXES) do
		if Input < math.pow(10, 3 * i) then
			Input /= math.pow(10, (3 * (i - 1) ) )
			local isComplex = (string.find(tostring(Input),".") and string.sub(tostring(Input),4,4) ~= ".")
			Input = string.sub(tostring(Input), 1, (isComplex and 4) or 3)..(NUMBER_SUFFIXES[i-1] or "")
			Paired = true
			break
		end
	end
	if not Paired then
		Input = tostring(math.floor(Input))
	end
	if Negative then
		return "-"..Input
	end
	return Input
end

-- Module:ToNumeral(5) - "V"
function Module:ToRomanNumeral(Number)
	local Numbers = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1,}
	local Numerals = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I",}
	local Result = ""
	if Number < 0 or Number >= 4000 then
		return nil
	elseif Number == 0 then
		return "N"
	else
		for Index = 1, 13 do
			while Number >= Numbers[Index] do
				Number = Number - Numbers[Index]
				Result = Result..Numerals[Index]
			end
		end
	end
	return Result
end

local RomanDigit = {["I"] = 1, ["V"] = 5, ["X"] = 10, ["L"] = 50, ["C"] = 100, ["D"] = 500, ["M"] = 1000}
local SpecialRomanDigit = {["I"] = 1, ["X"] = 10, ["C"] = 100,}
local function CheckNumOfCharacterInString(TheString, Character)
	local Number = 0
	for _ in string.gmatch(TheString, Character) do
		Number = Number + 1
	end
	return Number
end

-- GetRomanNumeral("XII")
function Module:FromRomanNumeral(Numeral)
	Numeral = string.upper(Numeral)
	local Result = 0
	if Numeral == "N" then 
		return 0
	elseif CheckNumOfCharacterInString(Numeral, "V") >= 2 or CheckNumOfCharacterInString(Numeral, "L") >= 2 or CheckNumOfCharacterInString(Numeral, "D") >= 2 then --(#{string.find(Numeral, "V*.V")} >= 2) or (#{string.find(Numeral, "L*.L")} >= 2) or (#{string.find(Numeral, "D*.D")} >= 2) then
		return nil
	end
	local Last = "Z"
	local Count = 1
	for i=1, #Numeral do
		local Numeral = string.sub(Numeral, i, i)
		if not RomanDigit[Numeral] then
			return nil
		end
		if Numeral == Last then
			Count = Count + 1
			if Count >= 4 then
				return nil
			end
		else
			Count = 1
		end
		Last = Numeral
	end
	local Pointer = 1
	local Values = {}
	local MaxDigit = 1000
	while Pointer <= #Numeral do
		local Numeral = string.sub(Numeral, Pointer, Pointer)
		local Digit = RomanDigit[Numeral]
		if Digit > MaxDigit then
			return nil
		end
		local NextDigit = 0
		if Pointer <= #Numeral - 1 then
			local NextNumeral = string.sub(Numeral, Pointer+1, Pointer+1)
			NextDigit = RomanDigit[NextNumeral]
			if NextDigit > Digit then
				if (not SpecialRomanDigit[Numeral]) or NextDigit > (Digit * 10) or CheckNumOfCharacterInString(Numeral, Numeral) > 3 then
					return nil
				end
				MaxDigit = Digit - 1
				Digit = NextDigit - Digit
				Pointer = Pointer + 1
			end
		end
		table.insert(Values, Digit)
		Pointer = Pointer + 1
	end
	for Index = 1, #Values-1 do
		if Values[Index] < Values[Index + 1] then
			return nil
		end
	end
	local Total = 0
	for _, Digit in pairs(Values) do
		Total = Total + Digit
	end
	return Total
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047e</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDA5F0BABC8EB44F0ADF801117C81E21E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">String</string>
							<string name="ScriptGuid">{C14716DE-0CA4-4C9C-951D-AC106B717BA1}</string>
							<ProtectedString name="Source"><![CDATA[
local Module = {}

function Module:ConvertToBytesTable(str)
	local bytes = {}
	for strIndex = 1, #str do
		local character = string.sub(str, strIndex, strIndex)
		local byte = string.byte(character)
		table.insert(bytes, byte)
	end
	return bytes
end

function Module:ConvertToTotalBytes(str)
	local total = 0
	for _, n in ipairs(Module:ConvertToBytesTable(str)) do
		total += n
	end
	return total
end

function Module:SpaceStringByPrimary(str) -- splits string at the start of a new capital or at the end of a number sequence
	local regions = {}
	local currentIndex = 1
	local hasNumber = false
	local function Split(Index)
		local leftRegion = string.sub(str, 1, Index - 1)
		local rightRegion = string.sub(str, Index, #str)
		table.insert(regions, leftRegion)
		str = rightRegion
	end
	while true do
		currentIndex += 1
		if currentIndex > #str then
			table.insert(regions, str)
			break
		end
		local char = string.sub(str, currentIndex, currentIndex)
		if string.byte(char) > 64 and string.byte(char) < 91 then -- capital letters
			hasNumber = false
			Split(currentIndex)
			currentIndex = 1
		elseif string.byte(char) > 48 and string.byte(char) < 57 and not hasNumber then -- numbers
			hasNumber = true
			Split(currentIndex)
			currentIndex = 1
		end
	end
	return table.concat(regions, ' ')
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003047f</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0935B870CDEC41F0AC4640B1FB409DFE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Table</string>
							<string name="ScriptGuid">{FBD09D01-F630-4BDF-8B98-AA9A08F0772A}</string>
							<ProtectedString name="Source"><![CDATA[
-- // Module // --
local Module = {}

function Module:DeepCopy(passed_table)
	local clonedTable = {}
	if typeof(passed_table) == "table" then
		for k,v in pairs(passed_table) do
			clonedTable[Module:DeepCopy(k)] = Module:DeepCopy(v)
		end
	else
		clonedTable = passed_table
	end
	return clonedTable
end

-- DICTIONARY
function Module:CountDictionary( Dict )
	local count = 0
	for _, _ in pairs(Dict) do
		count += 1
	end
	return count
end

function Module:GetDictionaryIndexes( Dict )
	local indexes = {}
	for i, _ in pairs(Dict) do
		table.insert(indexes, i)
	end
	return indexes
end

function Module:GetRandomDictionaryIndex(Dict)
	local indexes = Module:GetDictionaryIndexes( Dict )
	return indexes[Random.new():NextInteger(1, #indexes)]
end

function Module:GetRandDictionaryValue(Dict)
	return Dict[ Module:GetRandDictionaryIndex(Dict) ]
end

function Module:RandomizeArray( arrayTable )
	local item = nil
	local rng = Random.new(os.time())
	for i = #arrayTable, 1, -1 do
		item = table.remove(arrayTable, rng:NextInteger(1, i))
		table.insert(arrayTable, item)
	end
end

-- Combine all arrays passed into this function into one singular table.
function Module:CombineArrays(...)
	local combined = {}
	local arrays = {...}
	for index = 1, #arrays do
		if typeof(arrays[index]) == 'table' and #arrays[index] > 0 then
			table.move(arrays[index], 1, #arrays[index], #combined + 1, combined)
		end
	end
	return combined
end

-- Combine all dictionaries passed into this function into one singular dictionary
-- Overlapping indexes outputs warnings
function Module:CombineDictionaries(...)
	local combined = {}
	for _, dictTbl in ipairs( {...} ) do
		for index, val in pairs(dictTbl) do
			if combined[index] then
				warn('Overlapping Index Found ; ', index)
				continue
			end
			combined[index] = val
		end
	end
	return combined
end

-- Returns integer/string, boolean
-- boolean determines if its an array (false) or dictionary (true)
function Module:FindValueInTable(SearchTable, Value)
	if #SearchTable > 0 then
		-- array
		return table.find(SearchTable, Value), false
	else
		-- dictionary
		for index, Val in pairs( SearchTable ) do
			if Val == Value then
				return index, true
			end
		end
	end
	return nil
end

-- OBJECTS -> TABLE // TABLE -> OBJECTS
local OT_Types = {
	['boolean'] = 'BoolValue',
	['string'] = 'StringValue',
	['number'] = 'NumberValue',
}

function Module:TableToObject(Tbl, Prnt, Ignores, Nst)
	Nst = Nst or 0
	if Nst > 30 then
		return
	end
	for k, v in pairs(Tbl) do
		if Ignores and table.find(Ignores, tostring(k)) then
			continue
		end
		local valType = typeof(v)
		if valType == 'table' then
			local Fold = Instance.new('Folder')
			Fold.Name = tostring(k)
			Module:TableToObject(v, Fold, Ignores, Nst + 1)
			Fold.Parent = Prnt
		elseif typeof(k) == 'number' and valType == 'string' then
			local Fold = Instance.new('Folder')
			Fold.Name = v
			Fold.Parent = Prnt
		else
			local c = OT_Types[valType] or OT_Types['string']
			local val = Instance.new(c)
			val.Name = tostring(k)

			local success, _ = pcall(function()
				val.Value = v
			end)

			if not success then
				val.Value = tostring(v)
			end

			val.Parent = Prnt
		end
	end
	return Prnt
end

function Module:ObjectToTable(Prnt, Tbl)
	Tbl = Tbl or {}
	for _, child in ipairs(Prnt:GetChildren()) do
		if child:IsA('Folder') then
			Tbl[child.Name] = Module:ObjectToTable({}, child)
		else
			Tbl[child.Name] = child.Value
		end
	end
	return Tbl
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030480</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD7844B0EED1F425CA1F17BE875D5B69B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Time</string>
							<string name="ScriptGuid">{65133F8E-3D54-4D02-A62E-11C910632ED1}</string>
							<ProtectedString name="Source"><![CDATA[
local Module = {}

function Module:GetUTC()
	return os.time(os.date('!*t'))
end

return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030481</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX315CA0C1F11644A3819B9B533A77DC89">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Visualizers</string>
							<string name="ScriptGuid">{70E3CD82-A36C-4FD0-9AFE-BE370E336567}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService('RunService')
local Debris = game:GetService('Debris')

local Terrain = workspace.Terrain

local function SetProperties(BaseInstance, Properties)
	if typeof(Properties) == 'table' then
		for propName, propValue in pairs(Properties) do
			BaseInstance[propName] = propValue
		end
	end
end

local function SetDuration(BaseInstance, Duration)
	if typeof(Duration) == 'number' then
		Debris:AddItem(BaseInstance, Duration)
	end
end

-- //Module // --
local Module = {}

-- Set an Instance's properties through passing a table
function Module:SetProperties(BaseInstance, Properties)
	SetProperties(BaseInstance, Properties)
end

-- Create an Attachment at the position.
function Module:Attachment(Position, Duration)
	local Attachment = Instance.new('Attachment')
	Attachment.Name = 'VisualNode'
	Attachment.Visible = true
	Attachment.WorldPosition = Position
	Attachment.Parent = Terrain
	SetDuration(Attachment, Duration)
	return Attachment
end

-- Create a Beam at the position to the target position
local baseBeam = Instance.new('Beam')
baseBeam.Enabled = true
baseBeam.Width0 = 0.1
baseBeam.Width1 = 0.1
baseBeam.FaceCamera = true
baseBeam.LightInfluence = 0
baseBeam.Color = ColorSequence.new(Color3.new(1, 1, 1))
baseBeam.Brightness = 0
baseBeam.LightInfluence = 0
baseBeam.LightEmission = 0
baseBeam.Segments = 2
function Module:Beam(StartPosition, EndPosition, Duration, Properties)
	local NodeA = Module:Attachment(StartPosition, Duration)
	NodeA.Visible = false
	local NodeB = Module:Attachment(EndPosition, Duration)
	NodeB.Visible = false
	local newBeam = baseBeam:Clone()
	newBeam.Attachment0 = NodeA
	newBeam.Attachment1 = NodeB
	newBeam.Parent = NodeA
	SetProperties(newBeam, Properties)
	return newBeam
end

-- Create a Part at the position
local basePart = Instance.new('Part')
basePart.Transparency = 0.7
basePart.Anchored = true
basePart.CanCollide = false
basePart.CanQuery = false
basePart.CanTouch = false
basePart.CastShadow = false
basePart.Color = Color3.new(1,1,1)
basePart.Massless = true
function Module:BasePart(Position, Duration, Properties)
	local newPart = basePart:Clone()
	newPart.Position = Position
	newPart.Parent = Terrain
	SetProperties(newPart, Properties)
	SetDuration(newPart, Duration)
	return newPart
end

-- Create a SphereHandleAdornment at the position.
function Module:CircleNode(Position, Properties, Duration)
	local Node = Module:BasePart(Position, Duration)
	Node.Transparency = 1
	local Adornment = Instance.new('SphereHandleAdornment')
	Adornment.Visible = true
	Adornment.Radius = 0.1
	Adornment.AlwaysOnTop = true
	Adornment.Transparency = 0.7
	Adornment.Adornee = Node
	Adornment.Parent = Node
	SetProperties(Adornment, Properties)
	return Adornment, Node
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030482</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4FD54DB2F155479CB3F642C4750D833B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScriptUtility</string>
							<string name="ScriptGuid">{18867EE8-92B2-49F7-9416-C059545AB56E}</string>
							<ProtectedString name="Source"><![CDATA[
type SourceScript = BaseScript & { Source : string }

local LuaSyntaxToolsetInstance = script.LuaSyntaxToolset
local LuaSyntaxToolset = require(LuaSyntaxToolsetInstance)
local tokenModule = require(LuaSyntaxToolsetInstance.tokenize)
local parseModule = require(LuaSyntaxToolsetInstance.parse)

-- // Module // --
local Module = {}

function Module:RawTokenParse( ScriptInstance : SourceScript ) : table
	return parseModule(tokenModule(ScriptInstance.Source))
end

function Module:GetScriptRequireTree( sourceContainer : SourceScript )
	-- parse the script
	-- get an array of scripts that are required by this module
end

function Module:LinkScriptsToTree( ... : SourceScript )
	local sources = { ... }
	-- parse scripts
	-- find connections between scripts
	-- provide a table of which script (FullName?) require other scripts
	return {}
end

return Module

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032afb</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX42965F5D2BD449BD8C16F3CA1A351680">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LuaSyntaxToolset</string>
								<string name="ScriptGuid">{AF79CA4D-F3F0-4C63-9B87-66F6586ED65C}</string>
								<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.lookupify)
local formatTable = require(script.formatTable)

local tokenize = require(script.tokenize)
local parse = require(script.parse)

local printAst = require(script.printAst)
local stripAst = require(script.stripAst)
local formatAst = require(script.formatAst)

local addVariableInfo = require(script.addVariableInfo)
local beautifyVariables = require(script.beautifyVariables)
local minifyVariables = require(script.minifyVariablesAdvanced)

local decodeStrings = require(script.decodeStrings)
local encodeStrings = require(script.encodeStrings)

local Keywords = require(script.Keywords)
local WhitespaceCharacters = require(script.WhitespaceCharacters)
local AllIdentifierCharacters = require(script.AllIdentifierCharacters)

local LuaSyntaxToolset = {}

function LuaSyntaxToolset.minify(source: string, renameGlobals: boolean, doEncodeStrings: boolean)
	local tokens = tokenize(source)
	local ast = parse(tokens)
	local glb, root = addVariableInfo(ast)
	minifyVariables(glb, root, renameGlobals)
	if doEncodeStrings then
		encodeStrings(tokens)
	end
	stripAst(ast)
	return printAst(ast)
end

--[[
string source: The source code to beautify
bool renameVars: Should the local variables be renamed into easily find-replacable naming for reverse engineering?
bool renameGlobals: Should the same be done for globals? (unsafe if get/setfenv were used)
]]
function LuaSyntaxToolset.beautify(source: string, renameVars: boolean, renameGlobals: boolean, doDecodeStrings: boolean)
	local tokens = tokenize(source)
	local ast = parse(tokens)
	local glb, root = addVariableInfo(ast)
	if renameVars then
		beautifyVariables(glb, root, renameGlobals)
	end
	if doDecodeStrings then
		decodeStrings(tokens)
	end
	formatAst(ast)
	return printAst(ast)
end

return LuaSyntaxToolset
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032afd</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX041E0E17D3404C60851520BC0ECD3D83">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">AllIdentifierCharacters</string>
									<string name="ScriptGuid">{27C000D0-90E4-48F4-ADDA-CF689F1A474C}</string>
									<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
                 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
                 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
                 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
	             'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
	             '_',
	             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032afe</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8DFB2647EFA34174A0BF7E66F31CCF28">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Keywords</string>
									<string name="ScriptGuid">{22A6349E-CA05-4A41-AC22-7D9E88FAF2D2}</string>
									<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{
    'and', 'break', 'do', 'else', 'elseif',
    'end', 'false', 'for', 'function', 'goto', 'if',
    'in', 'local', 'nil', 'not', 'or', 'repeat',
    'return', 'then', 'true', 'until', 'while',
};]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032aff</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4C55543EC9F1407A8B14485024A6AC9A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WhitespaceCharacters</string>
									<string name="ScriptGuid">{9AF6F966-C392-41EB-BB1F-DEFEFA4BC573}</string>
									<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

return lookupify{' ', '\n', '\t', '\r'}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b00</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC060C1CFAED847E787236795B39C8C6F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">addVariableInfo</string>
									<string name="ScriptGuid">{EB97F50F-4591-4B62-9965-6BA16B726B3D}</string>
									<ProtectedString name="Source"><![CDATA[
local visitAst = require(script.Parent.visitAst)

function addVariableInfo(ast)
	local globalVars = {}
	local currentScope = nil

	-- Numbering generator for variable lifetimes
	local locationGenerator = 0
	local function markLocation()
		locationGenerator = locationGenerator + 1
		return locationGenerator
	end

	-- Scope management
	local function pushScope()
		currentScope = {
			ParentScope = currentScope;
			ChildScopeList = {};
			VariableList = {};
			BeginLocation = markLocation();
		}
		if currentScope.ParentScope then
			currentScope.Depth = currentScope.ParentScope.Depth + 1
			table.insert(currentScope.ParentScope.ChildScopeList, currentScope)
		else
			currentScope.Depth = 1
		end
		function currentScope:GetVar(varName)
			for _, var in pairs(self.VariableList) do
				if var.Name == varName then
					return var
				end
			end
			if self.ParentScope then
				return self.ParentScope:GetVar(varName)
			else
				for _, var in pairs(globalVars) do
					if var.Name == varName then
						return var
					end
				end
			end
		end
	end
	local function popScope()
		local scope = currentScope

		-- Mark where this scope ends
		scope.EndLocation = markLocation()

		-- Mark all of the variables in the scope as ending there
		for _, var in pairs(scope.VariableList) do
			var.ScopeEndLocation = scope.EndLocation
		end

		-- Move to the parent scope
		currentScope = scope.ParentScope

		return scope
	end
	pushScope() -- push initial scope

	-- Add / reference variables
	local function addLocalVar(name, setNameFunc, localInfo)
		assert(localInfo, "Misisng localInfo")
		assert(name, "Missing local var name")
		local var = {
			Type = 'Local';
			Name = name;
			RenameList = {setNameFunc};
			AssignedTo = false;
			Info = localInfo;
			UseCount = 0;
			Scope = currentScope;
			BeginLocation = markLocation();
			EndLocation = markLocation();
			ReferenceLocationList = {markLocation()};
		}
		function var:Rename(newName)
			self.Name = newName
			for _, renameFunc in pairs(self.RenameList) do
				renameFunc(newName)
			end
		end
		function var:Reference()
			self.UseCount = self.UseCount + 1
		end
		table.insert(currentScope.VariableList, var)
		return var
	end
	local function getGlobalVar(name)
		for _, var in pairs(globalVars) do
			if var.Name == name then
				return var
			end
		end
		local var = {
			Type = 'Global';
			Name = name;
			RenameList = {};
			AssignedTo = false;
			UseCount = 0;
			Scope = nil; -- Globals have no scope
			BeginLocation = markLocation();
			EndLocation = markLocation();
			ReferenceLocationList = {};
		}
		function var:Rename(newName)
			self.Name = newName
			for _, renameFunc in pairs(self.RenameList) do
				renameFunc(newName)
			end
		end
		function var:Reference()
			self.UseCount = self.UseCount + 1
		end
		table.insert(globalVars, var)
		return var
	end
	local function addGlobalReference(name, setNameFunc)
		assert(name, "Missing var name")
		local var = getGlobalVar(name)
		table.insert(var.RenameList, setNameFunc)
		return var
	end
	local function getLocalVar(scope, name)
		-- First search this scope
		-- Note: Reverse iterate here because Lua does allow shadowing a local
		--       within the same scope, and the later defined variable should
		--       be the one referenced.
		for i = #scope.VariableList, 1, -1 do
			if scope.VariableList[i].Name == name then
				return scope.VariableList[i]
			end
		end

		-- Then search parent scope
		if scope.ParentScope then
			local var = getLocalVar(scope.ParentScope, name)
			if var then
				return var
			end
		end

		-- Then 
		return nil
	end
	local function referenceVariable(name, setNameFunc)
		assert(name, "Missing var name")
		local var = getLocalVar(currentScope, name)
		if var then
			table.insert(var.RenameList, setNameFunc)
		else
			var = addGlobalReference(name, setNameFunc)
		end
		-- Update the end location of where this variable is used, and
		-- add this location to the list of references to this variable.
		local curLocation = markLocation()
		var.EndLocation = curLocation
		table.insert(var.ReferenceLocationList, var.EndLocation)
		return var
	end

	local visitor = {}
	visitor.FunctionLiteral = {
		-- Function literal adds a new scope and adds the function literal arguments
		-- as local variables in the scope.
		Pre = function(expr)
			pushScope()
			for index, ident in pairs(expr.ArgList) do
				local var = addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function(expr)
			popScope()
		end;
	}
	visitor.VariableExpr = function(expr)
		-- Variable expression references from existing local varibales
		-- in the current scope, annotating the variable usage with variable
		-- information.
		expr.Variable = referenceVariable(expr.Token.Source, function(newName)
			expr.Token.Source = newName
		end)
	end
	visitor.StatList = {
		-- StatList adds a new scope
		Pre = function(stat)
			pushScope()
		end;
		Post = function(stat)
			-- Ugly hack for repeat until statements. They use a statlist in their body,
			-- but we have to wait to pop that stat list until the until conditional
			-- expression has been visited rather than popping where the textual contents 
			-- of the statlist actually end. (As is the case for all the other places a 
			-- stat list can appear)
			if not stat.SkipPop then
				popScope()
			end
		end;
	}
	visitor.LocalVarStat = {
		Post = function(stat)
			-- Local var stat adds the local variables to the current scope as locals
			-- We need to visit the subexpressions first, because these new locals
			-- will not be in scope for the initialization value expressions. That is:
			--  `local bar = bar + 1`
			-- Is valid code
			for varNum, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					stat.VarList[varNum].Source = name
				end, {
					Type = 'Local';
				})
			end		
		end;
	}
	visitor.LocalFunctionStat = {
		Pre = function(stat)
			-- Local function stat adds the function itself to the current scope as
			-- a local variable, and creates a new scope with the function arguments
			-- as local variables.
			addLocalVar(stat.FunctionStat.NameChain[1].Source, function(name)
				stat.FunctionStat.NameChain[1].Source = name
			end, {
				Type = 'LocalFunction';
			})
			pushScope()
			for index, ident in pairs(stat.FunctionStat.ArgList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function()
			popScope()
		end;
	}
	visitor.FunctionStat = {
		Pre = function(stat) 			
			-- Function stat adds a new scope containing the function arguments
			-- as local variables.
			-- A function stat may also assign to a global variable if it is in
			-- the form `function foo()` with no additional dots/colons in the 
			-- name chain.
			-- **BUGFIX**: If `function foo()` is done when there is already a local
			-- variable `foo` in scope, it will assign to the local variable instead
			-- of a global one! I did not know this when writing it initially.
			local nameChain = stat.NameChain
			local var;
			if #nameChain == 1 then
				-- If there is only one item in the name chain, then the first item
				-- is a reference to a variable
				if getLocalVar(currentScope, nameChain[1].Source) then
					-- If there is a local of that name, then it's a reference to that local
					var = referenceVariable(nameChain[1].Source, function(name)
						nameChain[1].Source = name
					end)
				else
					-- Otherwise, it's a reference to a global
					var = addGlobalReference(nameChain[1].Source, function(name)
						nameChain[1].Source = name
					end)
				end
			else
				var = referenceVariable(nameChain[1].Source, function(name)
					nameChain[1].Source = name
				end)
			end
			var.AssignedTo = true
			pushScope()
			for index, ident in pairs(stat.ArgList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'Argument';
					Index = index;
				})
			end
		end;
		Post = function()
			popScope()
		end;
	}
	visitor.GenericForStat = {
		Pre = function(stat)
			-- Generic fors need an extra scope holding the range variables
			-- Need a custom visitor so that the generator expressions can be
			-- visited before we push a scope, but the body can be visited
			-- after we push a scope.
			for _, ex in pairs(stat.GeneratorList) do
				visitAst(ex, visitor)
			end
			pushScope()
			for index, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'ForRange';
					Index = index;
				})
			end
			visitAst(stat.Body, visitor)
			popScope()
			return true -- Custom visit
		end;
	}
	visitor.NumericForStat = {
		Pre = function(stat)
			-- Numeric fors need an extra scope holding the range variables
			-- Need a custom visitor so that the generator expressions can be
			-- visited before we push a scope, but the body can be visited
			-- after we push a scope.
			for _, ex in pairs(stat.RangeList) do
				visitAst(ex, visitor)
			end
			pushScope()
			for index, ident in pairs(stat.VarList) do
				addLocalVar(ident.Source, function(name)
					ident.Source = name
				end, {
					Type = 'ForRange';
					Index = index;
				})
			end
			visitAst(stat.Body, visitor)
			popScope()
			return true	-- Custom visit
		end;
	}
	visitor.RepeatStat = {
		Pre = function(stat)
			-- Extend the scope of the body statement up to the current point, that is
			-- up to the point *after* the until condition, since the body variables are
			-- still in scope through that condition.
			-- The SkipPop flag is used by visitor.StatList to accomplish this.
			stat.Body.SkipPop = true
		end;
		Post = function(stat)
			-- Now that the conditional exprssion has been visited, it's safe to pop the
			-- body scope
			popScope()
		end;
	}
	visitor.AssignmentStat = {
		Post = function(stat)
			-- For an assignment statement we need to mark the
			-- "assigned to" flag on variables.
			for _, ex in pairs(stat.Lhs) do
				if ex.Variable then
					ex.Variable.AssignedTo = true
				end
			end
		end;
	}

	visitAst(ast, visitor)

	return globalVars, popScope()
end

return addVariableInfo]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b01</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX588E6F6A02454E31B3E0A1A521822EAF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">beautifyVariables</string>
									<string name="ScriptGuid">{8A35995C-B51D-437A-BC09-410CF3ED9332}</string>
									<ProtectedString name="Source"><![CDATA[local function beautifyVariables(globalScope, rootScope, renameGlobals)
	local externalGlobals = {}
	for _, var in pairs(globalScope) do
		if not var.AssignedTo or not renameGlobals then
			externalGlobals[var.Name] = true
		end
	end

	local localNumber = 1
	local globalNumber = 1

	local function setVarName(var, name)
		var.Name = name
		for _, setter in pairs(var.RenameList) do
			setter(name)
		end
	end

	if renameGlobals then
		for _, var in pairs(globalScope) do
			if var.AssignedTo then
				setVarName(var, 'G_'..globalNumber..'_')
				globalNumber = globalNumber + 1
			end
		end
	end

	local function modify(scope)
		for _, var in pairs(scope.VariableList) do
			local name = 'L_'..localNumber..'_'
			if var.Info.Type == 'Argument' then
				name = name..'arg'..var.Info.Index
			elseif var.Info.Type == 'LocalFunction' then
				name = name..'func'
			elseif var.Info.Type == 'ForRange' then
				name = name..'forvar'..var.Info.Index
			end
			setVarName(var, name)
			localNumber = localNumber + 1
		end
		for _, scope in pairs(scope.ChildScopeList) do
			modify(scope)
		end
	end
	modify(rootScope)
end

return beautifyVariables]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b02</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF745A24D93214E9EB6BAE1D73E38F6F0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">decodeStrings</string>
									<string name="ScriptGuid">{FCE1DEDF-399A-4C30-8A13-942C34C9D7BC}</string>
									<ProtectedString name="Source"><![CDATA[
local MIN_PRINTABLE = 32
local MAX_PRINTABLE = 126
local ESCAPES = {
	[string.byte('\a')] = 'a',
	[string.byte('\b')] = 'b',
	[string.byte('\f')] = 'f',
	[string.byte('\n')] = 'n',
	[string.byte('\t')] = 't',
	[string.byte('\r')] = 'r',
	[string.byte('\v')] = 'v',
}

function decodeCharacter(chars)
	local code = tonumber(chars, 16)
	local char = string.char(code)
	if code >= MIN_PRINTABLE and code <= MAX_PRINTABLE then
		return string.char(code)
	elseif code >= 0 and code <= 0xFF and ESCAPES[char] then
		return "\\"..ESCAPES[char]
	elseif code <= 0xFF then
		return string.format("\\x%X", code)	
	else
		return string.format("\\u{%X}", code)
	end
end

function decode(str, quot)
	local elements = {quot}
	local p = 2
	local len = #str
	while p < len do
		local c = str:sub(p, p)
		if c == '\\' then
			-- Some kind of escape
			local escape = str:sub(p + 1, p + 1):lower()
			if escape == 'x' then
				-- Hexidecimal escape
				table.insert(elements, decodeCharacter(str:sub(p + 2, p + 3)))
				p += 4
			elseif escape == 'u' then
				local q = str:find('}', p)
				table.insert(elements, decodeCharacter(str:sub(p + 3, q - 1)))
				p = q + 1
			else
				-- Normal escape
				table.insert(elements, '\\'..escape)
				p += 2
			end
		else
			-- Normal character
			table.insert(elements, c)
			p += 1
		end
	end
	table.insert(elements, quot)
	return table.concat(elements)
end

return function(tokens)
	for _, token in pairs(tokens) do
		if token.Type == 'String' then
			-- Don't modify long string constants
			local quot = token.Source:sub(1, 1)
			if quot == '"' or quot == "'" then
				token.Source = decode(token.Source, quot)
			end
		end	
	end
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b03</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX224C454AC1BC47319C75A2662768AF4C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">decodeStrings.spec</string>
									<string name="ScriptGuid">{A8C3B9D0-0131-4597-9573-1FD788D6B37A}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local decodeStrings = require(script.Parent.decodeStrings)
	local tokenize = require(script.Parent.tokenize)
	
	describe("decoding string constants", function()
		it("should decode some ascii text as hex escapes", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\x20\n\x20\u{FFF}\x31\x32\x33"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing \n \u{FFF}123"]])
		end)
		
		it("should not decode a non-ascii character", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\xAB"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing\xAB"]])
		end)

		it("should uppercase hex and unicode escapes", function()
			local tokens = tokenize[["\x54\x65\x73\x74\x69\x6e\x67\xab\u{fff}"]]
			decodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["Testing\xAB\u{FFF}"]])
		end)
	end)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b04</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD6FA27DEBE2A4979B35B6301589D9D77">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">encodeStrings</string>
									<string name="ScriptGuid">{D5528591-0E68-4416-8013-F8897C7DC459}</string>
									<ProtectedString name="Source"><![CDATA[
function encodeCharacter(normalCharacter)
	return "\\x"..string.format("%X", string.byte(normalCharacter))
end


function encode(str, quot)
	local elements = {quot}
	local p = 2
	local len = #str
	while p < len do
		local c = str:sub(p, p)
		if c == '\\' then
			-- Some kind of escape
			local escape = str:sub(p + 1, p + 1):lower()
			if escape == 'x' then
				-- Hexidecimal escape
				table.insert(elements, str:sub(p, p + 3))
				p += 4
			elseif escape == 'u' then
				local q = str:find('}', p)
				table.insert(elements, str:sub(p, q))
				p = q + 1
			else
				-- Normal escape
				table.insert(elements, '\\'..escape)
				p += 2
			end
		else
			-- Normal character
			table.insert(elements, encodeCharacter(c))
			p += 1
		end
	end
	table.insert(elements, quot)
	return table.concat(elements)
end

return function(tokens)
	for _, token in pairs(tokens) do
		if token.Type == 'String' then
			-- Don't modify long string constants
			local quot = token.Source:sub(1, 1)
			if quot == '"' or quot == "'" then
				token.Source = encode(token.Source, quot)
			end
		end	
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b05</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8BE9F56BB27B4CE988D63EA5AE452001">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">encodeStrings.spec</string>
									<string name="ScriptGuid">{763E5B7E-6E68-49E8-80E2-9CD33F0A94F2}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local encodeStrings = require(script.Parent.encodeStrings)
	local tokenize = require(script.Parent.tokenize)

	describe("encoding string constants", function()
		it("should encode an empty string token", function()
			expect(function()
				encodeStrings(tokenize[[""]])
			end).never.to.throw()
		end)

		it("should encode a test string", function()
			local tokens = tokenize[["Testing"]]
			encodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["\x54\x65\x73\x74\x69\x6E\x67"]])
		end)

		it("should hex encode unicode text", function()
			local tokens = tokenize[["😜"]]
			encodeStrings(tokens)
			expect(tokens[1].Source).to.equal([["\xF0\x9F\x98\x9C"]])
		end)
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b06</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB272B00F15CC471E969450788A668231">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">formatAst</string>
									<string name="ScriptGuid">{FF5B476E-6BE9-4CB4-B786-CCBB37BEA212}</string>
									<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)
local WhitespaceCharacters = require(script.Parent.WhitespaceCharacters)
local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

-- Adds / removes whitespace in an AST to put it into a "standard formatting"
local function formatAst(ast)
	local formatStat
	local formatExpr
	local formatType

	local currentIndent = 0

	local function applyIndent(token)
		local indentString = '\n'..('\t'):rep(currentIndent)
		if token.LeadingWhite == '' or (token.LeadingWhite:sub(-#indentString, -1) ~= indentString) then
			-- Trim existing trailing whitespace on LeadingWhite
			-- Trim trailing tabs and spaces, and up to one newline
			token.LeadingWhite = token.LeadingWhite:gsub("\n?[\t ]*$", "")
			token.LeadingWhite = token.LeadingWhite..indentString
		end
	end

	local function tighten(token)
		token.LeadingWhite = token.LeadingWhite:gsub("[ ]*$", "")
	end

	local function trim(token)
		tighten(token)
		token.LeadingWhite = token.LeadingWhite:gsub("^%s*", "")
	end

	local function indent()
		currentIndent = currentIndent + 1
	end

	local function undent()
		currentIndent = currentIndent - 1
		assert(currentIndent >= 0, "Undented too far")
	end

	local function leadingChar(tk)
		if #tk.LeadingWhite > 0 then
			return tk.LeadingWhite:sub(1,1)
		else
			return tk.Source:sub(1,1)
		end
	end

	local function joint(tokenA, tokenB)
		-- Get the trailing A <-> leading B character pair
		local lastCh = tokenA.Source:sub(-1, -1)
		local firstCh = tokenB.Source:sub(1, 1)

		-- Cases to consider:
		--  Touching minus signs -> comment: `- -42` -> `--42' is invalid
		--  Touching dots: `.. .5` -> `...5` is invalid
		--  Touching words: `a b` -> `ab` is invalid
		--  Touching digits: `2 3`, can't occurr in the Lua syntax as number literals aren't a primary expression
		--  Abiguous syntax: `f(x)\n(x)()` is already disallowed, we can't cause a problem by removing newlines
		--  `>` `=` cannot be merged, because they will become a `>=` token.

		-- Figure out what separation is needed
		if 
			(lastCh == '-' and firstCh == '-') or
			(lastCh == '>' and firstCh == '=') or
			(lastCh == '.' and firstCh == '.') or
			(AllIdentifierCharacters[lastCh] and AllIdentifierCharacters[firstCh]) 
		then
			tokenB.LeadingWhite = ' ' -- Use a separator
		else
			tokenB.LeadingWhite = '' -- Don't use a separator
		end
	end

	local function padToken(tk)
		tighten(tk)
		if not WhitespaceCharacters[leadingChar(tk)] then
			tk.LeadingWhite = ' '..tk.LeadingWhite
		end
	end

	local function padExpr(expr)
		padToken(expr:GetFirstToken())
	end

	local function formatBody(openToken, bodyStat, closeToken)
		indent()
		formatStat(bodyStat)
		undent()
		applyIndent(closeToken)
	end

	formatType = function(typeExpr)
		tighten(typeExpr:GetFirstToken())
		if typeExpr.Type == 'BasicType' then
			for index, ident in pairs(typeExpr.IdentList) do
				tighten(ident)
				if typeExpr.Token_IdentDotList[index] then
					tighten(typeExpr.Token_IdentDotList[index])
				end
			end
			if typeExpr.Token_OpenAngle then
				tighten(typeExpr.Token_OpenAngle)
				for index, typeArg in pairs(typeExpr.GenericArgumentList) do
					formatType(typeArg)
					if index == 1 then
						tighten(typeArg:GetFirstToken())
					else
						padToken(typeArg:GetFirstToken())
					end
					if typeExpr.Token_GenericArgumentCommaList[index] then
						tighten(typeExpr.Token_GenericArgumentCommaList[index])
					end
				end
				tighten(typeExpr.Token_CloseAngle)
			end
		elseif typeExpr.Type == 'NilType' then
			tighten(typeExpr.Token_Nil)
		elseif typeExpr.Type == 'TypeofType' then
			--(typeExpr.Token_Typeof)
			tighten(typeExpr.Token_OpenParen)
			formatExpr(typeExpr.Expression)
			tighten(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'FunctionType' then
			formatType(typeExpr.ArgType)
			padToken(typeExpr.Token_Arrow)
			formatType(typeExpr.ReturnType)
			padToken(typeExpr.ReturnType:GetFirstToken())
		elseif typeExpr.Type == 'TupleType' then
			--(typeExpr.Token_OpenParen)
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				formatType(subTypeExpr)
				if index == 1 then
					tighten(subTypeExpr:GetFirstToken())
				else
					padToken(subTypeExpr:GetFirstToken())
				end
				if typeExpr.Token_CommaList[index] then
					tighten(typeExpr.Token_CommaList[index])
				end
			end
			tighten(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'TableType' then
			--(typeExpr.Token_OpenBrace)
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					if index == 1 then
						tighten(record.Token_OpenBracket)
					else
						padToken(record.Token_OpenBracket)
					end
					formatType(record.KeyType)
					tighten(record.Token_CloseBracket)
					tighten(record.Token_Colon)
					formatType(record.ValueType)
					padToken(record.ValueType:GetFirstToken())
				elseif record.Type == 'Name' then
					if index == 1 then
						tighten(record.Ident)
					else
						padToken(record.Ident)
					end
					tighten(record.Token_Colon)
					formatType(record.ValueType)
					padToken(record.ValueType:GetFirstToken())
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
				if typeExpr.Token_CommaList[index] then
					tighten(typeExpr.Token_CommaList[index])
				end
			end
			tighten(typeExpr.Token_CloseBrace)
		elseif typeExpr.Type == 'OptionalType' then
			formatType(typeExpr.BaseType)
			tighten(typeExpr.Token_QuestionMark)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				formatType(subTypeExpr)
				if index > 1 then
					padToken(subTypeExpr:GetFirstToken())
				end
				if typeExpr.Token_CombinerList[index] then
					padToken(typeExpr.Token_CombinerList[index])
				end
			end
		else
			error("Bad typeExpr type in: "..formatTable(typeExpr))
		end
	end

	formatExpr = function(expr)
		tighten(expr:GetFirstToken())
		if expr.Type == 'BinopExpr' then
			formatExpr(expr.Lhs)
			formatExpr(expr.Rhs)
			if expr.Token_Op.Source == '..' then
				-- Only necessary padding on ..
				joint(expr.Lhs:GetLastToken(), expr.Token_Op)
				joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			else
				padExpr(expr.Rhs)
				padToken(expr.Token_Op)
			end
		elseif expr.Type == 'UnopExpr' then
			formatExpr(expr.Rhs)
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			--(expr.Token_Op)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Nothing to do
			--(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			formatExpr(expr.Base)
			tighten(expr.Token_Dot)
			tighten(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			formatExpr(expr.Base)
			formatExpr(expr.Index)
			--(expr.Token_OpenBracket)
			--(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			formatExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				--(expr.Token_Colon)
				--(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				--(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				--(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					formatExpr(argExpr)
					if index > 1 then
						padExpr(argExpr)
					end
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						tighten(sep)
					end
				end
				--(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				formatExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			--(expr.Token_Function)
			tighten(expr.Token_OpenParen)
			for index, arg in pairs(expr.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = expr.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(expr.ArgTypeList[index])
				end
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #expr.ArgList > 0 and expr.Token_Varg then
				padToken(expr.Token_Varg)
			end
			tighten(expr.Token_CloseParen)
			if expr.Token_Colon then
				tighten(expr.Token_Colon)
				formatType(expr.ReturnType)
				padToken(expr.ReturnType:GetFirstToken())
			end
			formatBody(expr.Token_CloseParen, expr.Body, expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			--(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			formatExpr(expr.Expression)
			--(expr.Token_OpenParen)
			tighten(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			--(expr.Token_OpenBrace)
			if #expr.EntryList == 0 then
				-- Nothing to do
			else
				indent()
				for index, entry in pairs(expr.EntryList) do
					if entry.EntryType == 'Field' then
						applyIndent(entry.Field)
						padToken(entry.Token_Equals)
						formatExpr(entry.Value)
						padExpr(entry.Value)
					elseif entry.EntryType == 'Index' then
						applyIndent(entry.Token_OpenBracket)
						formatExpr(entry.Index)
						tighten(entry.Token_CloseBracket)
						padToken(entry.Token_Equals)
						formatExpr(entry.Value)
						padExpr(entry.Value)
					elseif entry.EntryType == 'Value' then
						formatExpr(entry.Value)
						applyIndent(entry.Value:GetFirstToken())
					else
						assert(false, "unreachable")
					end
					local sep = expr.Token_SeparatorList[index]
					if sep then
						tighten(sep)
					end
				end
				undent()
				applyIndent(expr.Token_CloseBrace)
			end
			tighten(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end

	formatStat = function(stat)
		if stat.Type == 'StatList' then
			for _, stat in pairs(stat.StatementList) do
				formatStat(stat)
				applyIndent(stat:GetFirstToken())
			end

		elseif stat.Type == 'BreakStat' then
			--(stat.Token_Break)

		elseif stat.Type == 'ContinueStat' then
			--(stat.Token_Continue)

		elseif stat.Type == 'TypeStat' then
			if stat.Token_Export then
				tighten(stat.Token_Export)
				padToken(stat.Token_Type)
			else
				tighten(stat.Token_Type)
			end
				
			padToken(stat.Ident)
			if stat.Token_OpenAngle then
				tighten(stat.Token_OpenAngle)
				for index, ident in pairs(stat.GenericTypeList) do
					if index == 1 then
						tighten(ident)
					else
						padToken(ident)
					end
					if stat.Token_GenericTypeCommaList[index] then
						tighten(stat.Token_GenericTypeCommaList[index])
					end
				end
				tighten(stat.Token_CloseAngle)
			end
			padToken(stat.Token_Equals)
			formatType(stat.AliasedType)
			padToken(stat.AliasedType:GetFirstToken())

		elseif stat.Type == 'ReturnStat' then
			--(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				formatExpr(expr)
				padExpr(expr)
				if stat.Token_CommaList[index] then
					--(stat.Token_CommaList[index])
					tighten(stat.Token_CommaList[index])
				end
			end
		elseif stat.Type == 'LocalVarStat' then
			--(stat.Token_Local)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.TypeList[index])
					padToken(stat.TypeList[index]:GetFirstToken())
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if stat.Token_Equals then
				padToken(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					formatExpr(expr)
					padExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						tighten(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			--(stat.Token_Local)
			padToken(stat.FunctionStat.Token_Function)
			padToken(stat.FunctionStat.NameChain[1])
			tighten(stat.FunctionStat.Token_OpenParen)
			for index, arg in pairs(stat.FunctionStat.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = stat.FunctionStat.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.FunctionStat.ArgTypeList[index])
					padToken(stat.FunctionStat.ArgTypeList[index]:GetFirstToken())
				end
				local comma = stat.FunctionStat.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #stat.FunctionStat.ArgList > 0 and stat.FunctionStat.Token_Varg then
				padToken(stat.FunctionStat.Token_Varg)
			end
			tighten(stat.FunctionStat.Token_CloseParen)
			if stat.FunctionStat.Token_Colon then
				tighten(stat.FunctionStat.Token_Colon)
				formatType(stat.FunctionStat.ReturnType)
				padToken(stat.FunctionStat.ReturnType:GetFirstToken())
			end
			formatBody(stat.FunctionStat.Token_CloseParen, stat.FunctionStat.Body, stat.FunctionStat.Token_End)
		elseif stat.Type == 'FunctionStat' then
			--(stat.Token_Function)
			for index, part in pairs(stat.NameChain) do
				if index == 1 then
					padToken(part)
				end
				local sep = stat.Token_NameChainSeparator[index]
				if sep then
					tighten(sep)
				end
			end
			tighten(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				if index > 1 then
					padToken(arg)
				end
				local colon = stat.Token_ArgColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.ArgTypeList[index])
					padToken(stat.ArgTypeList[index]:GetFirstToken())
				end
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					tighten(comma)
				end
			end
			if #stat.ArgList > 0 and stat.Token_Varg then
				padToken(stat.Token_Varg)
			end
			tighten(stat.Token_CloseParen)
			if stat.Token_Colon then
				tighten(stat.Token_Colon)
				formatType(stat.ReturnType)
				padToken(stat.ReturnType:GetFirstToken())
			end
			formatBody(stat.Token_CloseParen, stat.Body, stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			--(stat.Token_Repeat)
			formatBody(stat.Token_Repeat, stat.Body, stat.Token_Until)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			--(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.VarTypeList[index])
					padToken(stat.VarTypeList[index]:GetFirstToken())
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				formatExpr(expr)
				padExpr(expr)
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			--(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				padToken(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					tighten(colon)
					formatType(stat.VarTypeList[index])
					padToken(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				formatExpr(expr)
				padExpr(expr)
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					tighten(sep)
				end
			end
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)	
		elseif stat.Type == 'WhileStat' then
			--(stat.Token_While)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
			padToken(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'DoStat' then
			--(stat.Token_Do)
			formatBody(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'IfStat' then
			--(stat.Token_If)
			formatExpr(stat.Condition)
			padExpr(stat.Condition)
			padToken(stat.Token_Then)
			--
			local lastBodyOpen = stat.Token_Then
			local lastBody = stat.Body
			--
			for _, clause in pairs(stat.ElseClauseList) do
				formatBody(lastBodyOpen, lastBody, clause.Token)
				lastBodyOpen = clause.Token
				--
				if clause.Condition then
					formatExpr(clause.Condition)
					padExpr(clause.Condition)
					padToken(clause.Token_Then)
					lastBodyOpen = clause.Token_Then
				end
				lastBody = clause.Body
			end
			--
			formatBody(lastBodyOpen, lastBody, stat.Token_End)

		elseif stat.Type == 'CallExprStat' then
			formatExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				formatExpr(ex)
				if index > 1 then
					padExpr(ex)
				end
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					--(sep)
					tighten(sep)
				end
			end
			padToken(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				formatExpr(ex)
				padExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					--(sep)
					tighten(sep)
				end
			end
		else
			assert(false, "unreachable")
		end	
	end

	formatStat(ast)
	trim(ast:GetFirstToken())
end

return formatAst]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b07</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5C8B04EF6DA7416EB4B5344BD3593191">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">formatAst.spec</string>
									<string name="ScriptGuid">{18674F27-83FC-4522-9C7A-830A434E0D29}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local formatAst = require(script.Parent.formatAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	local printAst = require(script.Parent.printAst)
	
	local function doFormat(str)
		local ast = parse(tokenize(str))
		formatAst(ast)
		return printAst(ast)
	end
	
	describe("formatting statements", function()
		it("should format an export type statement", function()
			local str = doFormat[[export  type   foo<T > =blah]]
			expect(str).to.equal[[export type foo<T> = blah]]
		end)
		
		it("should format nil type usage", function()
			local str = doFormat[[local a:nil=nil]]
			expect(str).to.equal[[local a: nil = nil]]
		end)
		
		it("should format a qualified type", function()
			local str = doFormat[[local a:b.c =d.e.  f()]]
			expect(str).to.equal[[local a: b.c = d.e.f()]]
		end)
	end)
	
	describe("formatting locals", function()
		it("should format a local declaration", function()
			doFormat[[
			local a,b,c
			]]
		end)

		it("should format generic type arguments", function()
			local str = doFormat[[local a:foo<bar,baz>]]
			expect(str).to.equal[[local a: foo<bar, baz>]]
			local str2 = doFormat[[local  a  :  Set<T>=value]]
			expect(str2).to.equal[[local a: Set<T> = value]]
		end)

		it("should format a local declaration with types", function()
			local str = doFormat[[local a:number,b:string=7]]
			expect(str).to.equal[[local a: number, b: string = 7]]
			local str2 = doFormat[[local  a   : number,   b :  string  =  7]]
			expect(str2).to.equal[[local a: number, b: string = 7]]
		end)

		it("should format a typed function", function()
			local str = doFormat[[local function  foo(arg:t):number bar()end]]
			expect(str).to.equal"local function foo(arg: t): number\n\tbar()\nend"
		end)

		it("should format a continue statement", function()
			local str = doFormat[[while true do continue end]]
			expect(str).to.equal"while true do\n\tcontinue\nend"
		end)

		it("should format compound assignments", function()
			local str = doFormat[[a+=b b/=c e%=f]]
			expect(str).to.equal"a += b\nb /= c\ne %= f"
		end)

		it("should format a type statement", function()
			local str = doFormat[[type FooBar<T,U>=number]]
			expect(str).to.equal"type FooBar<T, U> = number"
			local str2 = doFormat[[type   FooBar   <T  ,  U  >  =  number]]
			expect(str2).to.equal"type FooBar<T, U> = number"
		end)
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b08</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX04B29F6FADC948679D9114AFEBBD981D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">formatTable</string>
									<string name="ScriptGuid">{2BDC1644-5F54-4F34-A71B-88A9CBAFBD52}</string>
									<ProtectedString name="Source"><![CDATA[--[[
function formatTable(tb, function
]]

function CountTable(tb)
	local c = 0
	for _ in pairs(tb) do c = c + 1 end
	return c
end

function FormatTableInt(tb, atIndent, ignoreFunc)
	if tb.Print then
		return tb.Print()
	end
	atIndent = atIndent or 0
	local useNewlines = (CountTable(tb) > 1)
	local baseIndent = string.rep('    ', atIndent+1)
	local out = "{"..(useNewlines and '\n' or '')
	for k, v in pairs(tb) do
		if type(v) ~= 'function' and not ignoreFunc(k) then
			out = out..(useNewlines and baseIndent or '')
			if type(k) == 'number' then
				--nothing to do
			elseif type(k) == 'string' and k:match("^[A-Za-z_][A-Za-z0-9_]*$") then 
				out = out..k.." = "
			elseif type(k) == 'string' then
				out = out.."[\""..k.."\"] = "
			else
				out = out.."["..tostring(k).."] = "
			end
			if type(v) == 'string' then
				out = out.."\""..v.."\""
			elseif type(v) == 'number' then
				out = out..v
			elseif type(v) == 'table' then
				out = out..FormatTableInt(v, atIndent+(useNewlines and 1 or 0), ignoreFunc)
			else
				out = out..tostring(v)
			end
			if next(tb, k) then
				out = out..","
			end
			if useNewlines then
				out = out..'\n'
			end
		end
	end
	out = out..(useNewlines and string.rep('    ', atIndent) or '').."}"
	return out
end

local function formatTable(tb, ignoreFunc: (any) -> boolean): ()
	ignoreFunc = ignoreFunc or function() 
		return false
	end
	return FormatTableInt(tb, 0, ignoreFunc)
end

return formatTable
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b09</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA275CEAED6094FA4946C4BE76F0B6BD3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">generateVariableName</string>
									<string name="ScriptGuid">{20CBEA36-ED88-46AD-8F7A-D24FC683ABB4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
Turns an index [0..n) into a variable name. 
0 -> '_'
1 -> 'a'
27 -> 'z'
28 -> '_a'
29 -> '_b' 
etc...
]]
local VarDigits = {'_'}
for i = ('a'):byte(), ('z'):byte() do table.insert(VarDigits, string.char(i)) end
for i = ('A'):byte(), ('Z'):byte() do table.insert(VarDigits, string.char(i)) end
for i = ('0'):byte(), ('9'):byte() do table.insert(VarDigits, string.char(i)) end

local VarStartDigits = {'_'}
for i = ('a'):byte(), ('z'):byte() do table.insert(VarStartDigits, string.char(i)) end
for i = ('A'):byte(), ('Z'):byte() do table.insert(VarStartDigits, string.char(i)) end

local function generateVariableName(index)
	local id = ''
	local d = index % #VarStartDigits
	index = (index - d) / #VarStartDigits
	id = id..VarStartDigits[d+1]
	while index > 0 do
		local d = index % #VarDigits
		index = (index - d) / #VarDigits
		id = id..VarDigits[d+1]
	end
	return id
end

return generateVariableName]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3F48B921F4594A08838B63F1695F197E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lookupify</string>
									<string name="ScriptGuid">{96CED943-F0F8-41B9-ABB8-A48CBA5E8847}</string>
									<ProtectedString name="Source"><![CDATA[--[[
function lookupify(array)

Turn an array of items into a set where set[item] = true
Useful for declaring static sets of strings.
]]
return function(tb)
	for _, v in pairs(tb) do
		tb[v] = true
	end
	return tb
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX566E1CE31D194030AF284833E3B84E19">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">minifyVariablesAdvanced</string>
									<string name="ScriptGuid">{C0193EE1-FA88-4433-B330-89ED722EFC1F}</string>
									<ProtectedString name="Source"><![CDATA[local Keywords = require(script.Parent.Keywords)

local generateVariableName = require(script.Parent.generateVariableName)

local function minifyVariables(globalScope, rootScope, renameGlobals)
	-- Variable names and other names that are fixed, that we cannot use
	-- Either these are Lua keywords, or globals that are not assigned to,
	-- that is environmental globals that are assigned elsewhere beyond our 
	-- control.
	local globalUsedNames = {}
	for kw, _ in pairs(Keywords) do
		globalUsedNames[kw] = true
	end

	-- Gather a list of all of the variables that we will rename
	local allVariables = {}
	local allLocalVariables = {}
	do
		-- Add applicable globals
		for _, var in pairs(globalScope) do
			if var.AssignedTo and renameGlobals then
				-- We can try to rename this global since it was assigned to
				-- (and thus presumably initialized) in the script we are 
				-- minifying.
				table.insert(allVariables, var)
			else
				-- We can't rename this global, mark it as an unusable name
				-- and don't add it to the nename list
				globalUsedNames[var.Name] = true
			end
		end

		-- Recursively add locals, we can rename all of those
		local function addFrom(scope)
			for _, var in pairs(scope.VariableList) do
				table.insert(allVariables, var)
				table.insert(allLocalVariables, var)
			end
			for _, childScope in pairs(scope.ChildScopeList) do
				addFrom(childScope)
			end
		end
		addFrom(rootScope)
	end

	-- Add used name arrays to variables
	for _, var in pairs(allVariables) do
		var.UsedNameArray = {}
	end

	-- Sort the least used variables first
	table.sort(allVariables, function(a, b)
		return #a.RenameList < #b.RenameList
	end)

	-- Lazy generator for valid names to rename to
	local nextValidNameIndex = 0
	local varNamesLazy = {}
	local function varIndexToValidVarName(i)
		local name = varNamesLazy[i] 
		if not name then
			repeat
				name = generateVariableName(nextValidNameIndex)
				nextValidNameIndex = nextValidNameIndex + 1
			until not globalUsedNames[name]
			varNamesLazy[i] = name
		end
		return name
	end

	-- For each variable, go to rename it
	for _, var in pairs(allVariables) do
		-- Lazy... todo: Make theis pair a proper for-each-pair-like set of loops 
		-- rather than using a renamed flag.
		var.Renamed = true

		-- Find the first unused name
		local i = 1
		while var.UsedNameArray[i] do
			i = i + 1
		end

		-- Rename the variable to that name
		var:Rename(varIndexToValidVarName(i))

		if var.Scope then
			-- Now we need to mark the name as unusable by any variables:
			--  1) At the same depth that overlap lifetime with this one
			--  2) At a deeper level, which have a reference to this variable in their lifetimes
			--  3) At a shallower level, which are referenced during this variable's lifetime
			for _, otherVar in pairs(allVariables) do
				if not otherVar.Renamed then
					if not otherVar.Scope or otherVar.Scope.Depth < var.Scope.Depth then
						-- Check Global variable (Which is always at a shallower level)
						--  or
						-- Check case 3
						-- The other var is at a shallower depth, is there a reference to it
						-- durring this variable's lifetime?
						for _, refAt in pairs(otherVar.ReferenceLocationList) do
							if refAt >= var.BeginLocation and refAt <= var.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end

					elseif otherVar.Scope.Depth > var.Scope.Depth then
						-- Check Case 2
						-- The other var is at a greater depth, see if any of the references
						-- to this variable are in the other var's lifetime.
						for _, refAt in pairs(var.ReferenceLocationList) do
							if refAt >= otherVar.BeginLocation and refAt <= otherVar.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end

					else --otherVar.Scope.Depth must be equal to var.Scope.Depth
						-- Check case 1
						-- The two locals are in the same scope
						-- Just check if the usage lifetimes overlap within that scope. That is, we
						-- can shadow a local variable within the same scope as long as the usages
						-- of the two locals do not overlap.
						if var.BeginLocation < otherVar.EndLocation and
							var.EndLocation > otherVar.BeginLocation
						then
							otherVar.UsedNameArray[i] = true
						end
					end
				end
			end
		else
			-- This is a global var, all other globals can't collide with it, and
			-- any local variable with a reference to this global in it's lifetime
			-- can't collide with it.
			for _, otherVar in pairs(allVariables) do
				if not otherVar.Renamed then
					if otherVar.Type == 'Global' then
						otherVar.UsedNameArray[i] = true
					elseif otherVar.Type == 'Local' then
						-- Other var is a local, see if there is a reference to this global within
						-- that local's lifetime.
						for _, refAt in pairs(var.ReferenceLocationList) do
							if refAt >= otherVar.BeginLocation and refAt <= otherVar.ScopeEndLocation then
								-- Collide
								otherVar.UsedNameArray[i] = true
								break
							end
						end
					else
						assert(false, "unreachable")
					end
				end
			end
		end
	end


	-- -- 
	-- print("Total Variables: "..#allVariables)
	-- print("Total Range: "..rootScope.BeginLocation.."-"..rootScope.EndLocation)
	-- print("")
	-- for _, var in pairs(allVariables) do
	-- 	io.write("`"..var.Name.."':\n\t#symbols: "..#var.RenameList..
	-- 		"\n\tassigned to: "..tostring(var.AssignedTo))
	-- 	if var.Type == 'Local' then
	-- 		io.write("\n\trange: "..var.BeginLocation.."-"..var.EndLocation)
	-- 		io.write("\n\tlocal type: "..var.Info.Type)
	-- 	end
	-- 	io.write("\n\n")
	-- end

	-- -- First we want to rename all of the variables to unique temoraries, so that we can
	-- -- easily use the scope::GetVar function to check whether renames are valid.
	-- local temporaryIndex = 0
	-- for _, var in pairs(allVariables) do
	-- 	var:Rename('_TMP_'..temporaryIndex..'_')
	-- 	temporaryIndex = temporaryIndex + 1
	-- end

	-- For each variable, we need to build a list of names that collide with it

	--
	--error()
end

return minifyVariables]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6A85A10E717A46F8B06CA98A14DAA0EB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">minifyVariablesBasic</string>
									<string name="ScriptGuid">{05D52D0C-C1DF-4192-9719-8328F7DEE743}</string>
									<ProtectedString name="Source"><![CDATA[local Keywords = require(script.Parent.Keywords)

local generateVariableName = require(script.Parent.generateVariableName)

local function minifyVariables(globalScope, rootScope)
	-- externalGlobals is a set of global variables that have not been assigned to, that is
	-- global variables defined "externally to the script". We are not going to be renaming 
	-- those, and we have to make sure that we don't collide with them when renaming 
	-- things so we keep track of them in this set.
	local externalGlobals = {}

	-- First we want to rename all of the variables to unique temoraries, so that we can
	-- easily use the scope::GetVar function to check whether renames are valid.
	local temporaryIndex = 0
	for _, var in pairs(globalScope) do
		if var.AssignedTo then
			var:Rename('_TMP_'..temporaryIndex..'_')
			temporaryIndex = temporaryIndex + 1
		else
			-- Not assigned to, external global
			externalGlobals[var.Name] = true
		end
	end
	local function temporaryRename(scope)
		for _, var in pairs(scope.VariableList) do
			var:Rename('_TMP_'..temporaryIndex..'_')
			temporaryIndex = temporaryIndex + 1
		end
		for _, childScope in pairs(scope.ChildScopeList) do
			temporaryRename(childScope)
		end
	end

	-- Now we go through renaming, first do globals, we probably want them
	-- to have shorter names in general.
	-- TODO: Rename all vars based on frequency patterns, giving variables
	--       used more shorter names.
	local nextFreeNameIndex = 0
	for _, var in pairs(globalScope) do
		if var.AssignedTo then
			local varName = ''
			repeat
				varName = generateVariableName(nextFreeNameIndex)
				nextFreeNameIndex = nextFreeNameIndex + 1
			until not Keywords[varName] and not externalGlobals[varName]
			var:Rename(varName)
		end
	end

	-- Now rename all local vars
	rootScope.FirstFreeName = nextFreeNameIndex
	local function doRenameScope(scope)
		for _, var in pairs(scope.VariableList) do
			local varName = ''
			repeat
				varName = generateVariableName(scope.FirstFreeName)
				scope.FirstFreeName = scope.FirstFreeName + 1
			until not Keywords[varName] and not externalGlobals[varName]
			var:Rename(varName)
		end
		for _, childScope in pairs(scope.ChildScopeList) do
			childScope.FirstFreeName = scope.FirstFreeName
			doRenameScope(childScope)
		end
	end
	doRenameScope(rootScope)
end

return minifyVariables]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD26C04ACD5A24F4EB30A5147A79386F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">parse</string>
									<string name="ScriptGuid">{02B212CE-E01E-4254-9CFD-01AD63E93404}</string>
									<ProtectedString name="Source"><![CDATA[
local lookupify = require(script.Parent.lookupify)

local BlockFollowKeyword = lookupify{'else', 'elseif', 'until', 'end'}

local UnopSet = lookupify{'-', 'not', '#'}

local BinopSet = lookupify{
	'+', '-', '*', '/', '%', '^', '#',
	'..', '.', ':',
	'>', '<', '<=', '>=', '~=', '==',
	'and', 'or'
}

local AssignmentOperators = lookupify{
	'=', -- Lua 5.1 
	'+=', '-=', '*=', '/=', '^=', '%=', -- Luau
}

local BinaryPriority = {
   ['+'] = {6, 6};
   ['-'] = {6, 6};
   ['*'] = {7, 7};
   ['/'] = {7, 7};
   ['%'] = {7, 7};
   ['^'] = {10, 9};
   ['..'] = {5, 4};
   ['=='] = {3, 3};
   ['~='] = {3, 3};
   ['>'] = {3, 3};
   ['<'] = {3, 3};
   ['>='] = {3, 3};
   ['<='] = {3, 3};
   ['and'] = {2, 2};
   ['or'] = {1, 1};
};
local UnaryPriority = 8

local function parse(tokens)
	-- Pointer into tokens list
	local p = 1

	local function get()
		local tok = tokens[p]
		if p < #tokens then
			p = p + 1
		end
		return tok
	end
	local function peek(n: number | nil)
		n = p + (n or 0)
		return tokens[n] or tokens[#tokens]
	end

	local function getTokenStartPosition(token)
		local line = 1
		local char = 0
		local tkNum = 1
		while true do
			local tk = tokens[tkNum]
			local text;
			if tk == token then
				text = tk.LeadingWhite
			else
				text = tk.LeadingWhite..tk.Source
			end
			for i = 1, #text do
				local c = text:sub(i, i)
				if c == '\n' then
					line = line + 1
					char = 0
				else
					char = char + 1
				end
			end
			if tk == token then
				break
			end
			tkNum = tkNum + 1
		end
		return line..":"..(char+1)
	end
	local function debugMark()
		local tk = peek()
		return "<"..tk.Type.." `"..tk.Source.."`> at: "..getTokenStartPosition(tk)
	end

	local function isBlockFollow()
		local tok = peek()
		return tok.Type == 'Eof' or (tok.Type == 'Keyword' and BlockFollowKeyword[tok.Source])
	end	
	local function isUnop()
		return UnopSet[peek().Source] or false
	end
	local function isBinop()
		return BinopSet[peek().Source] or false
	end
	local function expect(type: string, source: string | nil)
		local tk = peek()
		if tk.Type == type and (source == nil or tk.Source == source) then
			return get()
		else
			for i = -3, 3 do
				print("Tokens["..i.."] = `"..peek(i).Source.."`")
			end
			if source then
				error(getTokenStartPosition(tk)..": `"..source.."` expected.")
			else
				error(getTokenStartPosition(tk)..": "..type.." expected.")
			end
		end
	end

	local function MkNode(node)
		local getf = node.GetFirstToken
		local getl = node.GetLastToken
		function node:GetFirstToken()
			local t = getf(self)
			if not t then
				assert(t, "failed")
			end
			return t
		end
		function node:GetLastToken()
			local t = getl(self)
			assert(t, "failed")
			return t
		end
		return node
	end

	-- Forward decls
	local block;
	local expr;
	local typeexpr;

	-- Expression list
	local function exprlist()
		local exprList = {}
		local commaList = {}
		table.insert(exprList, expr())
		while peek().Source == ',' do
			table.insert(commaList, get())
			table.insert(exprList, expr())
		end
		return exprList, commaList
	end

	local function prefixexpr()
		local tk = peek()
		if tk.Source == '(' then
			local oparenTk = get()
			local inner = expr()
			local cparenTk = expect('Symbol', ')')
			return MkNode{
				Type = 'ParenExpr';
				Expression = inner;
				Token_OpenParen = oparenTk;
				Token_CloseParen = cparenTk;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif tk.Type == 'Ident' then
			return MkNode{
				Type = 'VariableExpr';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		else
			print(debugMark())
			error(getTokenStartPosition(tk)..": Unexpected symbol")
		end
	end

	local function tableexpr()
		local obrace = expect('Symbol', '{')
		local entries: {} = {}
		local separators = {}
		while peek().Source ~= '}' do
			if peek().Source == '[' then
				-- Index
				local obrac = get()
				local index = expr()
				local cbrac = expect('Symbol', ']')
				local eq = expect('Symbol', '=')
				local value = expr()
				table.insert(entries, {
					EntryType = 'Index';
					Index = index;
					Value = value;
					Token_OpenBracket = obrac;
					Token_CloseBracket = cbrac;
					Token_Equals = eq;
				})
			elseif peek().Type == 'Ident' and peek(1).Source == '=' then
				-- Field
				local field = get()
				local eq = get()
				local value = expr()
				table.insert(entries, {
					EntryType = 'Field';
					Field = field;
					Value = value;
					Token_Equals = eq;
				})
			else
				-- Value
				local value = expr()
				table.insert(entries, {
					EntryType = 'Value';
					Value = value;
				})
			end

			-- Comma or Semicolon separator
			if peek().Source == ',' or peek().Source == ';' then
				table.insert(separators, get())
			else
				break
			end
		end
		local cbrace = expect('Symbol', '}')
		return MkNode{
			Type = 'TableLiteral';
			EntryList = entries;
			Token_SeparatorList = separators;
			Token_OpenBrace = obrace;
			Token_CloseBrace = cbrace;
			GetFirstToken = function(self)
				return self.Token_OpenBrace
			end;
			GetLastToken = function(self)
				return self.Token_CloseBrace
			end;
		}
	end

	local function typeExprBasePart()
		if peek().Source == 'typeof' then
			local typeofTk = get()
			local openParen = expect('Symbol', '(')
			local expression = expr()
			local closeParen = expect('Symbol', ')')
			return MkNode{
				Type = 'TypeofType';
				Expression = expression;
				--
				Token_Typeof = typeofTk;
				Token_OpenParen = openParen;
				Token_CloseParen = closeParen;
				GetFirstToken = function(self)
					return self.Token_Typeof
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif peek().Source == '(' then
			-- Tuple type
			local tkOparen = get()
			local types = {}
			local commas = {}
			if peek().Source ~= ')' then
				while true do
					table.insert(types, typeexpr())
					if peek().Source == ',' then
						table.insert(commas, get())
					else
						break
					end
				end
			end
			local tkCparen = expect('Symbol', ')')
			return MkNode{
				Type = 'TupleType';
				TypeList = types;
				--
				Token_OpenParen = tkOparen;
				Token_CommaList = commas;
				Token_CloseParen = tkCparen;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif peek().Source == '{' then
			-- Table type
			local openBrace = get()
			local records: {} = {}
			local commas = {}
			if peek().Source == '[' or peek().Type == 'Ident' then
				while true do
					if peek().Source == '[' then
						-- Field type record
						local openBracket = get()
						local fieldType = typeexpr()
						local closeBracket = expect('Symbol', ']')
						local colon = expect('Symbol', ':')
						local valueType = typeexpr()
						table.insert(records, {
							Type = 'Type';
							KeyType = fieldType;
							ValueType = valueType;
							--
							Token_OpenBracket = openBracket;
							Token_CloseBracket = closeBracket;
							Token_Colon = colon;
						})
					elseif peek().Type == 'Ident' then
						-- Field name record
						local ident = get()
						local colon = expect('Symbol', ':')
						local valueType = typeexpr()
						table.insert(records, {
							Type = 'Name';
							Ident = ident;
							ValueType = valueType;
							--
							Token_Colon = colon;
						})
					else
						error(getTokenStartPosition(peek())..": Type expected, got `"..peek().Source.."`")
					end
					if peek().Source == ',' then
						table.insert(commas, get())
					else
						break
					end
				end
			end
			local closeBrace = expect('Symbol', '}')
			return MkNode{
				Type = 'TableType';
				RecordList = records;
				--
				Token_OpenBrace = openBrace;
				Token_CloseBrace = closeBrace;
				Token_CommaList = commas;
				GetFirstToken = function(self)
					return self.Token_OpenBrace
				end;
				GetLastToken = function(self)
					return self.Token_CloseBrace
				end;
			}
		elseif peek().Source == 'nil' then
			-- nil type
			local nilKw = get()
			return MkNode{
				Type = 'NilType';
				--
				Token_Nil = nilKw;
				GetFirstToken = function(self)
					return self.Token_Nil
				end;
				GetLastToken = function(self)
					return self.Token_Nil
				end;
			}
		elseif peek().Type == 'Ident' then
			-- Basic type
			local identList = {get()}
			local identDotList = {}
			while peek().Source == '.' do
				table.insert(identDotList, get())
				table.insert(identList, expect('Ident'))
			end
			local tkOpenAngle, tkCloseAngle
			local genericArgumentList = {}
			local genericArgumentCommaList = {}
			if peek().Source == '<' then
				tkOpenAngle = get()
				-- Parameterized generic type
				while true do
					table.insert(genericArgumentList, typeexpr())
					if peek().Source == ',' then
						table.insert(genericArgumentCommaList, get())
					else
						break
					end
				end
				if peek().Source == '>=' then
					-- Special handling for `>=` case
					tkCloseAngle = {
						Type = 'Symbol';
						LeadingWhite = peek().LeadingWhite;
						Source = '>';
					}
					peek().Source = '='
					peek().LeadingWhite = ""
				else
					tkCloseAngle = expect('Symbol', '>')
				end
			end
			return MkNode{
				Type = 'BasicType';
				IdentList = identList;
				GenericArgumentList = genericArgumentList;
				--
				Token_IdentDotList = identDotList;
				Token_OpenAngle = tkOpenAngle;
				Token_CloseAngle = tkCloseAngle;
				Token_GenericArgumentCommaList = genericArgumentCommaList;
				GetFirstToken = function(self)
					return self.IdentList[1]
				end;
				GetLastToken = function(self)
					if self.Token_CloseAngle then
						return self.Token_CloseAngle
					else
						return self.IdentList[#self.IdentList]
					end
				end;
			}
		else
			error(getTokenStartPosition(peek())..": Type expected, got `"..peek().Source.."`")
		end
	end

	local function typeExprPart()
		local baseType = typeExprBasePart()
		if peek().Source == '->' then
			-- Is actually a function type
			local tkArrow = get()
			local returnType = typeexpr()
			return MkNode{
				Type = 'FunctionType';
				ArgType = baseType;
				ReturnType = returnType;
				--
				Token_Arrow = tkArrow;
				GetFirstToken = function(self)
					return self.ArgType:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.ReturnType:GetLastToken()
				end;
			}
		elseif peek().Source == '?' then
			return MkNode{
				Type = 'OptionalType';
				BaseType = baseType;
				--
				Token_QuestionMark = get();
				GetFirstToken = function(self)
					return self.BaseType:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Token_QuestionMark
				end;
			}
		else
			return baseType
		end
	end

	function typeexpr()
		local parts = {typeExprPart()}
		local combiners = {}
		local combinersPresent = {}
		while peek().Source == '&' or peek().Source == '|' do
			local combiner = get()
			combinersPresent[combiner.Source] = true
			table.insert(parts, typeExprPart())
			table.insert(combiners, combiner)
		end
		if combinersPresent['&'] and combinersPresent['|'] then
			error(getTokenStartPosition(peek())..": Mixed union and intersection not allowed, must parenthesize")
		end
		if #parts > 1 then
			return MkNode{
				Type = combinersPresent['&'] and 'IntersectionType' or 'UnionType';
				TypeList = parts;
				--
				Token_CombinerList = combiners;
				GetFirstToken = function(self)
					return self.TypeList[1]:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.TypeList[#self.TypeList]:GetLastToken()
				end;
			}
		else
			return parts[1]
		end
	end

	-- List of identifiers
	local function varlist(acceptVarg)
		local varList = {}
		local colonList = {}
		local typeList = {}
		local commaList = {}
		if peek().Type == 'Ident' then
			varList[1] = get()
			if peek().Source == ':' then
				colonList[1] = get()
				typeList[1] = typeexpr()
			end
		elseif peek().Source == '...' and acceptVarg then
			return varList, colonList, typeList, commaList, get()
		end
		while peek().Source == ',' do
			table.insert(commaList, get())
			if peek().Source == '...' and acceptVarg then
				return varList, colonList, typeList, commaList, get()
			else
				local id = expect('Ident')
				table.insert(varList, id)
				if peek().Source == ':' then
					colonList[#varList] = get()
					typeList[#varList] = typeexpr()
				end
			end
		end
		return varList, colonList, typeList, commaList
	end

	-- Body
	local function blockbody(terminator)
		local body = block()
		local after = peek()
		if after.Type == 'Keyword' and after.Source == terminator then
			get()
			return body, after
		else
			print(after.Type, after.Source)
			error(getTokenStartPosition(after)..": "..terminator.." expected.")
		end
	end

	-- Function declaration
	local function funcdecl(isAnonymous)
		local functionKw = get()
		--
		local nameChain;
		local nameChainSeparator;
		--
		if not isAnonymous then
			nameChain = {}
			nameChainSeparator = {}
			--
			table.insert(nameChain, expect('Ident'))
			--
			while peek().Source == '.' do
				table.insert(nameChainSeparator, get())
				table.insert(nameChain, expect('Ident'))
			end
			if peek().Source == ':' then
				table.insert(nameChainSeparator, get())
				table.insert(nameChain, expect('Ident'))
			end
		end
		--
		local oparenTk = expect('Symbol', '(')
		local argList, argColonList, argTypeList, argCommaList, vargToken = varlist(true) --true -> allow varg symbol at end of var list
		local cparenTk = expect('Symbol', ')')
		local colonTk;
		local returnType;
		if peek().Source == ':' then
			colonTk = get()
			returnType = typeexpr()
		end
		--
		local fbody, enTk = blockbody('end')
		--
		return MkNode{
			Type = (isAnonymous and 'FunctionLiteral' or 'FunctionStat');
			NameChain = nameChain;
			ArgList = argList;
			ArgTypeList = argTypeList;
			ReturnType = returnType;
			Body = fbody;
			--
			Token_Function = functionKw;
			Token_NameChainSeparator = nameChainSeparator;
			Token_OpenParen = oparenTk;
			Token_Varg = vargToken;
			Token_ArgColonList = argColonList,
			Token_ArgCommaList = argCommaList;
			Token_CloseParen = cparenTk;
			Token_Colon = colonTk;
			Token_End = enTk;
			GetFirstToken = function(self)
				return self.Token_Function
			end;
			GetLastToken = function(self)
				return self.Token_End;
			end;
		}
	end

	-- Argument list passed to a funciton
	local function functionargs()
		local tk = peek()
		if tk.Source == '(' then
			local oparenTk = get()
			local argList = {}
			local argCommaList = {}
			while peek().Source ~= ')' do
				table.insert(argList, expr())
				if peek().Source == ',' then
					table.insert(argCommaList, get())
				else
					break
				end
			end
			local cparenTk = expect('Symbol', ')')
			return MkNode{
				CallType = 'ArgCall';
				ArgList = argList;
				--
				Token_CommaList = argCommaList;
				Token_OpenParen = oparenTk;
				Token_CloseParen = cparenTk;
				GetFirstToken = function(self)
					return self.Token_OpenParen
				end;
				GetLastToken = function(self)
					return self.Token_CloseParen
				end;
			}
		elseif tk.Source == '{' then
			return MkNode{
				CallType = 'TableCall';
				TableExpr = expr();
				GetFirstToken = function(self)
					return self.TableExpr:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.TableExpr:GetLastToken()
				end;
			}
		elseif tk.Type == 'String' then
			return MkNode{
				CallType = 'StringCall';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		else
			error("Function arguments expected.")
		end
	end

	local function primaryexpr()
		local base = prefixexpr()
		assert(base, "nil prefixexpr")
		while true do
			local tk = peek()
			if tk.Source == '.' then
				local dotTk = get()
				local fieldName = expect('Ident')
				base = MkNode{
					Type = 'FieldExpr';
					Base = base;
					Field = fieldName;
					Token_Dot = dotTk;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.Field
					end;
				}
			elseif tk.Source == ':' then
				local colonTk = get()
				local methodName = expect('Ident')
				local fargs = functionargs()
				base = MkNode{
					Type = 'MethodExpr';
					Base = base;
					Method = methodName;
					FunctionArguments = fargs;
					Token_Colon = colonTk;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.FunctionArguments:GetLastToken()
					end;
				}
			elseif tk.Source == '[' then
				local obrac = get()
				local index = expr()
				local cbrac = expect('Symbol', ']')
				base = MkNode{
					Type = 'IndexExpr';
					Base = base;
					Index = index;
					Token_OpenBracket = obrac;
					Token_CloseBracket = cbrac;
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.Token_CloseBracket
					end;
				}
			elseif tk.Source == '{' or tk.Source == '(' or tk.Type == 'String' then
				base = MkNode{
					Type = 'CallExpr';
					Base = base;
					FunctionArguments = functionargs();
					GetFirstToken = function(self)
						return self.Base:GetFirstToken()
					end;
					GetLastToken = function(self)
						return self.FunctionArguments:GetLastToken()
					end;
				}
			else
				return base
			end
		end
	end

	local function simpleexpr()
		local tk = peek()
		if tk.Type == 'Number' then
			return MkNode{
				Type = 'NumberLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Type == 'String' then
			return MkNode{
				Type = 'StringLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == 'nil' then
			return MkNode{
				Type = 'NilLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == 'true' or tk.Source == 'false' then
			return MkNode{
				Type = 'BooleanLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == '...' then
			return MkNode{
				Type = 'VargLiteral';
				Token = get();
				GetFirstToken = function(self)
					return self.Token
				end;
				GetLastToken = function(self)
					return self.Token
				end;
			}
		elseif tk.Source == '{' then
			return tableexpr()
		elseif tk.Source == 'function' then
			return funcdecl(true)
		else
			return primaryexpr()
		end
	end

	local function subexpr(limit)
		local curNode;

		-- Initial Base Expression
		if isUnop() then
			local opTk = get()
			local ex = subexpr(UnaryPriority)
			curNode = MkNode{
				Type = 'UnopExpr';
				Token_Op = opTk;
				Rhs = ex;
				GetFirstToken = function(self)
					return self.Token_Op
				end;
				GetLastToken = function(self)
					return self.Rhs:GetLastToken()
				end;
			}
		else 
			curNode = simpleexpr()
			assert(curNode, "nil simpleexpr")
		end

		-- Apply Precedence Recursion Chain
		while isBinop() and BinaryPriority[peek().Source][1] > limit do
			local opTk = get()
			local rhs = subexpr(BinaryPriority[opTk.Source][2])
			assert(rhs, "RhsNeeded")
			curNode = MkNode{
				Type = 'BinopExpr';
				Lhs = curNode;
				Rhs = rhs;
				Token_Op = opTk;
				GetFirstToken = function(self)
					return self.Lhs:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Rhs:GetLastToken()
				end;
			}
		end

		-- Return result
		return curNode
	end

	-- Expression
	expr = function()
		return subexpr(0)
	end

	-- Expression statement
	local function exprstat()
		local ex = primaryexpr()
		if ex.Type == 'MethodExpr' or ex.Type == 'CallExpr' then
			-- all good, calls can be statements
			return MkNode{
				Type = 'CallExprStat';
				Expression = ex;
				GetFirstToken = function(self)
					return self.Expression:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Expression:GetLastToken()
				end;
			}
		else
			-- Assignment expr
			local lhs = {ex}
			local lhsSeparator = {}
			while peek().Source == ',' do
				table.insert(lhsSeparator, get())
				local lhsPart = primaryexpr()
				if lhsPart.Type == 'MethodExpr' or lhsPart.Type == 'CallExpr' then
					error("Bad left hand side of assignment")
				end
				table.insert(lhs, lhsPart)
			end
			local eq = get()
			if not AssignmentOperators[eq.Source] then
				error(getTokenStartPosition(eq)..": `=` or compound assigment expected")
			end
			local rhs = {expr()}
			local rhsSeparator = {}
			while peek().Source == ',' do
				table.insert(rhsSeparator, get())
				table.insert(rhs, expr())
			end
			if eq.Source ~= '=' and (#rhs > 1 or #lhs > 1) then
				error(getTokenStartPosition(ex:GetFirstToken())..": Compound assignment statements must operate on single values")
			end
			return MkNode{
				Type = 'AssignmentStat';
				Rhs = rhs;
				Lhs = lhs;
				Token_Equals = eq;
				Token_LhsSeparatorList = lhsSeparator;
				Token_RhsSeparatorList = rhsSeparator;
				GetFirstToken = function(self)
					return self.Lhs[1]:GetFirstToken()
				end;
				GetLastToken = function(self)
					return self.Rhs[#self.Rhs]:GetLastToken()
				end;
			}
		end
	end

	-- If statement
	local function ifstat()
		local ifKw = get()
		local condition = expr()
		local thenKw = expect('Keyword', 'then')
		local ifBody = block()
		local elseClauses = {}
		while peek().Source == 'elseif' or peek().Source == 'else' do
			local elseifKw = get()
			local elseifCondition, elseifThenKw;
			if elseifKw.Source == 'elseif' then
				elseifCondition = expr()
				elseifThenKw = expect('Keyword', 'then')
			end
			local elseifBody = block()
			table.insert(elseClauses, {
				Condition = elseifCondition;
				Body = elseifBody;
				--
				ClauseType = elseifKw.Source;
				Token = elseifKw;
				Token_Then = elseifThenKw;
			})
			if elseifKw.Source == 'else' then
				break
			end
		end
		local enKw = expect('Keyword', 'end')
		return MkNode{
			Type = 'IfStat';
			Condition = condition;
			Body = ifBody;
			ElseClauseList = elseClauses;
			--
			Token_If = ifKw;
			Token_Then = thenKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_If
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- Do statement
	local function dostat()
		local doKw = get()
		local body, enKw = blockbody('end')
		--
		return MkNode{
			Type = 'DoStat';
			Body = body;
			--
			Token_Do = doKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_Do
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- While statement
	local function whilestat()
		local whileKw = get()
		local condition = expr()
		local doKw = expect('Keyword', 'do')
		local body, enKw = blockbody('end')
		--
		return MkNode{
			Type = 'WhileStat';
			Condition = condition;
			Body = body;
			--
			Token_While = whileKw;
			Token_Do = doKw;
			Token_End = enKw;
			GetFirstToken = function(self)
				return self.Token_While
			end;
			GetLastToken = function(self)
				return self.Token_End
			end;
		}
	end

	-- For statement
	local function forstat()
		local forKw = get()
		local loopVars, loopVarColons, loopVarTypes, loopVarCommas = varlist()
		if peek().Source == '=' then
			local eqTk = get()
			local exprList, exprCommaList = exprlist()
			if #exprList < 2 or #exprList > 3 then
				error("expected 2 or 3 values for range bounds")
			end
			local doTk = expect('Keyword', 'do')
			local body, enTk = blockbody('end')
			return MkNode{
				Type = 'NumericForStat';
				VarList = loopVars;
				VarTypeList = loopVarTypes;
				RangeList = exprList;
				Body = body;
				--
				Token_For = forKw;
				Token_VarCommaList = loopVarCommas;
				Token_VarColonList = loopVarColons;
				Token_Equals = eqTk;
				Token_RangeCommaList = exprCommaList;
				Token_Do = doTk;
				Token_End = enTk;
				GetFirstToken = function(self)
					return self.Token_For
				end;
				GetLastToken = function(self)
					return self.Token_End
				end;
			}
		elseif peek().Source == 'in' then
			local inTk = get()
			local exprList, exprCommaList = exprlist()
			local doTk = expect('Keyword', 'do')
			local body, enTk = blockbody('end')
			return MkNode{
				Type = 'GenericForStat';
				VarList = loopVars;
				VarTypeList = loopVarTypes;
				GeneratorList = exprList;
				Body = body;
				--
				Token_For = forKw;
				Token_VarCommaList = loopVarCommas;
				Token_VarColonList = loopVarColons;
				Token_In = inTk;
				Token_GeneratorCommaList = exprCommaList;
				Token_Do = doTk;
				Token_End = enTk;
				GetFirstToken = function(self)
					return self.Token_For
				end;
				GetLastToken = function(self)
					return self.Token_End
				end;
			}
		else
			error("`=` or in expected")
		end
	end

	-- Repeat statement
	local function repeatstat()
		local repeatKw = get()
		local body, untilTk = blockbody('until')
		local condition = expr()
		return MkNode{
			Type = 'RepeatStat';
			Body = body;
			Condition = condition;
			--
			Token_Repeat = repeatKw;
			Token_Until = untilTk;
			GetFirstToken = function(self)
				return self.Token_Repeat
			end;
			GetLastToken = function(self)
				return self.Condition:GetLastToken()
			end;
		}
	end

	-- Local var declaration
	local function localdecl()
		local localKw = get()
		if peek().Source == 'function' then
			-- Local function def
			local funcStat = funcdecl(false)
			if #funcStat.NameChain > 1 then
				error(getTokenStartPosition(funcStat.Token_NameChainSeparator[1])..": `(` expected.")
			end
			return MkNode{
				Type = 'LocalFunctionStat';
				FunctionStat = funcStat;
				Token_Local = localKw;
				GetFirstToken = function(self)
					return self.Token_Local
				end;
				GetLastToken = function(self)
					return self.FunctionStat:GetLastToken()
				end;
			}
		elseif peek().Type == 'Ident' then
			-- Local variable declaration
			local varList, varColonList, varTypeList, varCommaList = varlist()
			local exprList, exprCommaList = {}, {}
			local eqToken;
			if peek().Source == '=' then
				eqToken = get()
				exprList, exprCommaList = exprlist()
			end
			return MkNode{
				Type = 'LocalVarStat';
				VarList = varList;
				TypeList = varTypeList;
				ExprList = exprList;
				Token_Local = localKw;
				Token_Equals = eqToken;
				Token_VarCommaList = varCommaList;
				Token_VarColonList = varColonList;
				Token_ExprCommaList = exprCommaList;	
				GetFirstToken = function(self)
					return self.Token_Local
				end;
				GetLastToken = function(self)
					if #self.ExprList > 0 then
						return self.ExprList[#self.ExprList]:GetLastToken()
					else
						return self.VarList[#self.VarList]
					end
				end;
			}
		else
			error("`function` or ident expected")
		end
	end

	-- Return statement
	local function retstat()
		local returnKw = get()
		local exprList;
		local commaList;
		if isBlockFollow() or peek().Source == ';' then
			exprList = {}
			commaList = {}
		else
			exprList, commaList = exprlist()
		end
		return {
			Type = 'ReturnStat';
			ExprList = exprList;
			Token_Return = returnKw;
			Token_CommaList = commaList;
			GetFirstToken = function(self)
				return self.Token_Return
			end;
			GetLastToken = function(self)
				if #self.ExprList > 0 then
					return self.ExprList[#self.ExprList]:GetLastToken()
				else
					return self.Token_Return
				end
			end;
		}
	end

	-- Break statement
	local function breakstat()
		local breakKw = get()
		return {
			Type = 'BreakStat';
			Token_Break = breakKw;
			GetFirstToken = function(self)
				return self.Token_Break
			end;
			GetLastToken = function(self)
				return self.Token_Break
			end;
		}
	end
	
	-- Continue statement
	local function continuestat()
		local continueKw = get()
		return {
			Type = 'ContinueStat';
			Token_Continue = continueKw;
			GetFirstToken = function(self)
				return self.Token_Continue
			end;
			GetLastToken = function(self)
				return self.Token_Continue
			end;
		}
	end
	
	-- Type statement
	local function typestat()
		local exportKw
		if peek().Source == 'export' then
			exportKw = get()
		end
		local typeKw = expect('Ident', 'type')
		local typeName = expect('Ident')
		local genericTypeList = {}
		local genericTypeCommas = {}
		local openAngle, closeAngle
		local addSyntheticEquals = false
		if peek().Source == '<' then
			openAngle = get()
			while true do
				table.insert(genericTypeList, expect('Ident'))
				if peek().Source == ',' then
					table.insert(genericTypeCommas, get())
				else
					break
				end
			end
			-- Special case handling for the `>=` token. In this context treat it
			-- as separate `>` and `=` tokens instead.
			if peek().Source == '>=' then
				closeAngle = get()
				closeAngle.Source = '>'
				addSyntheticEquals = true
			else
				closeAngle = expect('Symbol', '>')
			end
		end
		local equals
		if addSyntheticEquals then
			equals = {
				Type = 'Symbol';
				Source = '=';
				LeadingWhite = "";
			}
		else
			equals = expect('Symbol', '=')
		end
		local mainType = typeexpr()
		return MkNode{
			Type = 'TypeStat';
			Ident = typeName;
			GenericTypeList = genericTypeList;
			AliasedType = mainType;
			--
			Token_Export = exportKw;
			Token_Type = typeKw;
			Token_OpenAngle = openAngle;
			Token_CloseAngle = closeAngle;
			Token_GenericTypeCommaList = genericTypeCommas;
			Token_Equals = equals;
			GetFirstToken = function(self)
				if self.Token_Export then
					return self.Token_Export
				else
					return self.Token_Type
				end
			end;
			GetLastToken = function(self)
				return self.AliasedType:GetLastToken()
			end;
		}
	end

	-- Expression
	local function statement()
		local tok = peek()
		if tok.Source == 'if' then
			return false, ifstat()
		elseif tok.Source == 'while' then
			return false, whilestat()
		elseif tok.Source == 'do' then
			return false, dostat()
		elseif tok.Source == 'for' then
			return false, forstat()
		elseif tok.Source == 'repeat' then
			return false, repeatstat()
		elseif tok.Source == 'function' then
			return false, funcdecl(false)
		elseif tok.Source == 'local' then
			return false, localdecl()
		elseif tok.Source == 'return' then
			return true, retstat()
		elseif tok.Source == 'break' then
			return true, breakstat()
		elseif tok.Source == 'type' or tok.Source == 'export' then
			return false, typestat()
		elseif tok.Source == 'continue' then
			if peek(1).Source == 'end' or peek(1).Source == ';' then
				return true, continuestat()
			else
				return false, exprstat()
			end
		else
			return false, exprstat()
		end
	end

	-- Chunk
	block = function()
		local statements = {}
		local semicolons = {}
		local isLast = false
		while not isLast and not isBlockFollow() do
			-- Parse statement
			local stat;
			isLast, stat = statement()
			table.insert(statements, stat)
			local next = peek()
			if next.Type == 'Symbol' and next.Source == ';' then
				local semiList = {}
				while next.Type == 'Symbol' and next.Source == ';' do
					table.insert(semiList, get())
					next = peek()
				end
				semicolons[#statements] = semiList
			end
		end
		return {
			Type = 'StatList';
			StatementList = statements;
			SemicolonList = semicolons;
			GetFirstToken = function(self)
				if #self.StatementList == 0 then
					return nil
				else
					return self.StatementList[1]:GetFirstToken()
				end
			end;
			GetLastToken = function(self)
				if #self.StatementList == 0 then
					return nil
				elseif self.SemicolonList[#self.StatementList] then
					-- Last token may be one of the semicolon separators
					local semis = self.SemicolonList[#self.StatementList]
					if semis then
						return semis[#semis]
					end
				else
					return self.StatementList[#self.StatementList]:GetLastToken()
				end
			end;
		}
	end

	return block()
end

return parse]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7BCD2BB4EAC047EF9DE4A8F036AA6AFF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">parse.spec</string>
									<string name="ScriptGuid">{C0578A14-C93C-4581-AD6B-2B68F52A891E}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	
	local function doParse(code)
		parse(tokenize(code))
	end
	
	describe("basic parsing", function()
		it("should parse a basic script", function()
			doParse[[local a = 5]]
		end)
	end)
	
	describe("export types", function()
		it("should parse an export type", function()
			doParse[[export type foo = bar<string>]]
		end)
	end)
	
	describe("typeof types", function()
		it("should let you define a type via typeof", function()
			doParse[[local a: typeof(foo + bar);]]
		end)
	end)
	
	describe("generic type usage", function()
		it("should handle you using a generic type", function()
			doParse[[local n: Thing<number, string> = 6]]
		end)
		
		it("should handle the `>=` case in a local statement", function()
			doParse[[local n: Thing<number>= 6]]
		end)
	end)
	
	describe("type statement", function()
		it("should let you alias a type", function()
			doParse[[type Foo = number]]
		end)

		it("should let you alias a generic type", function()
			doParse[[type Set<T> = {[T]: boolean}]]
		end)

		it("should let you use multiple generic argument", function()
			doParse[[type Map<K,V> = {[K]: V}]]
		end)

		it("should handle the `>=` token correctly", function()
			doParse[[type Generic<T>=T]]
		end)
	end)
	
	describe("nil type", function()
		it("can be used in a type statement", function()
			doParse[[type Foo = nil]]
			doParse[[type FooTable = {[number]: nil}]]
		end)
		
		it("can be used as a type", function()
			doParse[[local a: nil = nil]]
		end)
	end)

	describe("table types", function()
		it("should parse a basic table type", function()
			doParse[[
			local a: {}
			]]
		end)

		it("should parse name fields", function()
			doParse[[
			local a: {a: number, b:string}
			local b: {b: c?}?
			]]
		end)

		it("should parse type fields", function()
			doParse[[
			local b: {[boolean]: number}
			local c: {[string]: string, [() -> boolean]: number} = 5
			]]
		end)
	end)
	
	describe("function types", function()
		it("should parse a function with return type", function()
			doParse[[
			function a(b:c, d:e): (f, g)
			end
			]]
		end)

		it("should parse a function type", function()
			doParse[[
			local a: () -> number
			local b: ((number) -> number);
			]]
		end)
	end)

	describe("typed local declarations", function()
		it("should parse a local declaration without types", function()
			doParse[[
			local a
			local b = 7
			local c, d
			]]
		end)

		it("should parse a local declaration with basic types", function()
			doParse[[
			local a: number = 7
			local b, c: string = 7, "test"
			]]
		end)
	end)
	
	describe("compound assigment", function()
		it("should parse a compound assignment operator", function()
			doParse[[
			a += 1
			a -= 2
			a /= 3
			a *= 4
			a ^= 5
			a %= 6
			]]
		end)
		
		it("should not parse a compound assignment with multiple parts", function()
			expect(function()
				doParse[[
				a, b += 6, 7
				]]
			end).to.throw()
		end)
	end)
	
	describe("continue", function()
		it("should parse a continue statement", function()
			doParse[[
			while true do
				continue
			end
			]]
		end)
		
		it("should parse a continue statement with semis", function()
			doParse[[
			while true do
				continue;;
			end
			]]
		end)
		
		it("should parse a continue call", function()
			doParse[[
			while true do
				continue()
			end
			]]
		end)
		
		it("should parse a continue call with semis", function()
			doParse[[
			while true do
				continue();;
			end
			]]
		end)
		
		it("should accept continue as a variable", function()
			doParse[[local continue = 5]]
		end)
	end)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b0f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX92EB19CB2CDF4DC5B8942585A4037401">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">printAst</string>
									<string name="ScriptGuid">{B8B6F877-5098-46A2-8072-3A1432265CF3}</string>
									<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)

-- Prints out an AST to a string
local function printAst(ast)

	local printStat, printExpr, printType;

	local buffer = ''

	local function printt(tk)
		if not tk.LeadingWhite or not tk.Source then
			error("Bad token: "..formatTable(tk))
		end
		buffer = buffer..tk.LeadingWhite..tk.Source
	end

	printExpr = function(expr)
		if expr.Type == 'BinopExpr' then
			printExpr(expr.Lhs)
			printt(expr.Token_Op)
			printExpr(expr.Rhs)
		elseif expr.Type == 'UnopExpr' then
			printt(expr.Token_Op)
			printExpr(expr.Rhs)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Just print the token
			printt(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			printExpr(expr.Base)
			printt(expr.Token_Dot)
			printt(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			printExpr(expr.Base)
			printt(expr.Token_OpenBracket)
			printExpr(expr.Index)
			printt(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			printExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				printt(expr.Token_Colon)
				printt(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				printt(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				printt(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					printExpr(argExpr)
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						printt(sep)
					end
				end
				printt(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				printExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			printt(expr.Token_Function)
			printt(expr.Token_OpenParen)
			for index, arg in pairs(expr.ArgList) do
				printt(arg)
				local colon = expr.Token_ArgColonList[index]
				if colon then
					printt(colon)
					printType(expr.ArgTypeList[index])
				end
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if expr.Token_Varg then
				printt(expr.Token_Varg)
			end
			printt(expr.Token_CloseParen)
			if expr.Token_Colon then
				printt(expr.Token_Colon)
				printType(expr.ReturnType)
			end
			printStat(expr.Body)
			printt(expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			printt(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			printt(expr.Token_OpenParen)
			printExpr(expr.Expression)
			printt(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			printt(expr.Token_OpenBrace)
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					printt(entry.Field)
					printt(entry.Token_Equals)
					printExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					printt(entry.Token_OpenBracket)
					printExpr(entry.Index)
					printt(entry.Token_CloseBracket)
					printt(entry.Token_Equals)
					printExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					printExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
				local sep = expr.Token_SeparatorList[index]
				if sep then
					printt(sep)
				end
			end
			printt(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end
	
	printType = function(typeExpr)
		if typeExpr.Type == 'BasicType' then
			for i, ident in pairs(typeExpr.IdentList) do
				printt(ident)
				if typeExpr.Token_IdentDotList[i] then
					printt(typeExpr.Token_IdentDotList[i])
				end
			end
			if typeExpr.Token_OpenAngle then
				printt(typeExpr.Token_OpenAngle)
				for index, typeArg in pairs(typeExpr.GenericArgumentList) do
					printType(typeArg)
					if typeExpr.Token_GenericArgumentCommaList[index] then
						printt(typeExpr.Token_GenericArgumentCommaList[index])
					end
				end
				printt(typeExpr.Token_CloseAngle)
			end
		elseif typeExpr.Type == 'NilType' then
			printt(typeExpr.Token_Nil)
		elseif typeExpr.Type == 'TypeofType' then
			printt(typeExpr.Token_Typeof)
			printt(typeExpr.Token_OpenParen)
			printExpr(typeExpr.Expression)
			printt(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'FunctionType' then
			printType(typeExpr.ArgType)
			printt(typeExpr.Token_Arrow)
			printType(typeExpr.ReturnType)
		elseif typeExpr.Type == 'TupleType' then	
			printt(typeExpr.Token_OpenParen)
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				printType(subTypeExpr)
				if typeExpr.Token_CommaList[index] then
					printt(typeExpr.Token_CommaList[index])
				end
			end
			printt(typeExpr.Token_CloseParen)
		elseif typeExpr.Type == 'TableType' then
			printt(typeExpr.Token_OpenBrace)
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					printt(record.Token_OpenBracket)
					printType(record.KeyType)
					printt(record.Token_CloseBracket)
					printt(record.Token_Colon)
					printType(record.ValueType)
				elseif record.Type == 'Name' then
					printt(record.Ident)
					printt(record.Token_Colon)
					printType(record.ValueType)
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
				if typeExpr.Token_CommaList[index] then
					printt(typeExpr.Token_CommaList[index])
				end
			end
			printt(typeExpr.Token_CloseBrace)
		elseif typeExpr.Type == 'OptionalType' then
			printType(typeExpr.BaseType)
			printt(typeExpr.Token_QuestionMark)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				printType(subTypeExpr)
				if typeExpr.Token_CombinerList[index] then
					printt(typeExpr.Token_CombinerList[index])
				end
			end
		else
			assert(false, "unreachable, type: "..typeExpr.Type..":"..formatTable(typeExpr))
		end
	end

	printStat = function(stat)
		if stat.Type == 'StatList' then
			for index, ch in pairs(stat.StatementList) do
				printStat(ch)
				local semis = stat.SemicolonList[index]
				if semis then
					for _, semi in pairs(semis) do
						printt(semi)
					end
				end
			end
		elseif stat.Type == 'BreakStat' then
			printt(stat.Token_Break)
		elseif stat.Type == 'ContinueStat' then
			printt(stat.Token_Continue)
		elseif stat.Type == 'TypeStat' then
			if stat.Token_Export then
				printt(stat.Token_Export)
			end
			printt(stat.Token_Type)
			printt(stat.Ident)
			if stat.Token_OpenAngle then
				printt(stat.Token_OpenAngle)
				for index, ident in pairs(stat.GenericTypeList) do
					printt(ident)
					if stat.Token_GenericTypeCommaList[index] then
						printt(stat.Token_GenericTypeCommaList[index])
					end
				end
				printt(stat.Token_CloseAngle)
			end
			printt(stat.Token_Equals)
			printType(stat.AliasedType)
		elseif stat.Type == 'ReturnStat' then
			printt(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				printExpr(expr)
				if stat.Token_CommaList[index] then
					printt(stat.Token_CommaList[index])
				end
			end
		elseif stat.Type == 'LocalVarStat' then
			printt(stat.Token_Local)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.TypeList[index])
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if stat.Token_Equals then
				printt(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					printExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						printt(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' or stat.Type == 'FunctionStat' then
			if stat.Type == 'LocalFunctionStat' then
				printt(stat.Token_Local)
				stat = stat.FunctionStat
				printt(stat.Token_Function)
				printt(stat.NameChain[1])
			else
				printt(stat.Token_Function)
				for index, part in pairs(stat.NameChain) do
					printt(part)
					local sep = stat.Token_NameChainSeparator[index]
					if sep then
						printt(sep)
					end
				end
			end
			printt(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				printt(arg)
				local colon = stat.Token_ArgColonList[index]
				if colon then
					printt(colon)
					printType(stat.ArgTypeList[index])
				end
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					printt(comma)
				end
			end
			if stat.Token_Varg then
				printt(stat.Token_Varg)
			end
			printt(stat.Token_CloseParen)
			if stat.Token_Colon then
				printt(stat.Token_Colon)
				printType(stat.ReturnType)
			end
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			printt(stat.Token_Repeat)
			printStat(stat.Body)
			printt(stat.Token_Until)
			printExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			printt(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				printExpr(expr)
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			printt(stat.Token_For)
			for index, var in pairs(stat.VarList) do
				printt(var)
				local colon = stat.Token_VarColonList[index]
				if colon then
					printt(colon)
					printType(stat.VarTypeList[index])
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				printExpr(expr)
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'WhileStat' then
			printt(stat.Token_While)
			printExpr(stat.Condition)
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'DoStat' then
			printt(stat.Token_Do)
			printStat(stat.Body)
			printt(stat.Token_End)
		elseif stat.Type == 'IfStat' then
			printt(stat.Token_If)
			printExpr(stat.Condition)
			printt(stat.Token_Then)
			printStat(stat.Body)
			for _, clause in pairs(stat.ElseClauseList) do
				printt(clause.Token)
				if clause.Condition then
					printExpr(clause.Condition)
					printt(clause.Token_Then)
				end
				printStat(clause.Body)
			end
			printt(stat.Token_End)
		elseif stat.Type == 'CallExprStat' then
			printExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				printExpr(ex)
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					printt(sep)
				end
			end
			printt(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				printExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					printt(sep)
				end
			end
		else
			assert(false, "unreachable")
		end	
	end

	printStat(ast)
	
	return buffer
end

return printAst]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b10</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDDB213EB9BF44644BD0243493427FF8E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">printAst.spec</string>
									<string name="ScriptGuid">{7CE80D19-3130-4293-B0A7-EE31A7F455E3}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local printAst = require(script.Parent.printAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	
	describe("formatting", function()
		it("should print back loops with types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("for i: number, j:number in iterator() do end")
			check("for i: number = a, b, c  do end")
		end)
		
		it("should print generic type arguments", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a: FooBar<a, b, c>;")
			check("local a: baz< a, b,c> = 6")
		end)
		
		it("should print back typeof types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("type Foo=typeof(foo + bar)")
			check("local a:typeof(foobar) | {}")
		end)
		
		it("should print back type statements", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("type Foo=number")
			check("type Set<T >= {[T]: boolean}")
			check("type Map<K, V> =Bar")
			check("type Map<K,V>=Bar;;")
		end)
		
		it("should print back table types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a: { }")
			check("local a: {[number]: number}")
			check("local a:{field: value, foo:bar}")
			check("local a:  {field: value, [type]: type}")
		end)

		it("should print complex types", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a:(b)->c")
			check("local a:(b,c?)->d? | e")
			check("local a: (b & c) | d? | (e)->(f | g)?")
		end)

		it("should print local statements", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local a")
			check("local a;")
			check("local a,b,c")
			check("local a:type")
			check("local a, b, c")
			check("local a,b: type = c")
			check("local a, b: type=c")
		end)

		it("should print function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("function a() end")
			check("function a(...) end")
			check("function a(a,b, ...) end")
			check("function a(a:type, c,...): t end")
			check("function a(a:c,e:f) end")
		end)

		it("should print function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local function a() end")
			check("local function a(...) end")
			check("local function a(a,b, ...) end")
			check("local function a(a:type, c,...): t end")
			check("local function a(a:c,e:f) end")
		end)

		it("should print anonymous function arg lists", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("a = function(a,b, ...) end")
			check("a = function(a:type, b): t end")
			check("a = function(a, b:type,...) end")
		end)

		it("should differentiate local and global functions", function()
			local function check(str)
				expect(printAst(parse(tokenize(str)))).to.equal(str)
			end
			check("local function blah() end")
			check("function blah() end")
			check("function a.b.c(arg) end")
		end)
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b11</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX60E2E50AAD35474E997B6FE069523447">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">stripAst</string>
									<string name="ScriptGuid">{7D8A674F-70E5-4AAF-B563-9B2F2F05A2BD}</string>
									<ProtectedString name="Source"><![CDATA[
local formatTable = require(script.Parent.formatTable)
local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

-- Strips as much whitespace off of tokens in an AST as possible without 
local function stripAst(ast)
	local stripStat, stripExpr;

	local function stript(token)
		token.LeadingWhite = ''
	end

	-- Make to adjacent tokens as close as possible
	local function joint(tokenA, tokenB)
		-- Strip the second token's whitespace
		stript(tokenB)

		-- Get the trailing A <-> leading B character pair
		local lastCh = tokenA.Source:sub(-1, -1)
		local firstCh = tokenB.Source:sub(1, 1)

		-- Cases to consider:
		--  Touching minus signs -> comment: `- -42` -> `--42' is invalid
		--  Touching dots: `.. .5` -> `...5` is invalid
		--  Touching words: `a b` -> `ab` is invalid
		--  Touching digits: `2 3`, can't occurr in the Lua syntax as number literals aren't a primary expression
		--  Abiguous syntax: `f(x)\n(x)()` is already disallowed, we can't cause a problem by removing newlines
		--  `>` `=` cannot be merged, because they will become a `>=` token.

		-- Figure out what separation is needed
		if 
			(lastCh == '-' and firstCh == '-') or
			(lastCh == '>' and firstCh == '=') or
			(lastCh == '.' and firstCh == '.') or
			(AllIdentifierCharacters[lastCh] and AllIdentifierCharacters[firstCh]) 
		then
			tokenB.LeadingWhite = ' ' -- Use a separator
		else
			tokenB.LeadingWhite = '' -- Don't use a separator
		end
	end

	-- Join up a statement body and it's opening / closing tokens
	local function bodyjoint(open, body, close)
		stripStat(body)
		stript(close)
		local bodyFirst = body:GetFirstToken()
		local bodyLast = body:GetLastToken()
		if bodyFirst then
			-- Body is non-empty, join body to open / close
			joint(open, bodyFirst)
			joint(bodyLast, close)
		else
			-- Body is empty, just join open and close token together
			joint(open, close)
		end
	end

	stripExpr = function(expr)
		if expr.Type == 'BinopExpr' then
			stripExpr(expr.Lhs)
			stript(expr.Token_Op)
			stripExpr(expr.Rhs)
			-- Handle the `a - -b` -/-> `a--b` case which would otherwise incorrectly generate a comment
			-- Also handles operators "or" / "and" which definitely need joining logic in a bunch of cases
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
			joint(expr.Lhs:GetLastToken(), expr.Token_Op)
		elseif expr.Type == 'UnopExpr' then
			stript(expr.Token_Op)
			stripExpr(expr.Rhs)
			-- Handle the `- -b` -/-> `--b` case which would otherwise incorrectly generate a comment
			joint(expr.Token_Op, expr.Rhs:GetFirstToken())
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- Just print the token
			stript(expr.Token)
		elseif expr.Type == 'FieldExpr' then
			stripExpr(expr.Base)
			stript(expr.Token_Dot)
			stript(expr.Field)
		elseif expr.Type == 'IndexExpr' then
			stripExpr(expr.Base)
			stript(expr.Token_OpenBracket)
			stripExpr(expr.Index)
			stript(expr.Token_CloseBracket)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			stripExpr(expr.Base)
			if expr.Type == 'MethodExpr' then
				stript(expr.Token_Colon)
				stript(expr.Method)
			end
			if expr.FunctionArguments.CallType == 'StringCall' then
				stript(expr.FunctionArguments.Token)
			elseif expr.FunctionArguments.CallType == 'ArgCall' then
				stript(expr.FunctionArguments.Token_OpenParen)
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					stripExpr(argExpr)
					local sep = expr.FunctionArguments.Token_CommaList[index]
					if sep then
						stript(sep)
					end
				end
				stript(expr.FunctionArguments.Token_CloseParen)
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				stripExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			stript(expr.Token_Function)
			stript(expr.Token_OpenParen)
			expr.Token_ArgColonList = {}
			expr.ArgTypeList = {}
			expr.Token_Colon = nil
			expr.ReturnType = nil
			for index, arg in pairs(expr.ArgList) do
				stript(arg)
				local comma = expr.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if expr.Token_Varg then
				stript(expr.Token_Varg)
			end
			stript(expr.Token_CloseParen)
			bodyjoint(expr.Token_CloseParen, expr.Body, expr.Token_End)
		elseif expr.Type == 'VariableExpr' then
			stript(expr.Token)
		elseif expr.Type == 'ParenExpr' then
			stript(expr.Token_OpenParen)
			stripExpr(expr.Expression)
			stript(expr.Token_CloseParen)
		elseif expr.Type == 'TableLiteral' then
			stript(expr.Token_OpenBrace)
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					stript(entry.Field)
					stript(entry.Token_Equals)
					stripExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					stript(entry.Token_OpenBracket)
					stripExpr(entry.Index)
					stript(entry.Token_CloseBracket)
					stript(entry.Token_Equals)
					stripExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					stripExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
				local sep = expr.Token_SeparatorList[index]
				if sep then
					stript(sep)
				end
			end
			-- Trailing separator is never needed, EG: {a = 5; b = 6;} -> {a=5;b=6}
			expr.Token_SeparatorList[#expr.EntryList] = nil
			stript(expr.Token_CloseBrace)
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
	end

	stripStat = function(stat)
		if stat.Type == 'StatList' then
			-- Strip all surrounding whitespace on statement lists along with separating whitespace
			local i = 1
			while i <= #stat.StatementList do
				local chStat = stat.StatementList[i]

				-- Strip the statement and it's whitespace
				local deleted = stripStat(chStat)
				if deleted then
					table.remove(stat.StatementList, i)
					table.remove(stat.SemicolonList, i)
					continue
				end
				stript(chStat:GetFirstToken())

				-- Have max one semicolon between statements
				if stat.SemicolonList[i] then
					stat.SemicolonList[i] = {stat.SemicolonList[i][1]}
				end

				-- If there was a last statement, join them appropriately
				local lastChStat = stat.StatementList[i-1]
				if lastChStat then
					-- See if we can remove a semi-colon, the only case where we can't is if
					-- this and the last statement have a `);(` pair, where removing the semi-colon
					-- would introduce ambiguous syntax.
					if stat.SemicolonList[i-1] and 
						(lastChStat:GetLastToken().Source ~= ')' or chStat:GetFirstToken().Source ~= ')')
					then
						stat.SemicolonList[i-1] = nil
					end

					-- If there isn't a semi-colon, we should safely join the two statements
					-- (If there is one, then no whitespace leading chStat is always okay)
					if stat.SemicolonList[i-1] then
						joint(lastChStat:GetLastToken(), chStat:GetFirstToken())
					end
					
					chStat:GetFirstToken().LeadingWhite = " "
				end

				i += 1
			end

			-- A semi-colon is never needed on the last stat in a statlist:
			stat.SemicolonList[#stat.StatementList] = nil

			-- The leading whitespace on the statlist should be stripped
			if #stat.StatementList > 0 then
				stript(stat.StatementList[1]:GetFirstToken())
			end

		elseif stat.Type == 'BreakStat' then
			stript(stat.Token_Break)

		elseif stat.Type == 'ContinueStat' then
			stript(stat.Token_Continue)

		elseif stat.Type == 'ReturnStat' then
			stript(stat.Token_Return)
			for index, expr in pairs(stat.ExprList) do
				stripExpr(expr)
				if stat.Token_CommaList[index] then
					stript(stat.Token_CommaList[index])
				end
			end
			if #stat.ExprList > 0 then
				joint(stat.Token_Return, stat.ExprList[1]:GetFirstToken())
			end
		elseif stat.Type == 'LocalVarStat' then
			stript(stat.Token_Local)
			stat.Token_VarColonList = {}
			stat.TypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_Local, var)
				else
					stript(var)
				end
				local comma = stat.Token_VarCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.Token_Equals then
				stript(stat.Token_Equals)
				for index, expr in pairs(stat.ExprList) do
					stripExpr(expr)
					local comma = stat.Token_ExprCommaList[index]
					if comma then
						stript(comma)
					end
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			stript(stat.Token_Local)
			stat.FunctionStat.Token_ArgColonList = {}
			stat.FunctionStat.ArgTypeList = {}
			stat.FunctionStat.Token_Colon = nil
			stat.FunctionStat.ReturnType = nil
			joint(stat.Token_Local, stat.FunctionStat.Token_Function)
			joint(stat.FunctionStat.Token_Function, stat.FunctionStat.NameChain[1])
			joint(stat.FunctionStat.NameChain[1], stat.FunctionStat.Token_OpenParen)
			for index, arg in pairs(stat.FunctionStat.ArgList) do
				stript(arg)
				local comma = stat.FunctionStat.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.FunctionStat.Token_Varg then
				stript(stat.FunctionStat.Token_Varg)
			end
			stript(stat.FunctionStat.Token_CloseParen)
			bodyjoint(stat.FunctionStat.Token_CloseParen, stat.FunctionStat.Body, stat.FunctionStat.Token_End)
		elseif stat.Type == 'FunctionStat' then
			stript(stat.Token_Function)
			stat.Token_ArgColonList = {}
			stat.ArgTypeList = {}
			stat.Token_Colon = nil
			stat.ReturnType = nil
			for index, part in pairs(stat.NameChain) do
				if index == 1 then
					joint(stat.Token_Function, part)
				else
					stript(part)
				end
				local sep = stat.Token_NameChainSeparator[index]
				if sep then
					stript(sep)
				end
			end
			stript(stat.Token_OpenParen)
			for index, arg in pairs(stat.ArgList) do
				stript(arg)
				local comma = stat.Token_ArgCommaList[index]
				if comma then
					stript(comma)
				end
			end
			if stat.Token_Varg then
				stript(stat.Token_Varg)
			end
			stript(stat.Token_CloseParen)
			bodyjoint(stat.Token_CloseParen, stat.Body, stat.Token_End)
		elseif stat.Type == 'RepeatStat' then
			stript(stat.Token_Repeat)
			bodyjoint(stat.Token_Repeat, stat.Body, stat.Token_Until)
			stripExpr(stat.Condition)
			joint(stat.Token_Until, stat.Condition:GetFirstToken())
		elseif stat.Type == 'GenericForStat' then
			stript(stat.Token_For)
			stat.Token_VarColonList = {}
			stat.VarTypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_For, var)
				else
					stript(var)
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.VarList[#stat.VarList], stat.Token_In)
			for index, expr in pairs(stat.GeneratorList) do
				stripExpr(expr)
				if index == 1 then
					joint(stat.Token_In, expr:GetFirstToken())
				end
				local sep = stat.Token_GeneratorCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.GeneratorList[#stat.GeneratorList]:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'NumericForStat' then
			stript(stat.Token_For)
			stat.Token_VarColonList = {}
			stat.VarTypeList = {}
			for index, var in pairs(stat.VarList) do
				if index == 1 then
					joint(stat.Token_For, var)
				else
					stript(var)
				end
				local sep = stat.Token_VarCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.VarList[#stat.VarList], stat.Token_Equals)
			for index, expr in pairs(stat.RangeList) do
				stripExpr(expr)
				if index == 1 then
					joint(stat.Token_Equals, expr:GetFirstToken())
				end
				local sep = stat.Token_RangeCommaList[index]
				if sep then
					stript(sep)
				end
			end
			joint(stat.RangeList[#stat.RangeList]:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)	
		elseif stat.Type == 'WhileStat' then
			stript(stat.Token_While)
			stripExpr(stat.Condition)
			stript(stat.Token_Do)
			joint(stat.Token_While, stat.Condition:GetFirstToken())
			joint(stat.Condition:GetLastToken(), stat.Token_Do)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'DoStat' then
			stript(stat.Token_Do)
			stript(stat.Token_End)
			bodyjoint(stat.Token_Do, stat.Body, stat.Token_End)
		elseif stat.Type == 'IfStat' then
			stript(stat.Token_If)
			stripExpr(stat.Condition)
			joint(stat.Token_If, stat.Condition:GetFirstToken())
			joint(stat.Condition:GetLastToken(), stat.Token_Then)
			--
			local lastBodyOpen = stat.Token_Then
			local lastBody = stat.Body
			--
			for _, clause in pairs(stat.ElseClauseList) do
				bodyjoint(lastBodyOpen, lastBody, clause.Token)
				lastBodyOpen = clause.Token
				--
				if clause.Condition then
					stripExpr(clause.Condition)
					joint(clause.Token, clause.Condition:GetFirstToken())
					joint(clause.Condition:GetLastToken(), clause.Token_Then)
					lastBodyOpen = clause.Token_Then
				end
				stripStat(clause.Body)
				lastBody = clause.Body
			end
			--
			bodyjoint(lastBodyOpen, lastBody, stat.Token_End)

		elseif stat.Type == 'CallExprStat' then
			stripExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				stripExpr(ex)
				local sep = stat.Token_LhsSeparatorList[index]
				if sep then
					stript(sep)
				end
			end
			stript(stat.Token_Equals)
			for index, ex in pairs(stat.Rhs) do
				stripExpr(ex)
				local sep = stat.Token_RhsSeparatorList[index]
				if sep then
					stript(sep)
				end
			end
		elseif stat.Type == 'TypeStat' then
			return true
		else
			assert(false, "unreachable")
		end	
	end

	return stripStat(ast)
end

return stripAst]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b12</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2A50D4D1E75D4CA9BEAFA409BCCF0494">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">stripAst.spec</string>
									<string name="ScriptGuid">{FBFF27E4-BB8F-43DB-8DE6-489CD90FACE4}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local stripAst = require(script.Parent.stripAst)
	local tokenize = require(script.Parent.tokenize)
	local parse = require(script.Parent.parse)
	local printAst = require(script.Parent.printAst)
	
	local function doStrip(str)
		local ast = parse(tokenize(str))
		stripAst(ast)
		return printAst(ast)
	end
	
	describe("special cases", function()
		it("should not join `..` and `.5`", function()
			local str = doStrip[[local a = "a" .. .5]]
			expect(str).to.equal[[local a="a".. .5]]
		end)
		
		it("should not join things into a comment", function()
			local str = doStrip[[local a = 5 - -5]]
			expect(str).to.equal[[local a=5- -5]]
		end)
	end)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b13</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX409FFD348EDF4B008392512890E90F5F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">tokenize</string>
									<string name="ScriptGuid">{8DC4D3E0-11A7-4F29-AE60-8B484282AFD4}</string>
									<ProtectedString name="Source"><![CDATA[
--[[
function tokenize(text)

Turn a string containing Lua code into an array of tokens.
]]

local lookupify = require(script.Parent.lookupify)

-- Whitespace characters
local WhitespaceCharacters = require(script.Parent.WhitespaceCharacters)

local CharacterForEscape = {['r'] = '\r', ['n'] = '\n', ['t'] = '\t', ['"'] = '"', ["'"] = "'", ['\\'] = '\\'}

local AllIdentStartChars = lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 
                                     'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 
                                     's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                                     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
                                     'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
                                     'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_'}

local AllIdentifierCharacters = require(script.Parent.AllIdentifierCharacters)

local Keywords = require(script.Parent.Keywords)

local BinaryDigits = lookupify{'0', '1'}
local Digits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
local DigitsPlusSeparator = lookupify{'_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
local HexDigits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
	                            'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'}

local Symbols = lookupify{'+', '-', '*', '/', '^', '%', ',', '{', '}', '[', ']', '(', ')', ';', '#', '.', ':', '?', '|', '&'}

local EqualSymbols = lookupify{
	'~', '=', '>', '<', -- Lua 5.1
	'+', '-', '*', '/', '^', '%', -- Luau
}


local function tokenize(text)
	-- Tracking for the current position in the buffer, and
	-- the current line / character we are on.
	local p = 1
	local length = #text

	-- Output buffer for tokens
	local tokenBuffer = {}

	-- Get a character, or '' if at eof
	local function look(n)
		n = n or 0
		if p <= length then
			return text:sub(p + n, p + n)
		else
			return ''
		end
	end
	local function get()
		if p <= length then
			local c = text:sub(p, p)
			p = p + 1
			return c
		else
			return ''
		end
	end

	-- Error
	local olderr = error
	local function error(str)
		local q = 1
		local line = 1
		local char = 1
		while q <= p do
			if text:sub(q, q) == '\n' then
				line = line + 1
				char = 1
			else
				char = char + 1
			end
			q = q + 1
		end
		-- Toggle for debugging		
		--for _, token in pairs(tokenBuffer) do
		--	print(token.Type.."<"..token.Source..">")
		--end
		olderr("file<"..line..":"..char..">: "..str)
	end

	local function warn(str)
		-- TODO: Maybe record for lints or something?
	end

	-- Consume a long data with equals count of `eqcount'
	local function longdata(eqcount)
		while true do
			local c = get()
			if c == '' then
				error("Unfinished long string.")
			elseif c == ']' then
				local done = true -- Until contested
				for i = 1, eqcount do
					if look() == '=' then
						p = p + 1
					else
						done = false
						break
					end
				end
				if done and get() == ']' then
					return
				end
			end
		end
	end

	-- Get the opening part for a long data `[` `=`* `[`
	-- Precondition: The first `[` has been consumed
	-- Return: nil or the equals count
	local function getopen()
		local startp = p
		while look() == '=' do
			p = p + 1
		end
		if look() == '[' then
			p = p + 1
			return p - startp - 1
		else
			p = startp
			return nil
		end
	end

	-- Add token
	local whiteStart = 1
	local tokenStart = 1
	local function token(type)
		local tk = {
			Type = type;
			LeadingWhite = text:sub(whiteStart, tokenStart-1);
			Source = text:sub(tokenStart, p-1);
		}
		table.insert(tokenBuffer, tk)
		whiteStart = p
		tokenStart = p
		return tk
	end

	-- Parse tokens loop
	while true do
		-- Mark the whitespace start
		whiteStart = p

		-- Get the leading whitespace + comments
		while true do
			local c = look()
			if c == '' then
				break
			elseif c == '-' then
				if look(1) == '-' then
					p = p + 2
					-- Consume comment body
					if look() == '[' then
						p = p + 1
						local eqcount = getopen()
						if eqcount then
							-- Long comment body
							longdata(eqcount)
						else
							-- Normal comment body
							while true do
								local c2 = get()
								if c2 == '' or c2 == '\n' then
									break
								end
							end
						end
					else
						-- Normal comment body
						while true do
							local c2 = get()
							if c2 == '' or c2 == '\n' then
								break
							end
						end
					end
				else
					break
				end
			elseif WhitespaceCharacters[c] then
				p = p + 1
			else
				break
			end
		end
		local leadingWhite = text:sub(whiteStart, p-1)

		-- Mark the token start
		tokenStart = p

		-- Switch on token type
		local c1 = get()
		if c1 == '' then
			-- End of file
			token('Eof')
			break
		elseif c1 == '\'' or c1 == '\"' then
			-- String constant
			while true do
				local c2 = get()
				if c2 == '\\' then
					local c3 = get()
					if c3 == 'x' then
						-- Hexidecimal character
						local c4 = get()
						local c5 = get()
						if not HexDigits[c4] or not HexDigits[c5] then
							error("Invalid Hexidecimal Escape Sequence `\\x"..c4..c5.."`")
						end
					elseif c3 == 'u' then
						-- Unicode character
						local c4 = get()
						if c4 ~= '{' then
							error("Invalid Unicode Escape Sequence `\\u"..c4.."`")
						end
						local codePoint = ""
						while true do
							local cbody = get()
							if cbody == '' then
								error("Unfinished Unicode Escape Sequence at End of File")
							elseif cbody == '}' then
								break
							elseif HexDigits[cbody] then
								codePoint = codePoint..cbody
							else
								error("Invalid Unicode Escape Sequence `\\u{"..codePoint..cbody.."`")
							end
						end
						if codePoint == "" then
							error("Empty Unicode Escape Sequence")
						elseif tonumber(codePoint, 16) >= 0x10FFFF then
							error("Unicode Escape Sequence Out of Range")
						end
					elseif c3 == 'z' then
						-- Whitespace trimmer
						-- Nothing to do					
					else						
						local esc = CharacterForEscape[c3]
						if not esc then
							warn("Invalid Escape Sequence `\\"..c3.."`.")
						end
					end
				elseif c2 == c1 then
					break
				end
			end
			token('String')
		elseif AllIdentStartChars[c1] then
			-- Ident or Keyword
			while AllIdentifierCharacters[look()] do
				p = p + 1
			end
			if Keywords[text:sub(tokenStart, p-1)] then
				token('Keyword')
			else
				token('Ident')
			end
		elseif Digits[c1] or (c1 == '.' and Digits[look()]) then
			-- Note: The character directly after the .
			-- Number
			if c1 == '0' and look():lower() == 'x' then
				p = p + 1
				-- Hex number
				while HexDigits[look()] or look() == '_' do
					p = p + 1
				end
			elseif c1 == '0' and look():lower() == 'b' then
				p = p + 1
				-- Binary number
				while BinaryDigits[look()] or look() == '_' do
					p = p + 1
				end
			else
				-- Normal Number
				while DigitsPlusSeparator[look()] do
					p = p + 1
				end
				if look() == '.' then
					-- With decimal point
					p = p + 1
					while DigitsPlusSeparator[look()] do
						p = p + 1
					end
				end
				if look() == 'e' or look() == 'E' then
					-- With exponent
					p = p + 1
					if look() == '-' then
						p = p + 1
					end
					while DigitsPlusSeparator[look()] do
						p = p + 1
					end
				end
			end
			token('Number')
		elseif c1 == '[' then
			-- '[' Symbol or Long String
			local eqCount = getopen()
			if eqCount then
				-- Long string
				longdata(eqCount)
				token('String')
			else
				-- Symbol
				token('Symbol')
			end
		elseif c1 == '.' then
			-- Greedily consume up to 3 `.` for . / .. / ... tokens
			-- Also consume "..=" compound concatenation operator in this case
			if look() == '.' then
				get()
				if look() == '.' or look() == '=' then
					get()
				end
			end
			token('Symbol')
		elseif c1 == '-' and look() == '>' then
			-- Special handling for `->`
			get()
			token('Symbol')
		elseif EqualSymbols[c1] then
			if look() == '=' then
				get()
			end
			token('Symbol')
		elseif Symbols[c1] then
			token('Symbol')
		else
			error("Bad symbol `"..c1.."` in source.")
		end
	end
	return tokenBuffer
end

return tokenize
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b14</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX30307D460FA64490A76EA525334495A4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">tokenize.spec</string>
									<string name="ScriptGuid">{F909F905-BD87-4D88-A99B-C4AB09186EA9}</string>
									<ProtectedString name="Source"><![CDATA[return function()
	local tokenize = require(script.Parent.tokenize)
	
	describe("tokenize", function()
		it("should succeed with no input", function()
			local output = tokenize("")
		end)
		
		it("should parse a basic input", function()
			local output = tokenize("local a = 5")
			expect(#output).to.equal(5) -- local, a, =, 5, EOF
		end)
	end)
	
	describe("new type related operators", function()
		it("should accept the optional type operator as a token", function()
			local output = tokenize("??")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
		
		it("should accept the union operator as a token", function()
			local output = tokenize("||")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
		
		it("should accept the intersection operator as a token", function()
			local output = tokenize("&&")
			expect(#output).to.equal(3) -- ?, ?, EOF
		end)
	end)
	
	describe("type arrow operator", function()
		it("should parse an arrow as a single token", function()
			local output = tokenize("->->")
			expect(#output).to.equal(3) -- ->, ->, EOF
		end)
	end)
	
	describe("compound operators", function()
		it("should accept Luau compound operators", function()
			local output = tokenize[[+=,-=,%=]]
			expect(#output).to.equal(6)
			local output2 = tokenize[[/=,..=]]
			expect(#output2).to.equal(4)
		end)
	end)
	
	describe("number literals", function()
		it("should accept hexidecimal literals", function()
			tokenize[[0xABC, 0xabc, 0Xabc]]
		end)
		
		it("should accept underscores in number literals", function()
			local output = tokenize[[0xDEAD_BEEF, 100_000, 0x__42__, 0b__0_1_]]
			expect(#output).to.equal(8)
		end)
		
		it("should accept underscores in floating point literals", function()
			local output = tokenize[[.5, 0._7, 12.3_4E_78]]
			expect(#output).to.equal(6)
		end)
	end)
	
	describe("string literals", function()
		it("should parse hex constants", function()
			local output = tokenize[[local a = "\x5A"]]
			expect(#output).to.equal(5)
		end)
		
		it("should fail to parse a bad hex constant", function()
			expect(function()
				local output = tokenize[[local a = "\x5G"]]
			end).to.throw()
		end)
		
		it("should parse unicode constants", function()
			local output = tokenize[[local a = "\u{5Ab}"]]
			expect(#output).to.equal(5)
		end)
		
		it("should fail a unicode constant out of range", function()
			expect(function()
				tokenize[[local a = "\u{6456464}"]]
			end).to.throw()
		end)
		
		it("should fail an empty unicode constant", function()
			expect(function()
				tokenize[[local a = "\u{}"]]
			end).to.throw()
		end)
		
		it("should should fail an unfinished unicode constant", function()
			expect(function()
				tokenize[[local a = "\u{AB"]]
			end).to.throw()
		end)
		
		it("should accept the whitespace trimming escape", function()
			tokenize[[local a = "\z"]]
		end)
		
		it("should accept a bad escape sequence anyways", function()
			-- Lua 5.2+ does not accept the follow, but Lua 5.1 / Luau do
			expect(function()
				tokenize[[local a = "\LOL"]]
			end).never.to.throw()
		end)
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b15</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE798E98709F5466881627EE979B61BDB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">visitAst</string>
									<string name="ScriptGuid">{A4FD71C2-F16B-4594-9257-AA1681E630F6}</string>
									<ProtectedString name="Source"><![CDATA[

local formatTable = require(script.Parent.formatTable)
local lookupify = require(script.Parent.lookupify)

function visitAst(ast, visitors)
	local ExprType = lookupify{
		'BinopExpr'; 'UnopExpr'; 
		'NumberLiteral'; 'StringLiteral'; 'NilLiteral'; 'BooleanLiteral'; 'VargLiteral';
		'FieldExpr'; 'IndexExpr';
		'MethodExpr'; 'CallExpr';
		'FunctionLiteral';
		'VariableExpr';
		'ParenExpr';
		'TableLiteral';
	}

	local StatType = lookupify{
		'StatList';
		'BreakStat';
		'ReturnStat';
		'LocalVarStat';
		'LocalFunctionStat';
		'FunctionStat';
		'RepeatStat';
		'GenericForStat';
		'NumericForStat';
		'WhileStat';
		'DoStat';
		'IfStat';
		'CallExprStat';
		'AssignmentStat';
	}

	-- Check for typos in visitor construction
	for visitorSubject, visitor in pairs(visitors) do
		if not StatType[visitorSubject] and not ExprType[visitorSubject] then
			error("Invalid visitor target: `"..visitorSubject.."`")
		end
	end

	-- Helpers to call visitors on a node
	local function preVisit(exprOrStat)
		local visitor = visitors[exprOrStat.Type]
		if type(visitor) == 'function' then
			return visitor(exprOrStat)
		elseif visitor and visitor.Pre then
			return visitor.Pre(exprOrStat)
		end
	end
	local function postVisit(exprOrStat)
		local visitor = visitors[exprOrStat.Type]
		if visitor and type(visitor) == 'table' and visitor.Post then
			return visitor.Post(exprOrStat)
		end
	end

	local visitExpr, visitStat, visitType;

	visitExpr = function(expr)
		if preVisit(expr) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if expr.Type == 'BinopExpr' then
			visitExpr(expr.Lhs)
			visitExpr(expr.Rhs)
		elseif expr.Type == 'UnopExpr' then
			visitExpr(expr.Rhs)
		elseif expr.Type == 'NumberLiteral' or expr.Type == 'StringLiteral' or 
			expr.Type == 'NilLiteral' or expr.Type == 'BooleanLiteral' or 
			expr.Type == 'VargLiteral' 
		then
			-- No children to visit, single token literals
		elseif expr.Type == 'FieldExpr' then
			visitExpr(expr.Base)
		elseif expr.Type == 'IndexExpr' then
			visitExpr(expr.Base)
			visitExpr(expr.Index)
		elseif expr.Type == 'MethodExpr' or expr.Type == 'CallExpr' then
			visitExpr(expr.Base)
			if expr.FunctionArguments.CallType == 'ArgCall' then
				for index, argExpr in pairs(expr.FunctionArguments.ArgList) do
					visitExpr(argExpr)
				end
			elseif expr.FunctionArguments.CallType == 'TableCall' then
				visitExpr(expr.FunctionArguments.TableExpr)
			end
		elseif expr.Type == 'FunctionLiteral' then
			visitStat(expr.Body)
		elseif expr.Type == 'VariableExpr' then
			-- No children to visit
		elseif expr.Type == 'ParenExpr' then
			visitExpr(expr.Expression)
		elseif expr.Type == 'TableLiteral' then
			for index, entry in pairs(expr.EntryList) do
				if entry.EntryType == 'Field' then
					visitExpr(entry.Value)
				elseif entry.EntryType == 'Index' then
					visitExpr(entry.Index)
					visitExpr(entry.Value)
				elseif entry.EntryType == 'Value' then
					visitExpr(entry.Value)
				else
					assert(false, "unreachable")
				end
			end
		else
			assert(false, "unreachable, type: "..expr.Type..":"..formatTable(expr))
		end
		postVisit(expr)
	end
	
	visitType = function(typeExpr)
		if preVisit(typeExpr) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if typeExpr.Type == 'BasicType' then
			if typeExpr.Token_OpenAngle then
				for _, typeArg in pairs(typeExpr.GenericArgumentList) do
					visitType(typeArg)
				end
			end
		elseif typeExpr.Type == 'TypeofType' then
			visitExpr(typeExpr.Expression)
		elseif typeExpr.Type == 'FunctionType' then
			visitType(typeExpr.ArgType)
			visitType(typeExpr.ReturnType)
		elseif typeExpr.Type == 'TupleType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				visitType(subTypeExpr)
			end
		elseif typeExpr.Type == 'TableType' then
			for index, record in pairs(typeExpr.RecordList) do
				if record.Type == 'Type' then
					visitType(record.KeyType)
					visitType(record.ValueType)
				elseif record.Type == 'Name' then
					visitType(record.ValueType)
				else
					error("Unexpected record in table type: "..formatTable(record))
				end
			end
		elseif typeExpr.Type == 'OptionalType' then
			visitType(typeExpr.BaseType)
		elseif typeExpr.Type == 'UnionType' or typeExpr.Type == 'IntersectionType' then
			for index, subTypeExpr in pairs(typeExpr.TypeList) do
				visitType(subTypeExpr)
			end
		else
			error("Bad typeExpr type in: "..formatTable(typeExpr))
		end
	end

	visitStat = function(stat)
		if preVisit(stat) then
			-- Handler did custom child iteration or blocked child iteration
			return
		end
		if stat.Type == 'StatList' then
			for index, ch in pairs(stat.StatementList) do
				visitStat(ch)
			end
		elseif stat.Type == 'BreakStat' then
			-- No children to visit
		elseif stat.Type == 'ContinueStat' then
			-- No children to visit
		elseif stat.Type == 'ReturnStat' then
			for index, expr in pairs(stat.ExprList) do
				visitExpr(expr)
			end
		elseif stat.Type == 'LocalVarStat' then
			for _, typeExpr in pairs(stat.TypeList) do
				visitType(typeExpr)
			end
			if stat.Token_Equals then
				for index, expr in pairs(stat.ExprList) do
					visitExpr(expr)
				end
			end
		elseif stat.Type == 'LocalFunctionStat' then
			for _, typeExpr in pairs(stat.FunctionStat.ArgTypeList) do
				visitType(typeExpr)
			end
			if stat.FunctionStat.ReturnType then
				visitType(stat.FunctionStat.ReturnType)
			end
			visitStat(stat.FunctionStat.Body)
		elseif stat.Type == 'FunctionStat' then
			for _, typeExpr in pairs(stat.ArgTypeList) do
				visitType(typeExpr)
			end
			if stat.ReturnType then
				visitType(stat.ReturnType)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'RepeatStat' then
			visitStat(stat.Body)
			visitExpr(stat.Condition)
		elseif stat.Type == 'GenericForStat' then
			for _, typeExpr in pairs(stat.VarTypeList) do
				visitType(typeExpr)
			end
			for index, expr in pairs(stat.GeneratorList) do
				visitExpr(expr)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'NumericForStat' then
			for _, typeExpr in pairs(stat.VarTypeList) do
				visitType(typeExpr)
			end
			for index, expr in pairs(stat.RangeList) do
				visitExpr(expr)
			end
			visitStat(stat.Body)
		elseif stat.Type == 'WhileStat' then
			visitExpr(stat.Condition)
			visitStat(stat.Body)
		elseif stat.Type == 'DoStat' then
			visitStat(stat.Body)
		elseif stat.Type == 'IfStat' then
			visitExpr(stat.Condition)
			visitStat(stat.Body)
			for _, clause in pairs(stat.ElseClauseList) do
				if clause.Condition then
					visitExpr(clause.Condition)
				end
				visitStat(clause.Body)
			end
		elseif stat.Type == 'CallExprStat' then
			visitExpr(stat.Expression)
		elseif stat.Type == 'AssignmentStat' then
			for index, ex in pairs(stat.Lhs) do
				visitExpr(ex)
			end
			for index, ex in pairs(stat.Rhs) do
				visitExpr(ex)
			end
		elseif stat.Type == 'TypeStat' then
			visitType(stat.AliasedType)
		else
			assert(false, "unreachable, "..tostring(stat.Type))
		end	
		postVisit(stat)
	end

	if StatType[ast.Type] then
		visitStat(ast)
	else
		visitExpr(ast)
	end
end

return visitAst]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b16</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX7FB4B79059754E278DF80C3F76E751AA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Hashlib</string>
							<string name="ScriptGuid">{55EF143E-6F9A-4B78-8670-85D3BA457A49}</string>
							<ProtectedString name="Source"><![CDATA[--[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

Documentation here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked to port it to Roblox in a way that doesn't overcomplicate it with support of unreachable
cases. Then, howmanysmall did some final optimizations that really squeeze out all the performance possible.
It's gotten stupid fast, thanks to her!

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {};
	[256] = sha2_H_hi;
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {};
	[512] = sha2_H_lo;
}, {
	[384] = {};
	[512] = sha2_H_hi;
}

local md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
local md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3)) + bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10)) + W[j - 7] + W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7)) + bit32_band(e, f) + bit32_band(-1 - e, g) + h + K[j] + W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z + bit32_band(d, c) + bit32_band(a, bit32_bxor(d, c)) + bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 34, 160, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31), bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24), bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)) % 4294967296 +
				bit32_bxor(bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13), bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29), bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)) % 4294967296 +
				W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31), bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24), bit32_rshift(a_hi, 7)) +
				bit32_bxor(bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13), bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29), bit32_rshift(b_hi, 6)) +
				W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18), bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14), bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)) % 4294967296 +
				(bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 +
				h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18), bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14), bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)) +
				bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) +
				h_hi + K_hi[j] + W[jj - 1] +
				(tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo + (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296 + bit32_bxor(bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4), bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2), bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)) % 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi + (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi))) + bit32_bxor(bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4), bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2), bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 25
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 27
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 28
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 26
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi = lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5], lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10], lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15], lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20], lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)), bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)), bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)), bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)), bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)), bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)), bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)), bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)), bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)), bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)), bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)), bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)), bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)), bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)), bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)), bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)), bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)), bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)), bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)), bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)), bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)), bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)), bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)), bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)), bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)), bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)), bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)), bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)), bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)), bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)), bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)), bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)), bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)), bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)), bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)), bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)), bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)), bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)), bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)), bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)), bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0, 0, 1
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1, 2)
				local _, delta = mul(R, mul(R, R, 1, 4), -1, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1, 2)
					_, delta = mul(R, R, -1, 2)
					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				local tailLength = #tail
				if tail ~= "" and tailLength + partLength >= 64 then
					offs = 64 - tailLength
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)

	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi = 0, "", table.pack(table.unpack(sha2_H_ext512_lo[width])), not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296) .. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)

	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)
				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)
				tail = nil

				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(lanes_lo, lanes_hi, tail .. string.sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail .. (#tail + 1 == block_size_in_bytes and string.char(gap_start + 128) or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128")
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296) .. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(table.concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"), qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end

			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62, ["-"] = 62, [62] = "+";
	["/"] = 63, ["_"] = 63, [63] = "/";
	["="] = -1, ["."] = -1, [-1] = "=";
}

local symbol_index = 0
for j, pair in ipairs{"AZ", "az", "09"} do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local stringLength = #binary_string
	local result = table.create(math.ceil(stringLength / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. '\0', 1, -1)
		length = length + 1
		result[length] =
			base64_symbols[math.floor(c1 / 4)] ..
			base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)] ..
			base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1] ..
			base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
--local function pad_and_xor(str, result_length, byte_for_xor)
--	return string.gsub(str, ".", function(c)
--		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
--	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
--end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	local KeyLength = #key
	if KeyLength > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		KeyLength = #key
	end

	local append = hash_func()(string.gsub(key, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), 0x36))
	end) .. string.rep("6", block_size - KeyLength)) -- 6 = string.char(0x36)

	local result

	local function partial(message_part)
		if not message_part then
			result = result or hash_func(
				string.gsub(key, ".", function(c)
					return string.char(bit32_bxor(string.byte(c), 0x5c))
				end) .. string.rep("\\", block_size - KeyLength) -- \ = string.char(0x5c)
				.. (string.gsub(append(), "%x%x", HexToBinFunction))
			)

			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end;

	sha256 = function(message)
		return sha256ext(256, message)
	end;

	sha512_224 = function(message)
		return sha512ext(224, message)
	end;

	sha512_256 = function(message)
		return sha512ext(256, message)
	end;

	sha384 = function(message)
		return sha512ext(384, message)
	end;

	sha512 = function(message)
		return sha512ext(512, message)
	end;

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end;

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end;

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end;

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end;

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end;

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end;

	-- misc utilities:
	hmac = hmac; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin; -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin; -- converts base64 representation to binary string
	bin_to_base64 = bin2base64; -- converts binary string to base64 representation
	base64_encode = Base64.Encode;
	base64_decode = Base64.Decode;
}

block_size_for_HMAC = {
	[sha.md5] = 64;
	[sha.sha1] = 64;
	[sha.sha224] = 64;
	[sha.sha256] = 64;
	[sha.sha512_224] = 128;
	[sha.sha512_256] = 128;
	[sha.sha384] = 128;
	[sha.sha512] = 128;
	[sha.sha3_224] = (1600 - 2 * 224) / 8;
	[sha.sha3_256] = (1600 - 2 * 256) / 8;
	[sha.sha3_384] = (1600 - 2 * 384) / 8;
	[sha.sha3_512] = (1600 - 2 * 512) / 8;
}

return sha]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">310dd1710dcb8bab030416e900030793</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX17E538593CFD4B569CD59BFF991C011E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Base64</string>
								<string name="ScriptGuid">{B5F46E48-7D95-48BB-B5EA-01DCD989476D}</string>
								<ProtectedString name="Source"><![CDATA[-- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

return Base64]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">310dd1710dcb8bab030416e900030794</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX87395FC2E99A40B7B0653FC90D0691A5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Defined</string>
						<string name="ScriptGuid">{16E6FBDA-8E47-40D8-A015-65D758B546E1}</string>
						<ProtectedString name="Source"><![CDATA[local Module = {}

for _, ModuleScript in ipairs( script:GetChildren() ) do
	if ModuleScript:IsA('ModuleScript') then
		Module[ModuleScript.Name] = require(ModuleScript)
	end
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35196d4cdfcd98c1031462fb00031b46</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX72FB6CE8B9CA4814BEACD6159E605CC2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TestDiagram</string>
							<string name="ScriptGuid">{2281001E-15B9-4109-94BD-C79FDEAD56EC}</string>
							<ProtectedString name="Source"><![CDATA[
return {
	{
		ID = "Test1",
		Layer = 1,
		Depends = {}
	},
	{
		ID = "Test2",
		Layer = 2,
		Depends = {"Test1"}
	},
	{
		ID = "Test3",
		Layer = 3,
		Depends = {"Test2"}
	},
	{
		ID = "Test4",
		Layer = 4,
		Depends = {"Test3"}
	},
	{
		ID = "Test5",
		Layer = 4,
		Depends = {"Test3"}
	},
	{
		ID = "Test6",
		Layer = 5,
		Depends = {"Test4"}
	},
	{
		ID = "Test7",
		Layer = 5,
		Depends = {"Test5"}
	},
	{
		ID = "Test8",
		Layer = 6,
		Depends = {"Test6", "Test7", "Test11"}
	},
	{
		ID = "Test9",
		Layer = 7,
		Depends = {"Test8"}
	},
	{
		ID = "Test10",
		Layer = 4,
		Depends = {"Test3"}
	},
	{
		ID = "Test11",
		Layer = 5,
		Depends = {"Test10"}
	},
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35196d4cdfcd98c1031462fb00031b47</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX25ADEE484008431BBFFD224161299145">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseUI</string>
							<string name="ScriptGuid">{10D29723-7F80-4A65-B03C-C646269C2749}</string>
							<ProtectedString name="Source"><![CDATA[
local BASE_UI_SCALE = Instance.new('UIScale')
BASE_UI_SCALE.Name = '_UI_SCALE'
BASE_UI_SCALE.Scale = 1

local BASE_CIRCLE_UI_CORNER = Instance.new('UICorner')
BASE_CIRCLE_UI_CORNER.Name = '_UI_CORNER'
BASE_CIRCLE_UI_CORNER.CornerRadius = UDim.new(0.5, 0)

local BASE_INV_IMAGE_BUTTON = Instance.new('ImageButton')
BASE_INV_IMAGE_BUTTON.Name = 'Button'
BASE_INV_IMAGE_BUTTON.Position = UDim2.fromScale(0.5, 0.5)
BASE_INV_IMAGE_BUTTON.AnchorPoint = Vector2.new(0.5, 0.5)
BASE_INV_IMAGE_BUTTON.Size = UDim2.fromScale(1, 1)
BASE_INV_IMAGE_BUTTON.BackgroundTransparency = 1
BASE_INV_IMAGE_BUTTON.ImageTransparency = 1
BASE_INV_IMAGE_BUTTON.ZIndex = 25

local BASE_UI_PADDING = Instance.new('UIPadding')
BASE_UI_PADDING.Name = '_UI_PADDING'

local BASE_UI_ASPECT_RATIO = Instance.new('UIAspectRatioConstraint')
BASE_UI_ASPECT_RATIO.AspectType = Enum.AspectType.ScaleWithParentSize

-- https://javascript.info/bezier-curve
local function getCubicBezier(p1, p2, p3, p4, alpha)
	return
		math.pow( 1 - alpha, 3 ) * p1 +
		3 * math.pow(1 - alpha, 2) * alpha * p2 +
		3 * (1 - alpha) * math.pow(alpha, 2) * p3 +
		math.pow(alpha, 3) * p4
end

-- // Module // --
local Module = {}

Module.BASE_UI_PADDING = BASE_UI_PADDING
Module.BASE_UI_SCALE = BASE_UI_SCALE
Module.BASE_INV_IMAGE_BUTTON = BASE_INV_IMAGE_BUTTON
Module.BASE_CIRCLE_UI_CORNER = BASE_CIRCLE_UI_CORNER
Module.BASE_UI_ASPECT_RATIO = BASE_UI_ASPECT_RATIO

local baseTreeSelectButton = Instance.new('TextButton') do
	baseTreeSelectButton.Name = 'TreeDataSelectButton'
	baseTreeSelectButton.TextColor3 = Color3.new(0.4, 0.4, 0.4)
	baseTreeSelectButton.BackgroundColor3 = Color3.fromRGB(93, 93, 93)
	baseTreeSelectButton.BackgroundTransparency = 0.8
	baseTreeSelectButton.BorderSizePixel = 0
	BASE_UI_SCALE:Clone().Parent = baseTreeSelectButton
end
Module.baseTreeSelectButton = baseTreeSelectButton

local baseFlowChartContainerFrame = Instance.new('ScrollingFrame') do
	baseFlowChartContainerFrame.BackgroundTransparency = 1
	baseFlowChartContainerFrame.Size = UDim2.fromScale(0.975, 0.975)
	baseFlowChartContainerFrame.Position = UDim2.fromScale(0.5, 0.5)
	baseFlowChartContainerFrame.BorderSizePixel = 0
	baseFlowChartContainerFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	baseFlowChartContainerFrame.ScrollingEnabled = false
	baseFlowChartContainerFrame.ScrollBarThickness = 0
	baseFlowChartContainerFrame.ScrollBarImageTransparency = 1
	baseFlowChartContainerFrame.CanvasSize = UDim2.fromOffset(1200, 700)
	local gridIcon = Instance.new('ImageLabel')
	gridIcon.Name = 'GridIcon'
	gridIcon.BackgroundTransparency = 1
	gridIcon.Size = UDim2.fromScale(1, 1)
	gridIcon.ZIndex = -2
	gridIcon.Image = 'rbxassetid://9446123374'
	gridIcon.ScaleType = Enum.ScaleType.Tile
	gridIcon.TileSize = UDim2.fromOffset(10, 10)
	gridIcon.Parent = baseFlowChartContainerFrame
end
Module.baseFlowChartContainerFrame = baseFlowChartContainerFrame

local baseFlowChartNodeFrame = Instance.new('Frame') do
	baseFlowChartNodeFrame.BackgroundColor3 = Color3.fromRGB(111, 130, 165)
	baseFlowChartNodeFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	baseFlowChartNodeFrame.BackgroundTransparency = 0.05
	baseFlowChartNodeFrame.Size = UDim2.fromOffset(40, 40)
	baseFlowChartNodeFrame.BorderSizePixel = 0
	local flowChartNodeIDLabel = Instance.new('TextLabel')
	flowChartNodeIDLabel.Name = 'IDLabel'
	flowChartNodeIDLabel.BackgroundTransparency = 1
	flowChartNodeIDLabel.Size = UDim2.fromScale(1, 0.2)
	flowChartNodeIDLabel.TextScaled = true
	flowChartNodeIDLabel.TextColor3 = Color3.new(1, 1, 1)
	flowChartNodeIDLabel.Position = UDim2.fromScale(0, 1)
	flowChartNodeIDLabel.Text = 'ID_HERE'
	flowChartNodeIDLabel.Parent = baseFlowChartNodeFrame
	BASE_CIRCLE_UI_CORNER:Clone().Parent = baseFlowChartNodeFrame
	BASE_INV_IMAGE_BUTTON:Clone().Parent = baseFlowChartNodeFrame
end
Module.baseFlowChartNodeFrame = baseFlowChartNodeFrame

local baseLineFrame = Instance.new('Frame')
baseLineFrame.BackgroundTransparency = 0
baseLineFrame.BackgroundColor3 = Color3.new(1, 1, 1)
baseLineFrame.BorderSizePixel = 0
baseLineFrame.ZIndex = -1
function Module:Line(p1, p2)
	local dir = (p2 - p1)
	local length = dir.Magnitude
	local newFrame = baseLineFrame:Clone()
	newFrame.Rotation = math.deg( math.atan2(dir.y, dir.x) )
	newFrame.Size = UDim2.fromOffset(length, 2)
	newFrame.Position = UDim2.fromOffset(p1.x - length, p1.y)
	return newFrame
end

local BEZIER_RESOLUTION = 2 -- frame/pixels
function Module:CubicBezierLine(p1, p2, p3, p4)
	local bezierFrames = {}
	local totalSteps = math.floor((p4 - p1).Magnitude / BEZIER_RESOLUTION)
	local delta = (1 / totalSteps)
	for step = 1, totalSteps do
		local v = (step * delta)
		local vectorA = getCubicBezier(p1, p2, p3, p4, v - delta)
		local vectorB = getCubicBezier(p1, p2, p3, p4, v + delta)
		table.insert(bezierFrames, Module:Line(vectorA, vectorB))
	end
	return bezierFrames
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fe5be13c07d2a200316110500033cb6</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Script" referent="RBX80AF80DC63AB4716B0CFAF7D791B98D0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Plugin</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{9244D2F3-DE1E-4EFD-99EE-D705C288A6CB}</string>
					<ProtectedString name="Source"><![CDATA[
local pluginToolbar = plugin:CreateToolbar("Script Architecture Diagram")

local pluginFolder = script.Parent
local Modules = require(pluginFolder:WaitForChild('Modules'))
local WidgetModule = require(pluginFolder:WaitForChild('Widgets'))

local MaidClass = Modules.Classes.Maid

local ActiveButtonClasses = {}

-- // Class // --
local ButtonClass = {}
ButtonClass.__index = ButtonClass

function ButtonClass.New(widgetClass, buttonId, tooltip, icon_name , text : string?)
	local pluginButton = pluginToolbar:CreateButton(buttonId, tooltip, icon_name, text)

	widgetClass:Toggle(false)
	pluginButton:SetActive(false)

	local self = setmetatable({
		widgetClass = widgetClass,

		pluginButton = pluginButton,
		clickEvent = pluginButton.Click,

		_connections = MaidClass.New(),
	}, ButtonClass)

	self:OnClick(function()
		self:Toggle()
	end)

	table.insert(ActiveButtonClasses, self)

	return self
end

function ButtonClass:Toggle(enabled)
	-- print('toggle ', enabled or (not self.widgetClass.Visible))
	self.pluginButton:SetActive(false)
	if self.widgetClass then
		self.widgetClass:Toggle(enabled)
	end
end

function ButtonClass:OnClick(...)
	local connection = self.clickEvent:Connect(...)
	self._connections:Give(connection)
	return connection
end

function ButtonClass:Destroy()
	-- cleanup click event
	if self.clickEvent then
		self.clickEvent:Disconnect()
		self.clickEvent = nil
	end
	-- plugin button
	if self.pluginButton then
		self.pluginButton:Destroy()
		self.pluginButton = nil
	end
	-- connections cleanup
	if self._connections then
		self._connections:Cleanup()
		self._connections = nil
	end
end

-- // Plugin // --
local pluginMaid = MaidClass.New()

pluginMaid:Give(function()
	-- clear buttons
	for _, buttonClass in ipairs( ActiveButtonClasses ) do
		buttonClass:Destroy()
	end
	ActiveButtonClasses = nil
end)

pluginMaid:Give(plugin.Deactivation:Connect(function()
	pluginMaid:Cleanup()
end))

pluginMaid:Give(plugin.Unloading:Connect(function()
	pluginMaid:Cleanup()
end))

WidgetModule:Init(plugin)
ButtonClass.New(WidgetModule.ParseScript, 'Parse Script', 'This widget is used to parse scripts.', 'rbxassetid://8939587672')
ButtonClass.New(WidgetModule.FlowDiagram, 'Flow Diagram', 'This widget is used to hold diagrams', 'rbxassetid://8939587672')
ButtonClass.New(WidgetModule.NodeInfoDisplay, 'Node Info', 'This widget is used to display node information', 'rbxassetid://8939587672')
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030483</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4EB6020D0B504CDB8EF43C2D624DCEDD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Widgets</string>
					<string name="ScriptGuid">{A8016E4A-3EDB-4045-87D4-68FB6C153EA7}</string>
					<ProtectedString name="Source"><![CDATA[local Module = {}

for _, ModuleScript in ipairs( script:GetChildren() ) do
	if ModuleScript:IsA('ModuleScript') then
		Module[ModuleScript.Name] = require(ModuleScript)
	end
end

function Module:Init(pluginObject)
	for mName, mTable in pairs(Module) do
		if typeof(mTable) ~= 'table' or (not mTable.Init) then
			continue
		end
		local System = {}
		for otherName, otherTable in pairs(Module) do
			if mName == otherName or typeof(otherTable) ~= 'table' then
				continue
			end
			System[otherName] = otherTable
		end
		mTable:Init(System, pluginObject)
	end
end

return Module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030484</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX0E23CB02ACEC48F5893F7B2872DBAE2E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">EmptyWidget</string>
						<string name="ScriptGuid">{00009362-21EE-489A-9B08-0E1F3DC412CC}</string>
						<ProtectedString name="Source"><![CDATA[
local PluginFolder = script.Parent.Parent
local PluginModules = require(PluginFolder.Modules)

local SystemsContainer = {}

-- // Module // --
local Module = {}

Module.WidgetMaid = PluginModules.Classes.Maid.New()
Module.Visible = false
Module.DockWidget = false
Module.plugin = false

function Module:Show()
	Module.DockWidget.Enabled = true
	print(script.Name, 'Show')
end

function Module:Hide()
	Module.DockWidget.Enabled = false
	print(script.Name, 'Hide')
	self.WidgetMaid:Cleanup()
end

function Module:Toggle(forcedValue)
	print(typeof(forcedValue))
	if typeof(forcedValue) == 'boolean' then
		Module.Visible = forcedValue
	else
		Module.Visible = not Module.Visible
	end
	print(Module.Visible)
	if Module.Visible then
		Module:Show()
	else
		Module:Hide()
	end
end

function Module:Destroy()
	print(script.Name, 'Destroy')
end

function Module:Init(otherSystems, plugin)
	SystemsContainer = otherSystems
	Module.plugin = plugin

	local dockWidgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		false, true,
		250, 150, 50, 30
	)

	local dockWidget = plugin:CreateDockWidgetPluginGui(script.Name, dockWidgetInfo)
	dockWidget.Title = script.Name
	dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	dockWidget.Enabled = false
	Module.DockWidget = dockWidget
end

return Module

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00030485</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX364D8A02666B46978892DE76FA041803">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ParseScript</string>
						<string name="ScriptGuid">{7CA26D05-78A4-47F6-BFBF-0D3F3ABEEAF6}</string>
						<ProtectedString name="Source"><![CDATA[
local Selection = game:GetService('Selection')

local PluginFolder = script.Parent.Parent
local PluginModules = require(PluginFolder.Modules)

local NodeTreeContainer = PluginModules.Classes.NodeTree
local ScriptENVParser = PluginModules.Classes.ScriptENVParser

local ScriptUtility = PluginModules.Utility.ScriptUtility

local SystemsContainer = {}

-- // Module // --
local Module = {}

Module.WidgetMaid = PluginModules.Classes.Maid.New()
Module.Visible = false
Module.DockWidget = false
Module.plugin = false

function Module:TokenParseSelections()
	local whitelistClassName = {'LocalScript', 'Script', 'ModuleScript'}
	local parsedInfoArray = {}
	local ScriptInstances = Selection:Get()
	for _, scriptInstance in ipairs( ScriptInstances ) do
		if table.find(whitelistClassName, scriptInstance.ClassName) then
			table.insert(parsedInfoArray, { scriptInstance:GetFullName(), ScriptUtility:RawTokenParse( scriptInstance ) })
		end
	end
	return parsedInfoArray
end

function Module:EnvClassParseTokens(parsedInfoArray, debugPrint)
	for _, t in ipairs( parsedInfoArray ) do
		local scriptPath, tokenDictionary = unpack(t)
		local envParser = ScriptENVParser.New()
		local _ = envParser:ParseTokens(tokenDictionary)
		if debugPrint then
			print(scriptPath)
			envParser:OutputParse() -- DEBUG
			print('\n\n\n')
		end
		table.insert(t, envParser)
	end
	return parsedInfoArray
end

function Module:ParseEnvArraysToNodeJSON(envParserArray)
	-- { {fullScriptPath, tokenDictionary, envParser} }
	local nodeArray = {}
	for _, t in ipairs( envParserArray ) do
		local scriptPath, tokenDictionary, envParser = unpack(t)
		local nodesTable = {}
		table.insert(nodeArray, {scriptPath, nodesTable})
	end
	return nodeArray
end

function Module:ConvertParseInfoArrayToNodeJSON(parsedInfoArray)
	local nodeJSONArray = {}
	--[[
		{
			ID = "Test1",
			Layer = 1,
			Depends = {"Test1"}
		}

		:SetData(node_data)
	]]

	-- SCOPE_VARIABLENAME_VALUETYPE

	local scriptPath, tokenDictionary, envParser = unpack( parsedInfoArray[1] )

	table.insert(nodeJSONArray, {
		ID = "",
		Layer = 1,
		Depends = {},
	})

	--[[
	for _, t in ipairs( parsedInfoArray ) do
		local scriptPath, tokenDictionary, envParser = unpack(t)
		local fromScriptNodeArray = {}

		-- create each node here for each data point

		table.move(fromScriptNodeArray, 1, #fromScriptNodeArray, #nodeJSONArray, nodeJSONArray)
	end]]
	return nodeJSONArray
end

function Module:Show()
	Module.DockWidget.Enabled = true
	-- print(script.Name, 'Show')
end

function Module:Hide()
	Module.DockWidget.Enabled = false
	-- print(script.Name, 'Hide')
	self.WidgetMaid:Cleanup()
end

function Module:Toggle(forcedValue)
	if typeof(forcedValue) == 'boolean' then
		Module.Visible = forcedValue
	else
		Module.Visible = not Module.Visible
	end
	if Module.Visible then
		Module:Show()
	else
		Module:Hide()
	end
end

function Module:Destroy()
	print(script.Name, 'Destroy')
end

function Module:Init(otherSystems, plugin)
	SystemsContainer = otherSystems
	Module.plugin = plugin

	local dockWidgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		true, true,
		250, 150, 50, 30
	)

	local dockWidget = plugin:CreateDockWidgetPluginGui(script.Name, dockWidgetInfo)
	dockWidget.Name = 'ParseScript'
	dockWidget.Title = script.Name
	dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	dockWidget.Enabled = false

	local TriggerButton = Instance.new('TextButton')
	TriggerButton.Name = 'TriggerAction'
	TriggerButton.BackgroundTransparency = 1
	TriggerButton.Size = UDim2.fromScale(1, 1)
	TriggerButton.Position = UDim2.fromScale(0.5, 0.5)
	TriggerButton.AnchorPoint = Vector2.new(0.5, 0.5)
	TriggerButton.ZIndex = 5
	TriggerButton.Text = 'Parse Script Tokens'
	TriggerButton.TextScaled = true
	TriggerButton.Activated:Connect(function()
		local tokenScriptArray = Module:TokenParseSelections()
		local tokenNodeJSON = Module:ConvertParseInfoArrayToNodeJSON(tokenScriptArray)
		local _ = SystemsContainer.FlowDiagram:ParseEnvArraysToNodeJSON(tokenNodeJSON)
		SystemsContainer.FlowDiagramodule:UpdateTabs()
	end)

	local PadUDim = UDim.new(0.05, 0)
	local Padding = Instance.new('UIPadding')
	Padding.PaddingTop = PadUDim
	Padding.PaddingBottom = PadUDim
	Padding.PaddingLeft = PadUDim
	Padding.PaddingLeft = PadUDim
	Padding.Parent = TriggerButton

	TriggerButton.Parent = dockWidget
	Module.DockWidget = dockWidget
end

return Module

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5c33de30e8b23bd60301373a00032b33</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5BAEBDD713574B4B94DA82CB49199E64">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FlowDiagram</string>
						<string name="ScriptGuid">{E572E37E-5772-448E-8602-0F42C03C352B}</string>
						<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService('TweenService')

local PluginFolder = script.Parent.Parent
local Modules = require(PluginFolder.Modules)

local DefinedBaseUI = Modules.Defined.BaseUI

local NodeTreeClassModule = Modules.Classes.NodeTree
local MaidClass = Modules.Classes.Maid

local SystemsContainer = {}

local baseTreeSelectButton = DefinedBaseUI.baseTreeSelectButton
local baseFlowChartContainerFrame = DefinedBaseUI.baseFlowChartContainerFrame
local baseFlowChartNodeFrame = DefinedBaseUI.baseFlowChartNodeFrame

local function UIBezierLine(p1, p2, parentFrame)
	local wasCreated = false
	local hashValue = Modules.Utility.Hashlib.sha256(tostring(p1)..tostring(p2))
	local bezierFolderInstance = parentFrame:FindFirstChild(hashValue)
	if not bezierFolderInstance then
		bezierFolderInstance = Instance.new('Folder')
		bezierFolderInstance.Name = hashValue
		bezierFolderInstance.Parent = parentFrame
		if (p1.x == p2.x) or (p1.y == p2.y) then
			DefinedBaseUI:Line(p1, p2).Parent = bezierFolderInstance
		else
			local dir = (p1 - p2)
			local lineSegments = DefinedBaseUI:CubicBezierLine(p1, Vector2.new(p1.x - (dir.x * 0.375), p1.y), Vector2.new(p2.x + (dir.x * 0.375), p2.y), p2 )
			for _, segment in ipairs( lineSegments ) do
				segment.Parent = bezierFolderInstance
			end
		end
		wasCreated = true
	end
	return bezierFolderInstance, wasCreated
end

-- // Module // --
local Module = {}

Module.Visible = false
Module.plugin = false

Module.WidgetMaid = MaidClass.New()
Module.DockWidget = false
Module.TreeSelectFrame = false
Module.SeparatorFrame = false
Module.FlowChartFrame = false

Module.ActiveTrees = {}
Module.ButtonToTreeFrame = {}

function Module:GetNodeFrame(nodeClass, FlowChartFrame)
	local Frame = FlowChartFrame:FindFirstChild(nodeClass.ID)
	if not Frame then
		Frame = baseFlowChartNodeFrame:Clone()
		Frame.Position = UDim2.fromOffset(nodeClass.x, nodeClass.y)
		print(Frame.Button:GetFullName())
		Frame.IDLabel.Text = nodeClass.ID
		Frame.Button.Activated:Connect(function()
			print(nodeClass.ID)
			SystemsContainer.NodeInfoDisplay:DisplayNodeData(nodeClass)
		end)
		Frame.ZIndex = 2
		Frame.Parent = FlowChartFrame
	end
	return Frame
end

function Module:UpdateFramesInFlowChart( baseTreeClass, FlowChartFrame )
	print(FlowChartFrame:GetFullName(), #baseTreeClass.nodes)

	for _, nodeClass in ipairs( baseTreeClass.nodes ) do
		for _, dependID in ipairs( nodeClass.depends ) do
			local dependantNodeClass = baseTreeClass:GetNodeFromID(dependID)
			UIBezierLine(
				Vector2.new(nodeClass.x, nodeClass.y),
				Vector2.new(dependantNodeClass.x, dependantNodeClass.y),
				FlowChartFrame
			)
		end
	end

	for _, nodeClass in ipairs( baseTreeClass.nodes ) do
		Module:GetNodeFrame(nodeClass, FlowChartFrame)
	end
end

function Module:SetupChartInputMechanics( targetFrame : ScrollingFrame )
	assert(typeof(targetFrame) == 'Instance' and targetFrame:IsA('ScrollingFrame'), 'Passed targetFrame is not a ScrollingFrame!')

	local Holding, LastXY = false, Vector2.new(0, 0)
	local MaidInstance = MaidClass.New()

	local UIScaleInstance = Instance.new('UIScale')
	UIScaleInstance.Parent = targetFrame

	MaidInstance:Give(targetFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			Holding = true
		end
	end))

	MaidInstance:Give(targetFrame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			local newXY = Vector2.new(input.Position.X, input.Position.Y)
			if Holding then
				local delta = (newXY-LastXY)
				targetFrame.CanvasPosition += delta
			end
			LastXY = newXY
		elseif input.UserInputType == Enum.UserInputType.MouseWheel then
			local nextScale = UIScaleInstance.Scale + (input.Position.Z * 0.05)
			UIScaleInstance.Scale = math.clamp(nextScale, 0.1, 2)
		end
	end))

	MaidInstance:Give(targetFrame.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			Holding = false
		end
	end))

	MaidInstance:Give(targetFrame.Destroying:Connect(function()
		MaidInstance:Cleanup()
	end))

	MaidInstance:Give(UIScaleInstance)
end

function Module:GetFlowChartFrame(baseTreeClass)
	local targetFrame = Module.FlowChartFrame:FindFirstChild(baseTreeClass.name)
	if not targetFrame then
		targetFrame = baseFlowChartContainerFrame:Clone()
		targetFrame.Name = baseTreeClass.name
		targetFrame.Visible = false
		Module:SetupChartInputMechanics( targetFrame )
		targetFrame.Parent = Module.FlowChartFrame
	end
	return targetFrame
end

function Module:ToggleFrame(targetFrame)
	for ButtonFrame, FlowFrame in pairs(Module.ButtonToTreeFrame) do
		local IsVisible = (FlowFrame == targetFrame) and (not FlowFrame.Visible) or false
		FlowFrame.Visible = IsVisible
		ButtonFrame.TextColor3 = IsVisible and Color3.new(1, 1, 1) or Color3.new(0.4, 0.4, 0.4)
	end
end

function Module:GetCategorySelectButton(baseTreeClass, targetFrame)
	local categoryButton = Module.TreeSelectFrame:FindFirstChild(baseTreeClass.name)
	if not categoryButton then
		categoryButton = baseTreeSelectButton:Clone()
		categoryButton.Name = baseTreeClass.name
		categoryButton.MouseEnter:Connect(function()
			TweenService:Create(categoryButton._UI_SCALE, TweenInfo.new(0.25), {Scale = 1.05}):Play()
		end)
		categoryButton.MouseLeave:Connect(function()
			TweenService:Create(categoryButton._UI_SCALE, TweenInfo.new(0.25), {Scale = 1}):Play()
		end)
		categoryButton.Activated:Connect(function()
			Module:ToggleFrame(targetFrame)
		end)
		categoryButton.Parent = Module.TreeSelectFrame
	end
	categoryButton.LayoutOrder = #baseTreeClass.nodes
	return categoryButton
end

function Module:UpdateFrames()
	for _, baseTreeClass in ipairs( Module.ActiveTrees ) do
		if not baseTreeClass.visible then
			continue
		end
		local TreeFrame = Module:GetFlowChartFrame(baseTreeClass)
		local TreeButton = Module:GetCategorySelectButton(baseTreeClass, TreeFrame)
		if TreeButton then
			Module:UpdateFramesInFlowChart(baseTreeClass, TreeFrame)
			Module.ButtonToTreeFrame[TreeButton] = TreeFrame
		end
	end
end

function Module:LoadNodeArray( nodeArray )
	local baseTreeClass = NodeTreeClassModule.TreeData.New()
	-- baseTreeClass.IDToNode
	-- baseTreeClass.LayerZToNodeMap
	-- baseTreeClass.nodes
	-- return IDToNode, LayerZToNodeMap, NodesArray
	return baseTreeClass
end

function Module:LoadNodeJSON( nodeJSONArray )
	local baseTreeClass = NodeTreeClassModule.TreeData.New()
	baseTreeClass:LoadNodes( nodeJSONArray )
	baseTreeClass.visible = true
	table.insert(Module.ActiveTrees, baseTreeClass)
	return baseTreeClass
end

function Module:UpdateTabs()
	-- change tab highlights / visibility and stuff
	for TreeButton, TreeFrame in pairs(Module.ButtonToTreeFrame) do
		if not TreeFrame:IsDescendantOf(Module.FlowChartFrame) then
			TreeButton:Destroy()
		end
	end
	-- update the frames
	Module:UpdateFrames()
	if not Module.FirstRun and #Module.ActiveTrees > 0 then
		Module.FirstRun = true
		Module:ToggleFrame(Module.FlowChartFrame:FindFirstChildWhichIsA('Frame'))
	end
end

function Module:Show()
	Module.DockWidget.Enabled = true
	-- print(script.Name, 'Show')
	-- self.WidgetMaid:Give()
	-- Module.TreeSelectFrame
	-- Module.SeparatorFrame
	-- Module.FlowChartFrame
end

function Module:Hide()
	Module.DockWidget.Enabled = false
	-- print(script.Name, 'Hide')
	self.WidgetMaid:Cleanup()
end

function Module:Toggle(forcedValue)
	if typeof(forcedValue) == 'boolean' then
		Module.Visible = forcedValue
	else
		Module.Visible = not Module.Visible
	end
	if Module.Visible then
		Module:Show()
	else
		Module:Hide()
	end
end

function Module:Destroy()
	print(script.Name, 'Destroy')
end

function Module:Init(otherSystems, plugin)
	print(otherSystems)
	SystemsContainer = otherSystems
	Module.plugin = plugin

	local dockWidgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		true, true,
		600, 400, 600, 400
	)

	local dockWidget = plugin:CreateDockWidgetPluginGui(script.Name, dockWidgetInfo) :: DockWidgetPluginGui
	dockWidget.Name = 'FlowDiagram'
	dockWidget.Title = script.Name
	dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	dockWidget.Enabled = false
	Module.DockWidget = dockWidget

	do
		local BackgroundFrame = Instance.new('Frame')
		BackgroundFrame.Name = 'BackgroundFrame'
		BackgroundFrame.BorderSizePixel = 0
		BackgroundFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
		BackgroundFrame.Size = UDim2.fromScale(1, 1)
		BackgroundFrame.ZIndex = 0
		BackgroundFrame.Parent = dockWidget
	end

	local ContainerFrame = Instance.new('Frame')
	ContainerFrame.Name = 'ContainerFrame'
	ContainerFrame.BackgroundTransparency = 1
	ContainerFrame.Size = UDim2.fromScale(1, 1)
	ContainerFrame.ZIndex = 1
	ContainerFrame.Parent = dockWidget

	local SeparatorFrame = Instance.new('Frame')
	SeparatorFrame.Name = 'SeparatorFrame'
	SeparatorFrame.BorderSizePixel = 0
	SeparatorFrame.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	SeparatorFrame.Size = UDim2.fromScale(0.05, 1)
	SeparatorFrame.Position = UDim2.fromScale(0.2, 0)
	SeparatorFrame.ZIndex = 0
	SeparatorFrame.Parent = ContainerFrame
	self.SeparatorFrame = SeparatorFrame

	local FlowChartFrame = Instance.new('Frame')
	FlowChartFrame.Name = 'FlowChartFrame'
	FlowChartFrame.BorderSizePixel = 0
	FlowChartFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
	FlowChartFrame.Size = UDim2.fromScale(0.795, 1)
	FlowChartFrame.Position = UDim2.fromScale(0.205, 0)
	FlowChartFrame.ZIndex = 0
	FlowChartFrame.Parent = ContainerFrame
	self.FlowChartFrame = FlowChartFrame

	-- Select Tree Frame
	local TreeSelectFrame = Instance.new('Frame')
	TreeSelectFrame.Name = 'TreeSelectFrame'
	TreeSelectFrame.BorderSizePixel = 0
	TreeSelectFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
	TreeSelectFrame.Size = UDim2.fromScale(0.2, 1)
	TreeSelectFrame.ZIndex = 0
	TreeSelectFrame.Parent = ContainerFrame
	self.TreeSelectFrame = TreeSelectFrame
	local TreeSelectGridLayout  = Instance.new('UIGridLayout')
	TreeSelectGridLayout.CellPadding = UDim2.fromScale(0, 0.01)
	TreeSelectGridLayout.CellSize = UDim2.fromScale(1, 0.1)
	TreeSelectGridLayout.Parent = TreeSelectFrame
	local TreeSelectAspectRatio = DefinedBaseUI.BASE_UI_ASPECT_RATIO:Clone()
	TreeSelectAspectRatio.AspectRatio = 3.5
	TreeSelectAspectRatio.Parent = TreeSelectGridLayout
	local TreeSelectUIPadding = DefinedBaseUI.BASE_UI_PADDING:Clone()
	TreeSelectUIPadding.PaddingTop = UDim.new(0.01, 0)
	TreeSelectUIPadding.PaddingLeft = UDim.new(0.02, 0)
	TreeSelectUIPadding.PaddingRight = UDim.new(0.02, 0)
	TreeSelectUIPadding.Parent = TreeSelectFrame

	local _ = Module:LoadNodeJSON( Modules.Defined.TestDiagram )
	Module:UpdateTabs()
	Module:Toggle(true)
end

return Module


]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">310dd1710dcb8bab030416e90003079e</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4677A0574CC64768AFAF3D9BD391FEDF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NodeInfoDisplay</string>
						<string name="ScriptGuid">{AC372DDB-9E29-4F79-9ADF-9ECD12924F5A}</string>
						<ProtectedString name="Source"><![CDATA[
local PluginFolder = script.Parent.Parent
local PluginModules = require(PluginFolder.Modules)

local SystemsContainer = {}

-- // Module // --
local Module = {}

Module.WidgetMaid = PluginModules.Classes.Maid.New()
Module.Visible = false
Module.DockWidget = false
Module.plugin = false

function Module:DisplayNodeData(nodeClass)
	print(nodeClass)
end

function Module:Show()
	Module.DockWidget.Enabled = true
	print(script.Name, 'Show')
end

function Module:Hide()
	Module.DockWidget.Enabled = false
	print(script.Name, 'Hide')
	self.WidgetMaid:Cleanup()
end

function Module:Toggle(forcedValue)
	print(typeof(forcedValue))
	if typeof(forcedValue) == 'boolean' then
		Module.Visible = forcedValue
	else
		Module.Visible = not Module.Visible
	end
	print(Module.Visible)
	if Module.Visible then
		Module:Show()
	else
		Module:Hide()
	end
end

function Module:Destroy()
	print(script.Name, 'Destroy')
end

function Module:Init(otherSystems, plugin)
	SystemsContainer = otherSystems
	Module.plugin = plugin

	local dockWidgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		true, true,
		250, 250, 250, 250
	)

	local dockWidget = plugin:CreateDockWidgetPluginGui(script.Name, dockWidgetInfo)
	dockWidget.Name = 'NodeInfoDisplay'
	dockWidget.Title = script.Name
	dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	dockWidget.Enabled = false
	Module.DockWidget = dockWidget

	do
		local BackgroundFrame = Instance.new('Frame')
		BackgroundFrame.Name = 'BackgroundFrame'
		BackgroundFrame.BorderSizePixel = 0
		BackgroundFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
		BackgroundFrame.Size = UDim2.fromScale(1, 1)
		BackgroundFrame.ZIndex = 0
		BackgroundFrame.Parent = dockWidget
	end
end

return Module

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fe5be13c07d2a200316110500033cb8</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX18A011D79AB941C489F3331158DA901F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">BackupStorage</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">310dd1710dcb8bab030416e900030797</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX68B5C7638596430AAE2BCCF813F61AD1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Data</string>
						<string name="ScriptGuid">{29D2CC22-FD9C-4A2C-8706-02BA2DD983EC}</string>
						<ProtectedString name="Source"><![CDATA[return {
	["GetFirstToken"] = "function",
	["GetLastToken"] = "function",
	["SemicolonList"] = {},
	["StatementList"] =  {
		[1] =  {
			["Expression"] =  {
				["Base"] =  {
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token"] =  {
						["LeadingWhite"] = "",
						["Source"] = "warn",
						["Type"] = "Ident"
					},
					["Type"] = "VariableExpr"
				},
				["FunctionArguments"] =  {
					["ArgList"] =  {
						[1] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Token"] =  {
								["LeadingWhite"] = "",
								["Source"] = "'Character visuals - masks / gun skins / perks / etc'",
								["Type"] = "String"
							},
							["Type"] = "StringLiteral"
						}
					},
					["CallType"] = "ArgCall",
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseParen"] =  {
						["LeadingWhite"] = "",
						["Source"] = ")",
						["Type"] = "Symbol"
					},
					["Token_CommaList"] = {},
					["Token_OpenParen"] =  {
						["LeadingWhite"] = "",
						["Source"] = "(",
						["Type"] = "Symbol"
					}
				},
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["Type"] = "CallExpr"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Type"] = "CallExprStat"
		},
		[2] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Players'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Players",
					["Type"] = "Ident"
				}
			}
		},
		[3] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Teams'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Teams",
					["Type"] = "Ident"
				}
			}
		},
		[4] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "game",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'ReplicatedStorage'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "GetService",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedStorage",
					["Type"] = "Ident"
				}
			}
		},
		[5] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "ReplicatedStorage",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "'Assets'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Method"] =  {
						["LeadingWhite"] = "",
						["Source"] = "WaitForChild",
						["Type"] = "Ident"
					},
					["Token_Colon"] =  {
						["LeadingWhite"] = "",
						["Source"] = ":",
						["Type"] = "Symbol"
					},
					["Type"] = "MethodExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedAssets",
					["Type"] = "Ident"
				}
			}
		},
		[6] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "require",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedStorage",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "WaitForChild",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Type"] = "CallExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedCore",
					["Type"] = "Ident"
				}
			}
		},
		[7] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "require",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["FunctionArguments"] =  {
						["ArgList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedStorage",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "WaitForChild",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["CallType"] = "ArgCall",
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_CloseParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = ")",
							["Type"] = "Symbol"
						},
						["Token_CommaList"] = {},
						["Token_OpenParen"] =  {
							["LeadingWhite"] = "",
							["Source"] = "(",
							["Type"] = "Symbol"
						}
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Type"] = "CallExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedModules",
					["Type"] = "Ident"
				}
			}
		},
		[8] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "ReplicatedCore",
							["Type"] = "Ident"
						},
						["Type"] = "VariableExpr"
					},
					["Field"] =  {
						["LeadingWhite"] = "",
						["Source"] = "ReplicatedData",
						["Type"] = "Ident"
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_Dot"] =  {
						["LeadingWhite"] = "",
						["Source"] = ".",
						["Type"] = "Symbol"
					},
					["Type"] = "FieldExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ReplicatedData",
					["Type"] = "Ident"
				}
			}
		},
		[9] =  {
			["ExprList"] =  {
				[1] =  {
					["Base"] =  {
						["Base"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Token"] =  {
								["LeadingWhite"] = " ",
								["Source"] = "ReplicatedModules",
								["Type"] = "Ident"
							},
							["Type"] = "VariableExpr"
						},
						["Field"] =  {
							["LeadingWhite"] = "",
							["Source"] = "Defined",
							["Type"] = "Ident"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Dot"] =  {
							["LeadingWhite"] = "",
							["Source"] = ".",
							["Type"] = "Symbol"
						},
						["Type"] = "FieldExpr"
					},
					["Field"] =  {
						["LeadingWhite"] = "",
						["Source"] = "Items",
						["Type"] = "Ident"
					},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_Dot"] =  {
						["LeadingWhite"] = "",
						["Source"] = ".",
						["Type"] = "Symbol"
					},
					["Type"] = "FieldExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "ItemsModule",
					["Type"] = "Ident"
				}
			}
		},
		[10] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "SystemsContainer",
					["Type"] = "Ident"
				}
			}
		},
		[11] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "CharacterCache",
					["Type"] = "Ident"
				}
			}
		},
		[12] =  {
			["ExprList"] =  {
				[1] =  {
					["EntryList"] = {},
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token_CloseBrace"] =  {
						["LeadingWhite"] = "",
						["Source"] = "}",
						["Type"] = "Symbol"
					},
					["Token_OpenBrace"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "{",
						["Type"] = "Symbol"
					},
					["Token_SeparatorList"] = {},
					["Type"] = "TableLiteral"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_Equals"] =  {
				["LeadingWhite"] = " ",
				["Source"] = "=",
				["Type"] = "Symbol"
			},
			["Token_ExprCommaList"] = {},
			["Token_Local"] =  {
				["LeadingWhite"] = "",
				["Source"] = "local",
				["Type"] = "Keyword"
			},
			["Token_VarColonList"] = {},
			["Token_VarCommaList"] = {},
			["Type"] = "LocalVarStat",
			["TypeList"] = {},
			["VarList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				}
			}
		},
		[13] =  {
			["ArgList"] = {},
			["ArgTypeList"] = {},
			["Body"] =  {
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["SemicolonList"] = {},
				["StatementList"] =  {
					[1] =  {
						["ExprList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "ReplicatedData",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Method"] =  {
									["LeadingWhite"] = "",
									["Source"] = "GetData",
									["Type"] = "Ident"
								},
								["Token_Colon"] =  {
									["LeadingWhite"] = "",
									["Source"] = ":",
									["Type"] = "Symbol"
								},
								["Type"] = "MethodExpr"
							}
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Equals"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "=",
							["Type"] = "Symbol"
						},
						["Token_ExprCommaList"] = {},
						["Token_Local"] =  {
							["LeadingWhite"] = "",
							["Source"] = "local",
							["Type"] = "Keyword"
						},
						["Token_VarColonList"] = {},
						["Token_VarCommaList"] = {},
						["Type"] = "LocalVarStat",
						["TypeList"] = {},
						["VarList"] =  {
							[1] =  {
								["LeadingWhite"] = " ",
								["Source"] = "renderData",
								["Type"] = "Ident"
							}
						}
					},
					[2] =  {
						["Body"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["SemicolonList"] = {},
							["StatementList"] =  {
								[1] =  {
									["ExprList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CommaList"] = {},
									["Token_Return"] =  {
										["LeadingWhite"] = "",
										["Source"] = "return",
										["Type"] = "Keyword"
									},
									["Type"] = "ReturnStat"
								}
							},
							["Type"] = "StatList"
						},
						["Condition"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Lhs"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "typeof",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Type"] = "CallExpr"
							},
							["Rhs"] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = " ",
									["Source"] = "'table'",
									["Type"] = "String"
								},
								["Type"] = "StringLiteral"
							},
							["Token_Op"] =  {
								["LeadingWhite"] = " ",
								["Source"] = "~=",
								["Type"] = "Symbol"
							},
							["Type"] = "BinopExpr"
						},
						["ElseClauseList"] = {},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_End"] =  {
							["LeadingWhite"] = "",
							["Source"] = "end",
							["Type"] = "Keyword"
						},
						["Token_If"] =  {
							["LeadingWhite"] = "",
							["Source"] = "if",
							["Type"] = "Keyword"
						},
						["Token_Then"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "then",
							["Type"] = "Keyword"
						},
						["Type"] = "IfStat"
					},
					[3] =  {
						["Body"] =  {
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["SemicolonList"] = {},
							["StatementList"] =  {
								[1] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[2] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Lhs"] = table,
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "BinopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[3] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[4] =  {
									["ExprList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Equals"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "=",
										["Type"] = "Symbol"
									},
									["Token_ExprCommaList"] = {},
									["Token_Local"] =  {
										["LeadingWhite"] = "",
										["Source"] = "local",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] = {},
									["Type"] = "LocalVarStat",
									["TypeList"] = {},
									["VarList"] =  {
										[1] = table
									}
								},
								[5] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Lhs"] = table,
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "BinopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[6] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["Condition"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Rhs"] = table,
										["Token_Op"] = table,
										["Type"] = "UnopExpr"
									},
									["ElseClauseList"] = {},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_If"] =  {
										["LeadingWhite"] = "",
										["Source"] = "if",
										["Type"] = "Keyword"
									},
									["Token_Then"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "then",
										["Type"] = "Keyword"
									},
									["Type"] = "IfStat"
								},
								[7] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["GeneratorList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Do"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "do",
										["Type"] = "Keyword"
									},
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_For"] =  {
										["LeadingWhite"] = "",
										["Source"] = "for",
										["Type"] = "Keyword"
									},
									["Token_GeneratorCommaList"] = {},
									["Token_In"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "in",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] =  {
										[1] = table
									},
									["Type"] = "GenericForStat",
									["VarList"] =  {
										[1] = table,
										[2] = table
									},
									["VarTypeList"] = {}
								},
								[8] =  {
									["Body"] =  {
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["SemicolonList"] = table,
										["StatementList"] = table,
										["Type"] = "StatList"
									},
									["GeneratorList"] =  {
										[1] = table
									},
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_Do"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "do",
										["Type"] = "Keyword"
									},
									["Token_End"] =  {
										["LeadingWhite"] = "",
										["Source"] = "end",
										["Type"] = "Keyword"
									},
									["Token_For"] =  {
										["LeadingWhite"] = "",
										["Source"] = "for",
										["Type"] = "Keyword"
									},
									["Token_GeneratorCommaList"] = {},
									["Token_In"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "in",
										["Type"] = "Keyword"
									},
									["Token_VarColonList"] = {},
									["Token_VarCommaList"] =  {
										[1] = table
									},
									["Type"] = "GenericForStat",
									["VarList"] =  {
										[1] = table,
										[2] = table
									},
									["VarTypeList"] = {}
								}
							},
							["Type"] = "StatList"
						},
						["GeneratorList"] =  {
							[1] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = " ",
										["Source"] = "pairs",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["FunctionArguments"] =  {
									["ArgList"] =  {
										[1] = table
									},
									["CallType"] = "ArgCall",
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token_CloseParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = ")",
										["Type"] = "Symbol"
									},
									["Token_CommaList"] = {},
									["Token_OpenParen"] =  {
										["LeadingWhite"] = "",
										["Source"] = "(",
										["Type"] = "Symbol"
									}
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Type"] = "CallExpr"
							}
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Token_Do"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "do",
							["Type"] = "Keyword"
						},
						["Token_End"] =  {
							["LeadingWhite"] = "",
							["Source"] = "end",
							["Type"] = "Keyword"
						},
						["Token_For"] =  {
							["LeadingWhite"] = "",
							["Source"] = "for",
							["Type"] = "Keyword"
						},
						["Token_GeneratorCommaList"] = {},
						["Token_In"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "in",
							["Type"] = "Keyword"
						},
						["Token_VarColonList"] = {},
						["Token_VarCommaList"] =  {
							[1] =  {
								["LeadingWhite"] = "",
								["Source"] = ",",
								["Type"] = "Symbol"
							}
						},
						["Type"] = "GenericForStat",
						["VarList"] =  {
							[1] =  {
								["LeadingWhite"] = " ",
								["Source"] = "playerName",
								["Type"] = "Ident"
							},
							[2] =  {
								["LeadingWhite"] = " ",
								["Source"] = "accessoryData",
								["Type"] = "Ident"
							}
						},
						["VarTypeList"] = {}
					}
				},
				["Type"] = "StatList"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["NameChain"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				},
				[2] =  {
					["LeadingWhite"] = "",
					["Source"] = "RenderUpdate",
					["Type"] = "Ident"
				}
			},
			["Token_ArgColonList"] = {},
			["Token_ArgCommaList"] = {},
			["Token_CloseParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = ")",
				["Type"] = "Symbol"
			},
			["Token_End"] =  {
				["LeadingWhite"] = "",
				["Source"] = "end",
				["Type"] = "Keyword"
			},
			["Token_Function"] =  {
				["LeadingWhite"] = "",
				["Source"] = "function",
				["Type"] = "Keyword"
			},
			["Token_NameChainSeparator"] =  {
				[1] =  {
					["LeadingWhite"] = "",
					["Source"] = ":",
					["Type"] = "Symbol"
				}
			},
			["Token_OpenParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = "(",
				["Type"] = "Symbol"
			},
			["Type"] = "FunctionStat"
		},
		[14] =  {
			["ArgList"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "otherSystems",
					["Type"] = "Ident"
				}
			},
			["ArgTypeList"] = {},
			["Body"] =  {
				["GetFirstToken"] = "function",
				["GetLastToken"] = "function",
				["SemicolonList"] = {},
				["StatementList"] =  {
					[1] =  {
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Lhs"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = "",
									["Source"] = "SystemsContainer",
									["Type"] = "Ident"
								},
								["Type"] = "VariableExpr"
							}
						},
						["Rhs"] =  {
							[1] =  {
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token"] =  {
									["LeadingWhite"] = " ",
									["Source"] = "otherSystems",
									["Type"] = "Ident"
								},
								["Type"] = "VariableExpr"
							}
						},
						["Token_Equals"] =  {
							["LeadingWhite"] = " ",
							["Source"] = "=",
							["Type"] = "Symbol"
						},
						["Token_LhsSeparatorList"] = {},
						["Token_RhsSeparatorList"] = {},
						["Type"] = "AssignmentStat"
					},
					[2] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "task",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "defer",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Type"] = "CallExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[3] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "workspace",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "ChildAdded",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[4] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "workspace",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "ChildRemoved",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					},
					[5] =  {
						["Expression"] =  {
							["Base"] =  {
								["Base"] =  {
									["GetFirstToken"] = "function",
									["GetLastToken"] = "function",
									["Token"] =  {
										["LeadingWhite"] = "",
										["Source"] = "ReplicatedData",
										["Type"] = "Ident"
									},
									["Type"] = "VariableExpr"
								},
								["Field"] =  {
									["LeadingWhite"] = "",
									["Source"] = "OnUpdate",
									["Type"] = "Ident"
								},
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_Dot"] =  {
									["LeadingWhite"] = "",
									["Source"] = ".",
									["Type"] = "Symbol"
								},
								["Type"] = "FieldExpr"
							},
							["FunctionArguments"] =  {
								["ArgList"] =  {
									[1] =  {
										["ArgList"] = table,
										["ArgTypeList"] = table,
										["Body"] = table,
										["GetFirstToken"] = "function",
										["GetLastToken"] = "function",
										["Token_ArgColonList"] = table,
										["Token_ArgCommaList"] = table,
										["Token_CloseParen"] = table,
										["Token_End"] = table,
										["Token_Function"] = table,
										["Token_OpenParen"] = table,
										["Type"] = "FunctionLiteral"
									}
								},
								["CallType"] = "ArgCall",
								["GetFirstToken"] = "function",
								["GetLastToken"] = "function",
								["Token_CloseParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = ")",
									["Type"] = "Symbol"
								},
								["Token_CommaList"] = {},
								["Token_OpenParen"] =  {
									["LeadingWhite"] = "",
									["Source"] = "(",
									["Type"] = "Symbol"
								}
							},
							["GetFirstToken"] = "function",
							["GetLastToken"] = "function",
							["Method"] =  {
								["LeadingWhite"] = "",
								["Source"] = "Connect",
								["Type"] = "Ident"
							},
							["Token_Colon"] =  {
								["LeadingWhite"] = "",
								["Source"] = ":",
								["Type"] = "Symbol"
							},
							["Type"] = "MethodExpr"
						},
						["GetFirstToken"] = "function",
						["GetLastToken"] = "function",
						["Type"] = "CallExprStat"
					}
				},
				["Type"] = "StatList"
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["NameChain"] =  {
				[1] =  {
					["LeadingWhite"] = " ",
					["Source"] = "Module",
					["Type"] = "Ident"
				},
				[2] =  {
					["LeadingWhite"] = "",
					["Source"] = "Init",
					["Type"] = "Ident"
				}
			},
			["Token_ArgColonList"] = {},
			["Token_ArgCommaList"] = {},
			["Token_CloseParen"] =  {
				["LeadingWhite"] = " ",
				["Source"] = ")",
				["Type"] = "Symbol"
			},
			["Token_End"] =  {
				["LeadingWhite"] = "",
				["Source"] = "end",
				["Type"] = "Keyword"
			},
			["Token_Function"] =  {
				["LeadingWhite"] = "",
				["Source"] = "function",
				["Type"] = "Keyword"
			},
			["Token_NameChainSeparator"] =  {
				[1] =  {
					["LeadingWhite"] = "",
					["Source"] = ":",
					["Type"] = "Symbol"
				}
			},
			["Token_OpenParen"] =  {
				["LeadingWhite"] = "",
				["Source"] = "(",
				["Type"] = "Symbol"
			},
			["Type"] = "FunctionStat"
		},
		[15] =  {
			["ExprList"] =  {
				[1] =  {
					["GetFirstToken"] = "function",
					["GetLastToken"] = "function",
					["Token"] =  {
						["LeadingWhite"] = " ",
						["Source"] = "Module",
						["Type"] = "Ident"
					},
					["Type"] = "VariableExpr"
				}
			},
			["GetFirstToken"] = "function",
			["GetLastToken"] = "function",
			["Token_CommaList"] = {},
			["Token_Return"] =  {
				["LeadingWhite"] = "",
				["Source"] = "return",
				["Type"] = "Keyword"
			},
			["Type"] = "ReturnStat"
		}
	},
	["Type"] = "StatList"
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">310dd1710dcb8bab030416e900030798</UniqueId>
					</Properties>
				</Item>
				<Item class="Script" referent="RBXE1409F3D8E9F45DFAEABCE2565D61C47">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Parser</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{D153B50E-6089-44F4-80EB-D50A7E874199}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService('HttpService')

local SampleData = require(script.Parent.Data)

local ScopeConnectionMap = {}
local ScopeRegistries = {}

local SkipTypeList = {'ReturnStat', 'GenericForStat', 'IfStat', 'AssignmentStat 1'}

local ParseHandlers = {
	LocalVarStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.SetVariableNodes, {statementIndex, data.Type, data, depth})
	end,
	FunctionStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CreateFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
	CallExprStat = function(scopeRegistry, statementIndex, data, depth)
		table.insert(scopeRegistry.CallFunctionNodes, {statementIndex, data.Type, data, depth})
	end,
}

function ParseStatementList(parentRegistryUUID, StatementList, depth)
	print('Step Depth; ', depth or 0)

	local currentRegistryUUID = HttpService:GenerateGUID(false)
	if ScopeConnectionMap[parentRegistryUUID] then
		table.insert(ScopeConnectionMap[parentRegistryUUID], currentRegistryUUID)
	else
		ScopeConnectionMap[parentRegistryUUID] = {currentRegistryUUID}
	end

	local scopeReg = {
		Depth = depth,
		SetVariableNodes = { },
		CreateFunctionNodes = { },
		CallFunctionNodes = { },
	}

	ScopeRegistries[currentRegistryUUID] = scopeReg

	for statementIndex, data in pairs( StatementList ) do
		local parsed = true
		if ParseHandlers[data.Type] then
			print('Parsed ; ', statementIndex, data.Type)
			ParseHandlers[data.Type](scopeReg, statementIndex, data, depth or 0)
		elseif table.find(SkipTypeList, data.Type) then
			print('Skipped ; ', data.Type, statementIndex)
			continue
		else
			parsed = false
		end
		if data.Body and data.Body.StatementList then
			parsed = true
			local _ = ParseStatementList(currentRegistryUUID, data.Body.StatementList, (depth or 0) + 1)
		end
		if not parsed then
			warn('Unsupported Type ; ', data.Type, statementIndex)
		end
	end

	return scopeReg
end

ParseStatementList(false, SampleData.StatementList) -- ModuleScript parse [Type : StatList]

print(ScopeConnectionMap)
local baseRegistryString = 'REGISTRY %s DEPTH %d || CALL FUNCTIONS (%d), CREATE FUNCTIONS (%d), SET VARIABLE (%d)'
for registryUUID, data in pairs( ScopeRegistries ) do
	print( string.format(baseRegistryString, registryUUID, data.Depth or 0, #data.CallFunctionNodes, #data.CreateFunctionNodes, #data.SetVariableNodes) )
end

print(string.rep('\n', 10))

for registryID, registryData in pairs(ScopeRegistries) do
	print('==== ', registryID, ' ====')
	for _, SetVariableNode in ipairs( registryData.SetVariableNodes ) do
		local statementIndex, dataType, data, depth = unpack(SetVariableNode)
		print('SET VARIABLE ; ', statementIndex, dataType, data.VarList[1].Source, depth)
	end
	for _, CreateFunctionNode in ipairs( registryData.CreateFunctionNodes ) do
		local statementIndex, dataType, data, depth = unpack(CreateFunctionNode)
		print('CREATE FUNCTION ; ', statementIndex, dataType, data.NameChain[#data.NameChain].Source, depth)
	end
	for _, functionCallNode in ipairs( registryData.CallFunctionNodes ) do
		local statementIndex, dataType, data, depth = unpack(functionCallNode)
		print('CALL FUNCTION ; ', statementIndex, dataType, depth)
	end
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">310dd1710dcb8bab030416e900030799</UniqueId>
					</Properties>
				</Item>
				<Item class="Script" referent="RBX7FCD97720BC441D7954E9DAF78E2DD44">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SampleTestData</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{06E9513B-CB65-4486-A797-131EE52BB0ED}</string>
						<ProtectedString name="Source"><![CDATA[warn('Character visuals - masks / gun skins / perks / etc')
local Players = game:GetService('Players')
local Teams = game:GetService('Teams')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ReplicatedAssets = ReplicatedStorage:WaitForChild('Assets')
local ReplicatedCore = require(ReplicatedStorage:WaitForChild('Core'))
local ReplicatedModules = require(ReplicatedStorage:WaitForChild('Modules'))
local ReplicatedData = ReplicatedCore.ReplicatedData
local ItemsModule = ReplicatedModules.Defined.Items
local SystemsContainer = {}
local CharacterCache = {}
local Module = {}

function Module:RenderUpdate()
	local renderData = ReplicatedData:GetData('RenderData')
	-- print(renderData)
	if typeof(renderData) ~= 'table' then
		return
	end

	for playerName, accessoryData in pairs(renderData) do
		local PlayerInstance = Players:FindFirstChild(playerName)
		if (not PlayerInstance) or PlayerInstance.Team == Teams.Props then
			continue
		end

		local CharacterInstance = workspace:FindFirstChild(playerName)
		local HeadInstance = CharacterInstance and CharacterInstance:FindFirstChild('Head')
		if (not CharacterInstance) or (not HeadInstance) then
			continue
		end

		if not CharacterCache[PlayerInstance] then
			CharacterCache[PlayerInstance] = { }
		end

		-- print(CharacterInstance:GetFullName(), accessoryData)

		-- remove all old accessories that are not equipped
		for accessoryID, accessoryInstance in pairs( CharacterCache[PlayerInstance] ) do
			if not table.find(accessoryData, accessoryID) then
				accessoryInstance:Destroy()
				CharacterCache[PlayerInstance][accessoryID] = nil
			end
		end

		-- equip new accessories and skip those that are equipped
		for _, accessoryID in ipairs( accessoryData ) do
			local accessoryConfig = ItemsModule:GetConfigFromID( accessoryID )
			if not accessoryConfig then
				warn('Cannot find the accessory config for ID ', accessoryID)
				continue
			end

			if not accessoryConfig.Model then
				warn('No model set for accessory of ID ', accessoryID)
				continue
			end

			local ModelInstance = ReplicatedAssets.Masks:FindFirstChild(accessoryConfig.Model)
			if not ModelInstance then
				warn('Could not find accessory instance named ', accessoryConfig.Model)
				continue
			end

			-- print(ModelInstance:GetFullName())

			ModelInstance = ModelInstance:Clone()
			ModelInstance:SetPrimaryPartCFrame( HeadInstance.CFrame )
			ReplicatedModules.Utility.Models:WeldConstraint( ModelInstance.PrimaryPart, HeadInstance )
			ModelInstance.Parent = CharacterInstance

			CharacterCache[PlayerInstance][accessoryID] = ModelInstance
		end
	end
end

function Module:Init( otherSystems )
	SystemsContainer = otherSystems

	task.defer(function()
		Module:RenderUpdate()
	end)

	workspace.ChildAdded:Connect(function(childInstance)
		if Players:FindFirstChild(childInstance.Name) then
			task.wait(0.1)
			Module:RenderUpdate()
		end
	end)

	workspace.ChildRemoved:Connect(function(childInstance)
		if Players:FindFirstChild(childInstance.Name) then
			Module:RenderUpdate()
		end
	end)

	ReplicatedData.OnUpdate:Connect(function(Category, _)
		if Category == 'PlayerData' then
			Module:RenderUpdate()
		end
	end)
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">310dd1710dcb8bab030416e90003079a</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Frame" referent="RBX4672BC21443141EBB02F07D6D6468D33">
			<Properties>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<token name="AutomaticSize">0</token>
				<Color3 name="BackgroundColor3">
					<R>0.639215708</R>
					<G>0.635294139</G>
					<B>0.647058845</B>
				</Color3>
				<float name="BackgroundTransparency">1</float>
				<Color3 name="BorderColor3">
					<R>0.105882362</R>
					<G>0.164705887</G>
					<B>0.207843155</B>
				</Color3>
				<token name="BorderMode">0</token>
				<int name="BorderSizePixel">1</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<int name="LayoutOrder">0</int>
				<string name="Name">Frame</string>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0</XS>
					<XO>0</XO>
					<YS>0</YS>
					<YO>0</YO>
				</UDim2>
				<Ref name="RootLocalizationTable">null</Ref>
				<float name="Rotation">0</float>
				<bool name="Selectable">false</bool>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<int name="SelectionOrder">0</int>
				<UDim2 name="Size">
					<XS>1</XS>
					<XO>0</XO>
					<YS>1</YS>
					<YO>0</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<int64 name="SourceAssetId">-1</int64>
				<token name="Style">0</token>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811ec</UniqueId>
				<bool name="Visible">true</bool>
				<int name="ZIndex">1</int>
			</Properties>
			<Item class="Frame" referent="RBXCDD93FA0CF1B4B8FA4F77FCBC6E858A4">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.168627456</R>
						<G>0.168627456</G>
						<B>0.168627456</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">ChartSelectFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.200000003</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811ed</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">0</int>
				</Properties>
				<Item class="TextButton" referent="RBX23714F123D7A43C3AE171DCF4C0E1BFB">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.36470589</R>
							<G>0.36470589</G>
							<B>0.36470589</B>
						</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
							<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Bold.ttf</url></CachedFaceId>
						</Font>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Button</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Tree Node</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f0</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIPadding" referent="RBX9C4B7B52C7214C7590EFBA471D9B9CFD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f5</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX8934C2F202BA457CA9EC62F1B984E116">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.36470589</R>
							<G>0.36470589</G>
							<B>0.36470589</B>
						</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
							<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Bold.ttf</url></CachedFaceId>
						</Font>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Button</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Tree Node</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f1</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIPadding" referent="RBXA0B9D816F92F4ABC825A7022A8901BC1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f6</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXB0EF6DB02ED340908723E66A6107C280">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.36470589</R>
							<G>0.36470589</G>
							<B>0.36470589</B>
						</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
							<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Bold.ttf</url></CachedFaceId>
						</Font>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Button</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Tree Node</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f2</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIPadding" referent="RBX514B5ADD0C3B40D0B96621AC499FFCAA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f7</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="UIGridLayout" referent="RBXC8A031BB4ADF47668FE728D5511BF1B9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UDim2 name="CellPadding">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0.00999999978</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="CellSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="FillDirection">0</token>
						<int name="FillDirectionMaxCells">0</int>
						<token name="HorizontalAlignment">1</token>
						<string name="Name">UIGridLayout</string>
						<token name="SortOrder">2</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="StartCorner">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f4</UniqueId>
						<token name="VerticalAlignment">1</token>
					</Properties>
					<Item class="UIAspectRatioConstraint" referent="RBX8D211873A7E24B2E828AF53436729F76">
						<Properties>
							<float name="AspectRatio">3.5</float>
							<token name="AspectType">1</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="DominantAxis">0</token>
							<string name="Name">UIAspectRatioConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f3</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="UIPadding" referent="RBX03CAE778582B48EFAAB4C4711CE5B345">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">UIPadding</string>
						<UDim name="PaddingBottom">
							<S>0</S>
							<O>0</O>
						</UDim>
						<UDim name="PaddingLeft">
							<S>0.0199999996</S>
							<O>0</O>
						</UDim>
						<UDim name="PaddingRight">
							<S>0.0199999996</S>
							<O>0</O>
						</UDim>
						<UDim name="PaddingTop">
							<S>0.00999999978</S>
							<O>0</O>
						</UDim>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811f8</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Frame" referent="RBXE2FE5BBD4E55488C952C20B13705C5F2">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.23137255</R>
						<G>0.23137255</G>
						<B>0.23137255</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">SeparatorFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.200000003</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811ee</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">0</int>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBXE1FA37A30F7646E09A7639123A9EC153">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.168627456</R>
						<G>0.168627456</G>
						<B>0.168627456</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">FlowChartFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.204999998</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.795000017</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">24a3b9a257fa3c1e03154fe1000811ef</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">0</int>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX955819DCB27540DF81C14C4F2B05C780">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7108</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBX1D5A7C3F0D224E50A729F66D69C24B9D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b710f</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX8B252109F79A4112A6E50D5020548E89">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7110</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX4905902FBBFB4EE7A6111BAF5D13FB39">
		<Properties>
			<Color3 name="Ambient">
				<R>0.541176498</R>
				<G>0.541176498</G>
				<B>0.541176498</B>
			</Color3>
			<BinaryString name="AttributesSerialize">AQAAABIAAABVc2VDdXJyZW50TGlnaHRpbmcDAA==</BinaryString>
			<float name="Brightness">2</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.501960814</R>
				<G>0.501960814</G>
				<B>0.501960814</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">3</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7135</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX6E5E59C4ECD54F79B61D30F59328E0AD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7138</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX8FBBB525616D4D86966861228946263A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7257</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX68E09B5347824EFCB152EEA0CBFCF523">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b725e</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBXB20985CD4DE54137BC3DF60E70BF159F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004e7e77</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXA467A0A494764DF2A3808DC5EA03B96A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7264</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBXF646C24B954541B5932BC37BDEBDADB3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">44b188dace632b4702e9c68d004b7265</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX2F41C0C18333414E88CF8E07A1B69096">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Enabled">true</bool>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5c33de30e8b23bd60301373a0003064a</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>